Tutoraials -
	
A) Complete beginners
	1) JavaScript basics -
	* JavaScript is a programming language that adds interactivity to your website
	
	
	2) JavaScript first steps
	3) JavaScript building blocks
	4) Introducing JavaScript objects

B) JS Guide
  	Grammar and types
	Control flow and error handling
	Loops and iteration
	Functions
	Expressions and operators
	Numbers and dates
	Text formatting
	Regular expressions
	Indexed collections
	Keyed collections
	Working with objects
	Using classes
	Using promises
	JavaScript typed arrays
	Iterators and generators
	Meta programming
	JavaScript modules
C) Intermediate	
	1) Client-side JavaScript frameworks
	2) Client-side web APIs
	3) Language overview
	4) JavaScript data structures
	5) Equality comparisons and sameness
	6) Enumerability and ownership of properties
	7) Closures -
		* a closure gives you access to an outer function's scope from an inner function 
	

D) Advanced
	1) Inheritance and the prototype chain
		* In programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an existing one.
		* JavaScript implements inheritance by using objects
		* Each object has an internal link to another object called its prototype.
		* That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype
	 Inheritance with the prototype chain
	* Inheriting Properties - 
		* The [[Prototype]] internal slot can be accessed and modified with the Object.getPrototypeOf() and Object.setPrototypeOf() functions respectively. This is equivalent to the JavaScript accessor __proto__ which is non-standard but de-facto implemented by many JavaScript engines.
		* const o = {
			  a: 1,
			  b: 2,
			  // __proto__ sets the [[Prototype]]. It's specified here
			  // as another object literal.
			  __proto__: {
			    b: 3,
			    c: 4,
			  },
			};
		// Thus, the full prototype chain looks like:
		// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> Object.prototype ---> null
		
		* console.log(o.b); // 2
		// Is there a 'b' own property on o? Yes, and its value is 2.
		// The prototype also has a 'b' property, but it's not visited.
		// This is called Property Shadowing

		* console.log(o.d); // undefined
		// no property found, return undefined.

	* Inheriting "methods" -
		* In JavaScript, any function can be added to an object in the form of a property. An inherited function acts just as any other property, including property shadowing as shown above (in this case, a form of method overriding).
		* When an inherited function is executed, the value of this points to the inheriting object, not to the prototype object where the function is an own property

	* Constructors -
		* The power of prototypes is that we can reuse a set of properties if they should be present on every instance — especially for methods
		* const boxPrototype = {
		  getValue() {
		    return this.value;
		  },
		};
		
		const boxes = [
		  { value: 1, __proto__: boxPrototype },
		  { value: 2, __proto__: boxPrototype },
		  { value: 3, __proto__: boxPrototype },
		];
		* so for creating object with prototype, we can use function constructor
	
	* using classes -
		class Box {
		  constructor(value) {
		    this.value = value;
		  }
		
		  // Methods are created on Box.prototype
		  getValue() {
		    return this;
		  } 
		   getc = () => {return this}   // Methods are created on Object created by " new Box(5) "
		}


	* Implicit constructors of literals
		* // Object literals (without the `__proto__` key) automatically
		// have `Object.prototype` as their `[[Prototype]]`
		const object = { a: 1 };
		Object.getPrototypeOf(object) === Object.prototype; // true
		
		// Array literals automatically have `Array.prototype` as their `[[Prototype]]`
		const array = [1, 2, 3];
		Object.getPrototypeOf(array) === Array.prototype; // true
		
		// RegExp literals automatically have `RegExp.prototype` as their `[[Prototype]]`
		const regexp = /abc/;
		Object.getPrototypeOf(regexp) === RegExp.prototype; // true


		* Number.prototype + 1; // 1
		Array.prototype.map((x) => x + 1); // []
		String.prototype + "a"; // "a"
		RegExp.prototype.source; // "(?:)"
		Function.prototype(); // Function.prototype is a no-op function by itself

	* Inspecting prototypes: a deeper dive
		* function doSomething() {}
		console.log(doSomething.prototype);
		// It does not matter how you declare the function; a
		// function in JavaScript will always have a default
		// prototype property — with one exception: an arrow
		// function doesn't have a default prototype property:
		const doSomethingFromArrowFunction = () => {};
		console.log(doSomethingFromArrowFunction.prototype);


	* Different ways of creating and mutating prototype chains -
		* Objects created with syntax constructs -
		* need to learn 


	2) Memory Management
		* JavaScript automatically allocates memory when objects are created and frees it when they are not used anymore (garbage collection)
		* The main concept that garbage collection algorithms rely on is the concept of reference.
		* Regardless of the programming language, the memory life cycle is pretty much always the same:
			1. Allocate the memory you need
			2. Use the allocated memory (read, write)
			3. Release the allocated memory when it is not needed anymore
			The second part is explicit in all languages. The first and last parts are explicit in low-level languages but are mostly implicit in high-level languages like JavaScript.
		* Some high-level languages, such as JavaScript, utilize a form of automatic memory management known as garbage collection (GC). The purpose of a garbage collector is to monitor memory allocation and determine when a block of allocated memory is no longer needed and reclaim it.
		* Mark-and-sweep algorithm - This algorithm reduces the definition of "an object is no longer needed" to "an object is unreachable". In this algorithm, all objects get marked which has referenced with variables. After this, it delete all unmarked objects.
		* Although JavaScript does not directly expose the garbage collector API, the language offers several data structures that indirectly observe garbage collection and can be used to manage memory usage.

		* need to learn 
			about WeakMaps and WeakSets, WeakRefs and FinalizationRegistry ......
	
	3) Concurrency model and Event Loop - 
		* JavaScript has a runtime model based on an event loop.
		* Here, we saw how event loop works. It's same as tony described. There's image which show how event loop works
		* In that image, they mention heap, stack, and queue
		* Heap - Objects are allocated in a heap which is just a name to denote a large (mostly unstructured) region of memory.
		* Stack - Here, we add execution context on each other
		* queue (Event Queue) - where async operations are added here.
		* In Event loop, sometime async operations have to wait more than given time bcz it might have already opeartions in queue
		* A very interesting property of the event loop model is that JavaScript, unlike a lot of other languages, never blocks.
------------------
References:

A) Built-in objects -
	1) AggregateError -
    		* The AggregateError object represents an error when several errors need to be wrapped in a single error. It is thrown when multiple errors need to be reported by an operation, for example by Promise.any(), when all promises passed to it reject.

	    constructor -
	      * AggregateError() - Creates a new AggregateError object.
	
	    Instance properties
	      * AggregateError.prototype.message - Error message. Inherited from Error.
	
	      * AggregateError.prototype.name - Error name. Inherited from Error.
	
	      * AggregateError.prototype.cause - Error cause. Inherited from Error.
	
	      * AggregateError.prototype.errors -
	      An array that essentially reflects the iterable with which the AggregateError was instantiated; for example, if the AggregateError was created using the AggregateError() constructor, an array produced from whatever iterable was passed to the constructor as its first argument.

	2) Array
	3) ArrayBuffer
	4) AsyncFunction
	5) AsyncGenerator
	6) AsyncGeneratorFunction
	7) AsyncIterator
	8) Atomics
	9) BigInt
	10) BigInt64Array
	11) BigUint64Array
	12) Boolean
	13) DataView
	14) Date
	15) decodeURI()
	16) decodeURIComponent()
	17) encodeURI()
	18) encodeURIComponent()
	19) Error
	20) escape() Deprecated
	21) eval()
	22) EvalError
	23) FinalizationRegistry
	24) Float32Array
	25) Float64Array
	26) Function
	27) Generator
	28) GeneratorFunction
	29) globalThis
	30) Infinity
	31) Int16Array
	32) Int32Array
	33) Int8Array
	34) InternalErrorNon-standard
	35) Intl
	36) isFinite()
	37) isNaN()
	38) Iterator
	39) JSON
	40) Map
	41) Math
	42) NaN
	43) Number
	44) Object
	45) parseFloat()
	46) parseInt()
	47) Promise
	48) Proxy
	49) RangeError
	50) ReferenceError
	51) Reflect
	52) RegExp
	53) Set
	54) SharedArrayBuffer
	55) String
	56) Symbol
	57) SyntaxError
	58) TypedArray
	59) TypeError
	60) Uint16Array
	61) Uint32Array
	62) Uint8Array
	63) Uint8ClampedArray
	64) undefined
	65) unescape()Deprecated
	66) URIError
	67) WeakMap
	68) WeakRef
	69) WeakSet



B) Expressions & operators
	1) Addition (+)
	2) Addition assignment (+=)
	3) Assignment (=)
	4) async function expression
	5) async function* expression
	6) await
	7) Bitwise AND (&)
	8) Bitwise AND assignment (&=)
	9) Bitwise NOT (~)
	10) Bitwise OR (|)
	11) Bitwise OR assignment (|=)
	12) Bitwise XOR (^)
	13) Bitwise XOR assignment (^=)
	14) class expression
	15) Comma operator (,)
	16) Conditional (ternary) operator
	17) Decrement (--)
	18) delete
	19) Destructuring assignment
	20) Division (/)
	21) Division assignment (/=)
	22) Equality (==)
	23) Exponentiation (**)
	24) Exponentiation assignment (**=)
	25) function expression
	26) function* expression
	27) Greater than (>)
	28) Greater than or equal (>=)
	29) Grouping operator ( )
	30) import.meta
	31) import()
	32) in
	33) Increment (++)
	34) Inequality (!=)
	35) instanceof
	36) Left shift (<<)
	37) Left shift assignment (<<=)
	38) Less than (<)
	39) Less than or equal (<=)
	40) Logical AND (&&)
	41) Logical AND assignment (&&=)
	42) Logical NOT (!)
	43) Logical OR (||)
	44) Logical OR assignment (||=)
	45) Multiplication (*)
	46) Multiplication assignment (*=)
	47) new
	48) new.target
	49) null
	50) Nullish coalescing assignment (??=)
	51) Nullish coalescing operator (??)
	52) Object initializer
	53) Operator precedence
	54) Optional chaining (?.)
	55) Property accessors
	56) Remainder (%)
	57) Remainder assignment (%=)
	58) Right shift (>>)
	59) Right shift assignment (>>=)
	60) Spread syntax (...)
	61) Strict equality (===)
	62) Strict inequality (!==)
	63) Subtraction (-)
	64) Subtraction assignment (-=)
	65) super
	66) this
	67) typeof
	68) Unary negation (-)
	69) Unary plus (+)
	70) Unsigned right shift (>>>)
	71) Unsigned right shift assignment (>>>=)
	72) void operator
	73) yield
	74) yield*

C) Statements & declarations
	1) async function - 
		The await keyword is permitted within the function body, enabling asynchronous, promise-based behaviour to be written in a cleaner style and avoiding the need to configure promise chains explicitly.
		* eg.
			function waitForData () {
			    return new Promise((res, rej) => {
			        setTimeout(() => {
			            res(10)
			        }, 3000)
			    })
			}
			console.log("before call");
			async function testAsyncFun(){
			    try {
			        console.log("line1");
			        const data = await waitForData();
			        console.log("line2", data);
			    } catch(e){
			        console.log("error", e)
			    }
			}
			testAsyncFun()
			console.log("outside line call");
		* In the above example, output like below -
			before call
			line1
			outside line call
			line2 10
		* Here, await help to stop execution till "waitForData" returns something and starts working on other code synchronously. once done with synchronous code, then moves to the "waitForData" function which is in microtask queues. 
		* Async functions can contain zero or more await expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of async and await enables the use of ordinary try / catch blocks around asynchronous code.
		* In situations like following - promise.all or promise.allSettled, don't use async await. 



	2) async function*
	3) block
	3) break
	4) class
	5) const
	6) continue
	7) debugger
	8) do...while
	9) empty
	
	10) Export
	* export statement is used when creating JavaScript modules to export live bindings to functions, objects, or primitive values from the module so they can be used by other programs with the import statement.
	* When a module updates the value of a binding that it exports, the update will be visible in its imported value.
	* two types of exports: 
		Named Exports (Zero or more exports per module),
		Default Exports (One per module)
	* Syntax -
		// Exporting individual features
		export let name1, name2, …, nameN; // also var, const
		export let name1 = …, name2 = …, …, nameN; // also var, const
		export function functionName(){...}
		export class ClassName {...}

		// Export list
		export { name1, name2, …, nameN };

		// Renaming exports
		export { variable1 as name1, variable2 as name2, …, nameN };

		// Exporting destructured assignments with renaming
		export const { name1, name2: bar } = o;

		// Default exports
		export default expression;
		export default function (…) { … } // also class, function*
		export default function name1(…) { … } // also class, function*
		export { name1 as default, … };

		// Aggregating modules
		export * from …; // does not set the default export
		export * as name1 from …; // ECMAScript® 2O20
		export { name1, name2, …, nameN } from …;
		export { import1 as name1, import2 as name2, …, nameN } from …;
		export { default, … } from …;

	* default export can be imported with any name. eg. import m from './test';
	* rename named exports to avoid naming conflicts. eg. export { myFunction as function1, myVariable as variable };
	* one can create a single module concentrating various exports from various modules.
		export { default as function1, function2 } from 'bar.js';
	* 


	* Description -
	11) Expression Statement
	11) for
	12) for await...of
	13) for...in
	14) for...of
	14) for
	15) function*
	16) function declaration
	17) if...else
	18) import.meta
	19) import
	20) label
	21) let
	22) return
	23) switch
	24) throw
	25) try...catch
	26) var
	27) while
	28) with


D) Regular Expressions 
	1) Backreference: \1, \2
	2) Capturing group: (...)
	3) Character class escape: \d, \D, \w, \W, \s, \S
	4) Character class: [...], [^...]
	5) Character escape: \n, \u{...}
	6) Disjunction: |
	7) Input boundary assertion: ^, $
	8) Literal character: a, b
	9) Lookahead assertion: (?=...), (?!...)
	10) Lookbehind assertion: (?<=...), (?<!...)
	11) Named backreference: \k<name>
	12) Named capturing group: (?<name>...)
	13) Non-capturing group: (?:...)
	14) Quantifier: *, +, ?, {n}, {n,}, {n,m}
	15) Unicode character class escape: \p{...}, \P{...}
	16) Wildcard: .
	17) Word boundary assertion: \b, \B


Reference Links -
* https://codedamn.com/news/programming/comprehensive-guide-javascript-event-loop ( Event Queue / Loop, microtask, async await)  


Points need to be done to improve interview -
async await
promise
prototype and its chain
class
call, apply, bind
object.create and object.assign
methods of array, object, string, number
date
event propagation
recursion
symbol
Iterators and generators
Map, set, 




