Tutoraials -
	
A) Complete beginners
	1) JavaScript basics -
	* JavaScript is a programming language that adds interactivity to your website
	
	
	2) JavaScript first steps
	3) JavaScript building blocks
	4) Introducing JavaScript objects

B) JS Guide
  	Grammar and types
	Control flow and error handling
	Loops and iteration
	Functions
	Expressions and operators
	Numbers and dates
	Text formatting
	Regular expressions
	Indexed collections
	Keyed collections
	Working with objects
	Using classes
	Using promises
	JavaScript typed arrays
	Iterators and generators
	Meta programming
	JavaScript modules
C) Intermediate	
	1) Client-side JavaScript frameworks
	2) Client-side web APIs
	3) Language overview
	4) JavaScript data structures
	5) Equality comparisons and sameness
	6) Enumerability and ownership of properties
	7) Closures -
		* a closure gives you access to an outer function's scope from an inner function 
	

D) Advanced
	1) Inheritance and the prototype chain
		* In programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an existing one.
		* JavaScript implements inheritance by using objects
		* Each object has an internal link to another object called its prototype.
		* That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype
	 Inheritance with the prototype chain
	* Inheriting Properties - 
		* The [[Prototype]] internal slot can be accessed and modified with the Object.getPrototypeOf() and Object.setPrototypeOf() functions respectively. This is equivalent to the JavaScript accessor __proto__ which is non-standard but de-facto implemented by many JavaScript engines.
		* const o = {
			  a: 1,
			  b: 2,
			  // __proto__ sets the [[Prototype]]. It's specified here
			  // as another object literal.
			  __proto__: {
			    b: 3,
			    c: 4,
			  },
			};
		// Thus, the full prototype chain looks like:
		// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> Object.prototype ---> null
		
		* console.log(o.b); // 2
		// Is there a 'b' own property on o? Yes, and its value is 2.
		// The prototype also has a 'b' property, but it's not visited.
		// This is called Property Shadowing

		* console.log(o.d); // undefined
		// no property found, return undefined.

	* Inheriting "methods" -
		* In JavaScript, any function can be added to an object in the form of a property. An inherited function acts just as any other property, including property shadowing as shown above (in this case, a form of method overriding).
		* When an inherited function is executed, the value of this points to the inheriting object, not to the prototype object where the function is an own property

	* Constructors -
		* The power of prototypes is that we can reuse a set of properties if they should be present on every instance — especially for methods
		* const boxPrototype = {
		  getValue() {
		    return this.value;
		  },
		};
		
		const boxes = [
		  { value: 1, __proto__: boxPrototype },
		  { value: 2, __proto__: boxPrototype },
		  { value: 3, __proto__: boxPrototype },
		];
		* so for creating object with prototype, we can use function constructor
	
	* using classes -
		class Box {
		  constructor(value) {
		    this.value = value;
		  }
		
		  // Methods are created on Box.prototype
		  getValue() {
		    return this;
		  } 
		   getc = () => {return this}   // Methods are created on Object created by " new Box(5) "
		}


	* Implicit constructors of literals
		* // Object literals (without the `__proto__` key) automatically
		// have `Object.prototype` as their `[[Prototype]]`
		const object = { a: 1 };
		Object.getPrototypeOf(object) === Object.prototype; // true
		
		// Array literals automatically have `Array.prototype` as their `[[Prototype]]`
		const array = [1, 2, 3];
		Object.getPrototypeOf(array) === Array.prototype; // true
		
		// RegExp literals automatically have `RegExp.prototype` as their `[[Prototype]]`
		const regexp = /abc/;
		Object.getPrototypeOf(regexp) === RegExp.prototype; // true


		* Number.prototype + 1; // 1
		Array.prototype.map((x) => x + 1); // []
		String.prototype + "a"; // "a"
		RegExp.prototype.source; // "(?:)"
		Function.prototype(); // Function.prototype is a no-op function by itself

	* Inspecting prototypes: a deeper dive
		* function doSomething() {}
		console.log(doSomething.prototype);
		// It does not matter how you declare the function; a
		// function in JavaScript will always have a default
		// prototype property — with one exception: an arrow
		// function doesn't have a default prototype property:
		const doSomethingFromArrowFunction = () => {};
		console.log(doSomethingFromArrowFunction.prototype);


	* Different ways of creating and mutating prototype chains -
		* Objects created with syntax constructs -
		* need to learn 


	2) Memory Management
		* JavaScript automatically allocates memory when objects are created and frees it when they are not used anymore (garbage collection)
		* The main concept that garbage collection algorithms rely on is the concept of reference.
		* Regardless of the programming language, the memory life cycle is pretty much always the same:
			1. Allocate the memory you need
			2. Use the allocated memory (read, write)
			3. Release the allocated memory when it is not needed anymore
			The second part is explicit in all languages. The first and last parts are explicit in low-level languages but are mostly implicit in high-level languages like JavaScript.
		* Some high-level languages, such as JavaScript, utilize a form of automatic memory management known as garbage collection (GC). The purpose of a garbage collector is to monitor memory allocation and determine when a block of allocated memory is no longer needed and reclaim it.
		* Mark-and-sweep algorithm - This algorithm reduces the definition of "an object is no longer needed" to "an object is unreachable". In this algorithm, all objects get marked which has referenced with variables. After this, it delete all unmarked objects.
		* Although JavaScript does not directly expose the garbage collector API, the language offers several data structures that indirectly observe garbage collection and can be used to manage memory usage.

		* need to learn 
			about WeakMaps and WeakSets, WeakRefs and FinalizationRegistry ......
	
	3) Concurrency model and Event Loop - 
		* JavaScript has a runtime model based on an event loop.
		* Here, we saw how event loop works. It's same as tony described. There's image which show how event loop works
		* In that image, they mention heap, stack, and queue
		* Heap - Objects are allocated in a heap which is just a name to denote a large (mostly unstructured) region of memory.
		* Stack - Here, we add execution context on each other
		* queue (Event Queue) - where async operations are added here.
		* In Event loop, sometime async operations have to wait more than given time bcz it might have already opeartions in queue
		* A very interesting property of the event loop model is that JavaScript, unlike a lot of other languages, never blocks.
------------------
References:

A) Built-in objects -
	1) AggregateError -
    		* The AggregateError object represents an error when several errors need to be wrapped in a single error. It is thrown when multiple errors need to be reported by an operation, for example by Promise.any(), when all promises passed to it reject.

	    constructor -
	      * AggregateError() - Creates a new AggregateError object.
	
	    Instance properties
	      * AggregateError.prototype.message - Error message. Inherited from Error.
	
	      * AggregateError.prototype.name - Error name. Inherited from Error.
	
	      * AggregateError.prototype.cause - Error cause. Inherited from Error.
	
	      * AggregateError.prototype.errors -
	      An array that essentially reflects the iterable with which the AggregateError was instantiated; for example, if the AggregateError was created using the AggregateError() constructor, an array produced from whatever iterable was passed to the constructor as its first argument.

	2) Array
	3) ArrayBuffer
	4) AsyncFunction
	5) AsyncGenerator
	6) AsyncGeneratorFunction
	7) AsyncIterator
	8) Atomics
	9) BigInt
	10) BigInt64Array
	11) BigUint64Array
	12) Boolean
	13) DataView
	14) Date
	15) decodeURI()
	16) decodeURIComponent()
	17) encodeURI()
	18) encodeURIComponent()
	19) Error
	20) escape() Deprecated
	21) eval()
	22) EvalError
	23) FinalizationRegistry
	24) Float32Array
	25) Float64Array
	26) Function
	27) Generator
	28) GeneratorFunction
	29) globalThis
	30) Infinity
	31) Int16Array
	32) Int32Array
	33) Int8Array
	34) InternalErrorNon-standard
	35) Intl
	36) isFinite()
	37) isNaN()
	38) Iterator
	39) JSON
	40) Map
	41) Math
	42) NaN
	43) Number
	44) Object
	45) parseFloat()
	46) parseInt()
	47) Promise
	48) Proxy
	49) RangeError
	50) ReferenceError
	51) Reflect
	52) RegExp
	53) Set
	54) SharedArrayBuffer
	55) String
	56) Symbol
	57) SyntaxError
	58) TypedArray
	59) TypeError
	60) Uint16Array
	61) Uint32Array
	62) Uint8Array
	63) Uint8ClampedArray
	64) undefined
	65) unescape()Deprecated
	66) URIError
	67) WeakMap
	68) WeakRef
	69) WeakSet



B) Expressions & operators
	1) Addition (+) -
		* The addition (+) operator produces the sum of numeric operands or string concatenation.
		* ex. console.log(2 + 3)
		* The + operator is overloaded for two distinct operations: numeric addition and string concatenation. When evaluating, it first coerces both operands to primitives. Then, the two operands' types are tested:-
			1) If one side is a string, the other operand is also converted to a string and they are concatenated.
			2) If they are both BigInts, BigInt addition is performed. If one side is a BigInt but the other is not, a TypeError is thrown.
			3) Otherwise, both sides are converted to numbers, and numeric addition is performed.
				// Number addition
				1 + 2; // 3 		// Number + Number -> addition
				true + 1; // 2		// Boolean + Number -> addition	
				false + false; // 0	// Boolean + Boolean -> addition

				// BigInt addition
				1n + 2n; // 3n		// BigInt + BigInt -> addition
				1n + 2; // TypeError: Cannot mix BigInt and other types, use explicit conversions	// BigInt + Number -> throws TypeError
				1n + BigInt(2); // 3n		// To add a BigInt to a non-BigInt, convert either operand
				Number(1n) + 2; // 3

				// String concatenation
				"foo" + "bar"; // "foobar"		// String + String -> concatenation
				5 + "foo"; // "5foo"			// Number + String -> concatenation
				"foo" + false; // "foofalse"		// String + Boolean -> concatenation
				"2" + 2; // "22"			// String + Number -> concatenation

		* String concatenation is often thought to be equivalent with template literals or String.prototype.concat(), but they are not. Addition coerces the expression to a primitive, which calls valueOf() in priority; on the other hand, template literals and concat() coerce the expression to a string, which calls toString() in priority. If the expression has a @@toPrimitive method, string concatenation calls it with "default" as hint, while template literals use "string". This is important for objects that have different string and primitive representations — such as Temporal, whose valueOf() method throws.




	2) Addition assignment (+=) -
		* The addition assignment (+=) operator performs addition (which is either numeric addition or string concatenation) on the two operands and assigns the result to the left operand.
		* x += y is equivalent to x = x + y, except that the expression x is only evaluated once.
		* Own Notes - 
			* operand coerce as per other operand if require
			* value must comes in string, number or NaN. hence coerce other value if both are not same.
			
		ex. 	
		// boolean 
		let boolean1 = true
		// boolean1 += true //2
		// boolean1 += "check"  //"truecheck"
		// boolean1 += 4        //5
		// boolean1 += undefined    //NaN
		// boolean1 += null         //1     // null converts to 0
		// boolean1 + [2,3,5]       //"true2,3,5"
		// boolean1 + []            //"true"
		// boolean1 + {}            //"true[object Object]"
		
		
		// String
		let names = "sumeet";
		// names += true            //"sumeettrue"
		// name += "sddsd"          //'sumeetsddsd'
		// name += 5                //'sumeet5'
		// name += undefined        //"sumeetundefined"
		// name += null             //"sumeetnull"
		// name += [21,34,55]       // 'sumeet21,34,55'
		// name += {}               //'sumeet[object Object]'
		
		
		// number
		let number1 = 5
		// number1  += true         // 6
		// number1  += "check"      // '4check'
		// number1  += 5            // 10
		// number1  += undefined    // NaN
		// number1  += null         // 5
		// number1  += [2,3,4]      // '52,3,4'
		// number1  += {}           // '5[object Object]'
		
		// undefined
		let undefined1;
		// undefined1 += true       // NaN
		// undefined1 += "check"    // 'undefinedcheck'
		// undefined1 += 5          // NaN
		// undefined1  += undefined    // NaN
		// undefined1  += null         // NaN
		// undefined1  += [2,3,4]      // 'undefined2,3,4'
		// undefined1  += {}           // 'undefined[object Object]'
		
		
		// null
		let null1 = null;
		// null1 += true            // 1 
		// null1 += "check"         // 'nullcheck'
		// null1 += 5               // 5
		// null1  += undefined      // NaN
		// null1  += null           // 0
		// null1  += [2,3,4]        // 'null2,3,4'
		// null1  += {}             // error
		
		
		// Array
		let array1 = [2,4];
		// array1 += true            // '2,4true'
		// array1 += "check"         // '2,4check'
		// array1 += 5               // '2,45'
		// array1  += undefined      // '2,4undefined'
		// array1  += null           // '2,4null'
		// array1  += [2,3,4]        // '2,42,3,4'
		// array1  += {}             // '2,4[object Object]'
		
		
		// object
		let object1 = {name:"sumeet"}
		// object1 += true            //  '[object Object]true'
		// object1 += "check"         //  '[object Object]check'
		// object1 += 5               //  '[object Object]5'
		// object1  += undefined      //  '[object Object]undefined'
		// object1  += null           //  '[object Object]null'
		// object1  += [2,3,4]        //  '[object Object]2,3,4'
		// object1  += {}             //  '[object Object][object Object]'


	3) Assignment (=)
		* The assignment (=) operator is used to assign a value to a variable or property. The assignment expression itself has a value, which is the assigned value. This allows multiple assignments to be chained in order to assign a single value to multiple variables.
		* Description - The assignment operator is completely different from the equals (=) sign used as syntactic separators in other locations, which include:
			Initializers of var, let, and const declarations
			Default values of destructuring
			Default parameters
			Initializers of class fields
		* All these places accept an assignment expression on the right-hand side of the =, so if you have multiple equals signs chained together:
			const x = y = 5;	this is equivalent to => 	const x = (y = 5);
		* Which means y must be a pre-existing variable, and x is a newly declared const variable. y is assigned the value 5, and x is initialized with the value of the y = 5 expression, which is also 5. If y is not a pre-existing variable, a global variable y is implicitly created in non-strict mode, or a ReferenceError is thrown in strict mode. To declare two variables within the same declaration, use:


		*  To declare two variables within the same declaration, use:  const x = 5, y = 5;

		* Examples -
			let x = 2;
			x = x + 3
			const x = y = 5;		//x = 5, y = 5
		1) Simple assignment and chaining
			let x = 5;
			let y = 10;
			let z = 25;
			
			x = y; // x is 10
			x = y = z; // x, y and z are all 25
		2) Unqualified identifier assignment - need to understand

		3) Assignment with destructuring
		const result = /(a+)(b+)(c+)/.exec("aaabcc");
			let a = "", b = "", c = "";
			[, a, b, c] = result;
			console.log(a, b, c); // "aaa" "b" "cc"

		

	4) async function expression 
		* The async function keywords can be used to define an async function inside an expression.
		syntax.
			async function (param1, param2,....., paramN) { }	// for anonymous function
			async function name (param1, param2,....., paramN) { }	// for function
		* The main difference between an async function expression and an async function declaration is the function name, which can be omitted in async function expressions to create anonymous functions.
		*  An async function expression can be used as an IIFE (Immediately Invoked Function Expression) which runs as soon as it is defined, allowing you to mimic top-level await.
			
		* example -
		function resolveAfter2Seconds(x) {
		  return new Promise((resolve) => {
		    setTimeout(() => {
		      resolve(x);
		    }, 2000);
		  });
		}
		
		// async function expression assigned to a variable
		const add = async function (x) {
		  const a = await resolveAfter2Seconds(20);
		  const b = await resolveAfter2Seconds(30);
		  return x + a + b;
		};
		
		add(10).then((v) => {
		  console.log(v); // prints 60 after 4 seconds.
		});
		
		// async function expression used as an IIFE
		(async function (x) {
		  const p1 = resolveAfter2Seconds(20);
		  const p2 = resolveAfter2Seconds(30);
		  return x + (await p1) + (await p2);
		})(10).then((v) => {
		  console.log(v); // prints 60 after 2 seconds.
		});



	5) async function* expression
		* The async function* keywords can be used to define an async generator function inside an expression.
		need to understand



	6) await
		* The await operator is used to wait for a Promise and get its fulfillment value. It can only be used inside an async function or at the top level of a module.
		* await is usually used to unwrap promises by passing a Promise as the expression. Using await pauses the execution of its surrounding async function until the promise is settled.
		* the await expression never blocks the main thread and only defers execution of code that actually depends on the result, i.e. anything after the await expression.
		need to understand

	7) Bitwise AND (&) -
		* The bitwise AND (&) operator returns a number or BigInt whose binary representation has a 1 in each bit position for which the corresponding bits of both operands are 1.
		ex. 
			const a = 5; // 00000000000000000000000000000101
			const b = 3; // 00000000000000000000000000000011
			
			console.log(a & b); // 00000000000000000000000000000001
			// Expected output: 1


	8) Bitwise AND assignment (&=)
		* The bitwise AND assignment (&=) operator performs bitwise AND on the two operands and assigns the result to the left operand.
		ex.
			let a = 5; // 00000000000000000000000000000101
			a &= 3; // 00000000000000000000000000000011
			
			console.log(a); // 00000000000000000000000000000001
			// Expected output: 1
		* x &= y is equivalent to x = x & y, except that the expression x is only evaluated once.
		* Description -
			* The & operator is overloaded for two types of operands: number and BigInt. For numbers, the operator returns a 32-bit integer. For BigInts, the operator returns a BigInt. It first coerces both operands to numeric values and tests the types of them. It performs BigInt AND if both operands become BigInts; otherwise, it converts both operands to 32-bit integers and performs number bitwise AND. A TypeError is thrown if one operand becomes a BigInt but the other becomes a number.
			* The operator operates on the operands' bit representations in two's complement. Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on. The operator is applied to each pair of bits, and the result is constructed bitwise.
			




	9) Bitwise NOT (~)
		* The bitwise NOT (~) operator returns a number or BigInt whose binary representation has a 1 in each bit position for which the corresponding bit of the operand is 0, and a 0 otherwise.
		ex. 
			const a = 5; // 00000000000000000000000000000101
			const b = -3; // 11111111111111111111111111111101
			
			console.log(~a); // 11111111111111111111111111111010
			// Expected output: -6
			
			console.log(~b); // 00000000000000000000000000000010
			// Expected output: 2


	10) Bitwise OR (|)
		* The bitwise OR (|) operator returns a number or BigInt whose binary representation has a 1 in each bit position for which the corresponding bits of either or both operands are 1.
		ex.
			const a = 5; // 00000000000000000000000000000101
			const b = 3; // 00000000000000000000000000000011
			
			console.log(a | b); // 00000000000000000000000000000111
			// Expected output: 7
		ex. 
			// 9  (00000000000000000000000000001001)
			// 14 (00000000000000000000000000001110)
			
			14 | 9;		// 15 (00000000000000000000000000001111)
			
			14n | 9n; 	// 15n


	11) Bitwise OR assignment (|=)
		* The bitwise OR assignment (|=) operator performs bitwise OR on the two operands and assigns the result to the left operand.
		ex.
			let a = 5; // 00000000000000000000000000000101
			a |= 3; // 00000000000000000000000000000011
			
			console.log(a); // 00000000000000000000000000000111
			// Expected output: 7


	12) Bitwise XOR (^)
		* The bitwise XOR (^) operator returns a number or BigInt whose binary representation has a 1 in each bit position for which the corresponding bits of either but not both operands are 1.
		ex.	
			const a = 5; // 00000000000000000000000000000101
			const b = 3; // 00000000000000000000000000000011
			
			console.log(a ^ b); // 00000000000000000000000000000110
			// Expected output: 6


	13) Bitwise XOR assignment (^=)
		* The bitwise XOR assignment (^=) operator performs bitwise XOR on the two operands and assigns the result to the left operand.
		ex.
			let a = 5; // 00000000000000000000000000000101
			a ^= 3; // 00000000000000000000000000000011
			
			console.log(a); // 00000000000000000000000000000110
			// Expected output: 6


	14) class expression
		* The class keyword can be used to define a class inside an expression.
		* The main difference between a class expression and a class declaration is the class name, which can be omitted in class expressions to create anonymous classes.
		* A simple class expression -
		const rec = class {
		  constructor(h, w){
		    this.h = h;
		    this.w = w;
		  }
		  area(){
		    return this.h * this.w
		  }
		}
		console.log(new Rectangle(5, 8).area());
		// Expected output: 40

		* Named class expressions - If you want to refer to the current class inside the class body, you can create a named class expression. The name is only visible within the scope of the class expression itself.
		const Foo = class NamedFoo {
			constructor(){}
		}


 
	15) Comma operator (,) -
		* The comma (,) operator evaluates each of its operands (from left to right) and returns the value of the last operand. This is commonly used to provide multiple updaters to a for loop's afterthought.
		* Syntax - One or more expressions, the last of which is returned as the value of the compound expression.

		* need to understand

	16) Conditional (ternary) operator -
		* syntax.	condition ? exprIfTrue : exprIfFalse
		* Besides false, possible falsy expressions are: null, NaN, 0, the empty string (""), and undefined. If condition is any of these, the result of the conditional expression will be the result of executing the expression exprIfFalse.
		* Conditional chains - 
			 function example() {
				  return condition1 ? value1
				    : condition2 ? value2
				    : condition3 ? value3
				    : value4;
				}

	17) Decrement (--)
		* The decrement (--) operator decrements (subtracts one from) its operand and returns the value before or after the decrement, depending on where the operator is placed.
		ex.
			let x = 3;
			const y = x--;
			console.log(`x:${x}, y:${y}`);
			// Expected output: "x:2, y:3"
			
			let a = 3;
			const b = --a;
			console.log(`a:${a}, b:${b}`);
			// Expected output: "a:2, b:2"


	18) delete
		* The delete operator removes a property from an object. If the property's value is an object and there are no more references to the object, the object held by that property is eventually released automatically.
		ex.
			const Employee = {
			  firstname: 'Maria',
			  lastname: 'Sanchez',
			};
			
			console.log(Employee.firstname); 	// Expected output: "Maria"
			delete Employee.firstname;
			console.log(Employee.firstname);	// Expected output: undefined
		* need to understand 

	19) Destructuring assignment
		* The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables.
		ex.	
			let a, b, rest;
			[a, b] = [10, 20];
			console.log(a);		// Expected output: 10
			console.log(b);		// Expected output: 20
			[a, b, ...rest] = [10, 20, 30, 40, 50];
			console.log(rest);	// Expected output: Array [30, 40, 50]
		* syntax -
			const [a, b] = array;
			const [a, , b] = array;
			const [a = aDefault, b] = array;
			const [a, b, ...rest] = array;
			const [a, , b, ...rest] = array;
			const [a, b, ...{ pop, push }] = array;
			const [a, b, ...[c, d]] = array;
			
			const { a, b } = obj;
			const { a: a1, b: b1 } = obj;
			const { a: a1 = aDefault, b = bDefault } = obj;
			const { a, b, ...rest } = obj;
			const { a: a1, b: b1, ...rest } = obj;
			const { [key]: a } = obj;
			
			let a, b, a1, b1, c, d, rest, pop, push;
			[a, b] = array;
			[a, , b] = array;
			[a = aDefault, b] = array;
			[a, b, ...rest] = array;
			[a, , b, ...rest] = array;
			[a, b, ...{ pop, push }] = array;
			[a, b, ...[c, d]] = array;
			
			({ a, b } = obj); // parentheses are required
			({ a: a1, b: b1 } = obj);
			({ a: a1 = aDefault, b = bDefault } = obj);
			({ a, b, ...rest } = obj);
			({ a: a1, b: b1, ...rest } = obj);

		* Binding and assignment - 
			* In binding patterns, the pattern starts with a declaration keyword (var, let, or const). Then, each individual property must either be bound to a variable or further destructured.
				ex. const obj = { a: 1, b: { c: 2 } };
				const {  a, b: { c: d }, } = obj;	// Two variables are bound: `a` and `d`
	
			* All variables share the same declaration, so if you want some variables to be re-assignable but others to be read-only, you may have to destructure twice — once with let, once with const.
				ex. const obj = { a: 1, b: { c: 2 } };
				const { a } = obj; // a is constant
				let {  b: { c: d }, } = obj; // d is re-assignable
			* In assignment patterns, the pattern does not start with a keyword. Each destructured property is assigned to a target of assignment — which may either be declared beforehand with var or let, or is a property of another object — in general, anything that can appear on the left-hand side of an assignment expression.
				ex. const numbers = [];
				const obj = { a: 1, b: 2 };
				({ a: numbers[0], b: numbers[1] } = obj);
				// The properties `a` and `b` are assigned to properties of `numbers`
			* Note: 
				* The parentheses ( ... ) around the assignment statement are required when using object literal destructuring assignment without a declaration.
				* { a, b } = { a: 1, b: 2 } is not valid stand-alone syntax, as the { a, b } on the left-hand side is considered a block and not an object literal according to the rules of expression statements. However, ({ a, b } = { a: 1, b: 2 }) is valid, as is const { a, b } = { a: 1, b: 2 }.
				* If your coding style does not include trailing semicolons, the ( ... ) expression needs to be preceded by a semicolon, or it may be used to execute a function on the previous line.
		
		* Default value -
			* Each destructured property can have a default value. The default value is used when the property is not present, or has value undefined. It is not used if the property has value null.
			* ex. 	const [a = 1] = []; // a is 1
				const { b = 2 } = { b: undefined }; // b is 2
				const { c = 2 } = { c: null }; // c is null
			* The default value can be any expression. It will only be evaluated when necessary.
			* ex.	const { b = console.log("hey") } = { b: 2 };	// Does not log anything, because `b` is defined and there's no need to evaluate the default value.
		
		* Rest property  - You can end a destructuring pattern with a rest property ...rest. This pattern will store all remaining properties of the object or array into a new object or array.
			* ex. 	const { a, ...others } = { a: 1, b: 2, c: 3 };
				console.log(others); // { b: 2, c: 3 }
				const [first, ...others2] = [1, 2, 3];
				console.log(others2); // [2, 3]
		* Examples - take help from official docs

	20) Division (/) -
		* The division (/) operator produces the quotient of its operands where the left operand is the dividend and the right operand is the divisor.
		* ex.	console.log(12 / 2);	// Expected output: 6
			console.log(3 / 2);	// Expected output: 1.5
			console.log(6 / '3');	// Expected output: 2			
			console.log(2 / 0);	// Expected output: Infinity
		* The / operator is overloaded for two types of operands: number and BigInt. It first coerces both operands to numeric values and tests the types of them. It performs BigInt division if both operands become BigInts; otherwise, it performs number division. A TypeError is thrown if one operand becomes a BigInt but the other becomes a number.
		For BigInt division, the result is the quotient of the two operands truncated towards zero, and the remainder is discarded. A RangeError is thrown if the divisor y is 0n. This is because number division by zero returns Infinity or -Infinity, but BigInt has no concept of infinity.
		* ex.
			1 / 2; // 0.5
			Math.floor(3 / 2); // 1
			1.0 / 2.0; // 0.5
			
			1n / 2n; // 0n
			5n / 3n; // 1n
			-1n / 3n; // 0n
			1n / -3n; // 0n
			
			2n / 2; // TypeError: Cannot mix BigInt and other types, use explicit conversions
			
			// To do division with a BigInt and a non-BigInt, convert either operand
			2n / BigInt(2); // 1n
			Number(2n) / 2; // 1


	21) Division assignment (/=)
		* The division assignment (/=) operator performs division on the two operands and assigns the result to the left operand.
		* ex. 	let a = 3;
			a /= 2;
			console.log(a);			// Expected output: 1.5
			a /= 0;
			console.log(a);			// Expected output: Infinity
			a /= 'hello';
			console.log(a);			// Expected output: NaN
		* x /= y is equivalent to x = x / y, except that the expression x is only evaluated once.


	22) Equality (==) 
		* The equality (==) operator checks whether its two operands are equal, returning a Boolean result. Unlike the strict equality operator, it attempts to convert and compare operands that are of different types.
		*ex. 	console.log(1 == 1);		// Expected output: true
			console.log('hello' == 'hello');	// Expected output: true
			console.log('1' == 1);		// Expected output: true
			console.log(0 == false);	// Expected output: true
		* The equality operators (== and !=) provide the IsLooselyEqual semantic. This can be roughly summarized as follows:
		* need to understand


	23) Exponentiation (**) 
		* The exponentiation (**) operator returns the result of raising the first operand to the power of the second operand. It is equivalent to Math.pow(), except it also accepts BigInts as operands.
		* ex.	console.log(3 ** 4);			// Expected output: 81
			console.log(10 ** -2);			// Expected output: 0.01
			console.log(2 ** (3 ** 2));		// Expected output: 512
			console.log((2 ** 3) ** 2);		// Expected output: 64


	24) Exponentiation assignment (**=) -
		* The exponentiation assignment (**=) operator performs exponentiation on the two operands and assigns the result to the left operand.
		* x **= y is equivalent to x = x ** y, except that the expression x is only evaluated once.
		* ex.
						let a = 3;
						a **= 2;		// 9


	25) function expression -
		* The function keyword can be used to define a function inside an expression.
		* ex.
					const getArea = function(name){ console.log(name, this, arguments);}

		* The main difference between a function expression and a function declaration is the function name, which can be omitted in function expressions to create anonymous functions. A function expression can be used as an IIFE (Immediately Invoked Function Expression) which runs as soon as it is defined.
		* Function expressions in JavaScript are not hoisted, unlike function declarations. You can't use function expressions before you create them.
		* Named function expression - by providing a name for a function expression, it becomes a Named Function Expression.
		* ex.			
							const math = {
									factIt: function factorial(n){
												console.log(n);
												if(n <= 1){
													return 1;
												}
												return n * factorial(n - 1);
									}
							}
							math.factIt(3);
		* Using function expression - The following example defines an "unnamed function" and assigns it to x. The function returns the square of its argument:
				const x = function (y) {
						return y * y;
				}
			


	26) function* expression
	27) Greater than (>) -
		* The greater than (>) operator returns true if the left operand is greater than the right operand, and false otherwise.
		* ex. console.log( 5 > 3 );		// true
		* x > y is generally equivalent to y < x, except that x > y coerces x to a primitive before y, while y < x coerces y to a primitive before x. Because coercion may have side effects, the order of the operands may matter.
		* String to string comparison -
				"a" > "b"; // false
				"a" > "a"; // false
				"a" > "3"; // true
		* String to Number comparison -
				"5" > 3; // true
				"3" > 3; // false
				"3" > 5; // false
				
				"hello" > 5; // false
				5 > "hello"; // false
				
				"5" > 3n; // true
				"3" > 5n; // false
		* Number to number comparison -
				5 > 3; // true
				3 > 3; // false
				3 > 5; // false
		* Number to BigInt comparison -
				5n > 3; // true
				3 > 5n; // false
		* Comparing Boolean, null, undefined, NaN -
				true > false; // true
				false > true; // false
				
				true > 0; // true
				true > 1; // false
				
				null > 0; // false
				1 > null; // true
				
				undefined > 3; // false
				3 > undefined; // false
				
				3 > NaN; // false
				NaN > 3; // false



	28) Greater than or equal (>=) -
		* The greater than or equal (>=) operator returns true if the left operand is greater than or equal to the right operand, and false otherwise.
		* ex. console.log(5 >= 3);	// true
		* need to understand in depth


	29) Grouping operator ( ) -
		* The grouping ( ) operator controls the precedence of evaluation in expressions. It also acts as a container for arbitrary expressions in certain syntactic constructs, where ambiguity or syntax errors would otherwise occur.
		* need to understand in depth



	30) import.meta
	31) import() -
		* The import() syntax, commonly called dynamic import, is a function-like expression that allows loading an ECMAScript module asynchronously and dynamically into a potentially non-module environment.


	32) in -
		* The in operator returns true if the specified property is in the specified object or its prototype chain.
		* The in operator cannot be used to search for values in other collections. To test if a certain value exists in an array, use Array.prototype.includes(). For sets, use Set.prototype.has().
		* const car = { make: 'Honda', model: 'Accord', year: 1998 };
			console.log('make' in car);		// true
		* syntax - 
					prop in object
					#prop in object
		* Description -
			* If you want to check for only non-inherited properties, use Object.hasOwn() instead.
		* ex.
			// Arrays
			const trees = ["redwood", "bay", "cedar", "oak", "maple"];
			0 in trees; // returns true
			3 in trees; // returns true
			6 in trees; // returns false
			"bay" in trees; // returns false (you must specify the index number, not the value at that index)
			"length" in trees; // returns true (length is an Array property)
			Symbol.iterator in trees; // returns true
			
			// Predefined objects
			"PI" in Math; // returns true
			
			// Custom objects
			const mycar = { make: "Honda", model: "Accord", year: 1998 };
			"make" in mycar; // returns true
			"model" in mycar; // returns true

			const color1 = new String("green");
			"length" in color1; // returns true
			
			const color2 = "coral";			// generates an error (color2 is not a String object)
			"length" in color2;

		* Using the in operator with deleted or undefined properties -
			const mycar = { make: "Honda", model: "Accord", year: 1998 };
			delete mycar.make;
			"make" in mycar; // returns false
			
			const trees = ["redwood", "bay", "cedar", "oak", "maple"];
			delete trees[3];
			3 in trees; // returns false
		  If you set a property to undefined but do not delete it, the in operator returns true for that property.

		* need to look at more example




	33) Increment (++) -
		* The increment (++) operator increments (adds one to) its operand and returns the value before or after the increment, depending on where the operator is placed.
		* ex.
			let x = 3;
			const y = x++;
			console.log(`x:${x}, y:${y}`);	// Expected output: "x:4, y:3"
			let a = 3;
			const b = ++a;
			console.log(`a:${a}, b:${b}`);	// Expected output: "a:4, b:4"



	34) Inequality (!=) -
		* The inequality (!=) operator checks whether its two operands are not equal, returning a Boolean result. Unlike the strict inequality operator, it attempts to convert and compare operands that are of different types.
		* 	console.log(1 != 1);			// Expected output: false
			console.log('hello' != 'hello');	// Expected output: false
			console.log('1' != 1);			// Expected output: false
			console.log(0 != false);		// Expected output: false

		* Comparison with type conversion
			"1" != 1; // false
			1 != "1"; // false
			0 != false; // false
			0 != null; // true
			0 != undefined; // true
			0 != !!null; // false, look at Logical NOT operator
			0 != !!undefined; // false, look at Logical NOT operator
			null != undefined; // false
			
			const number1 = new Number(3);
			const number2 = new Number(3);
			number1 != 3; // false
			number1 != number2; // true

		* Comparison of objects
			const object1 = {
			  key: "value",
			};
			
			const object2 = {
			  key: "value",
			};
			
			console.log(object1 != object2); // true
			console.log(object1 != object1); // false

		
	35) instanceof -
		* The instanceof operator tests to see if the prototype property of a constructor appears anywhere in the prototype chain of an object. The return value is a boolean value. Its behavior can be customized with Symbol.hasInstance.
		* ex.
			function Car(make, model, year) {
			  this.make = make;
			  this.model = model;
			  this.year = year;
			}
			const auto = new Car('Honda', 'Accord', 1998);
			
			console.log(auto instanceof Car);
			// Expected output: true
			
			console.log(auto instanceof Object);
			// Expected output: true

		* ex. 	// defining constructors
			function C() {}
			function D() {}
			
			const o = new C();
			
			// true, because: Object.getPrototypeOf(o) === C.prototype
			o instanceof C;
			
			// false, because D.prototype is nowhere in o's prototype chain
			o instanceof D;
			
			o instanceof Object; // true, because:
			C.prototype instanceof Object; // true
			
			// Re-assign `constructor.prototype`: you should
			// rarely do this in practice.
			C.prototype = {};
			const o2 = new C();
			
			o2 instanceof C; // true
			
			// false, because C.prototype is nowhere in
			// o's prototype chain anymore
			o instanceof C;
			
			D.prototype = new C(); // add C to [[Prototype]] linkage of D
			const o3 = new D();
			o3 instanceof D; // true
			o3 instanceof C; // true since C.prototype is now in o3's prototype chain

		* Note that the value of an instanceof test can change if constructor.prototype is re-assigned after creating the object (which is usually discouraged). It can also be changed by changing object's prototype using Object.setPrototypeOf.


	36) Left shift (<<) -
		* The left shift (<<) operator returns a number or BigInt whose binary representation is the first operand shifted by the specified number of bits to the left. Excess bits shifted off to the left are discarded, and zero bits are shifted in from the right.
		* will see later


	37) Left shift assignment (<<=)
		* The left shift assignment (<<=) operator performs left shift on the two operands and assigns the result to the left operand.
		* let a = 5; 		// 00000000000000000000000000000101
		a <<= 2; // 20		// 00000000000000000000000000010100
		
		let b = 5n;
		b <<= 2n; // 20n


	38) Less than (<) - 
		* The less than (<) operator returns true if the left operand is less than the right operand, and false otherwise.
		* ex. 	
			console.log(5 < 3); 			// Expected output: false
			console.log(3 < 3);			// Expected output: false
			
			// Compare bigint to number
			console.log(3n < 5);			// Expected output: true
			console.log('aa' < 'ab');		// Expected output: true
		*  need to understand in depth


	39) Less than or equal (<=) -
		* The less than or equal (<=) operator returns true if the left operand is less than or equal to the right operand, and false otherwise.
		* ex.
			console.log(5 <= 3);			// Expected output: false
			console.log(3 <= 3);			// Expected output: true
			
			// Compare bigint to number
			console.log(3n <= 5);			// Expected output: true
			console.log('aa' <= 'ab');		// Expected output: true
		*  need to understand in depth


	40) Logical AND (&&) -
		* The logical AND (&&) (logical conjunction) operator for a set of boolean operands will be true if and only if all the operands are true. Otherwise it will be false.
		* ex. 
			const a = 3;
			const b = -2;
			
			console.log(a > 0 && b > 0);		// Expected output: false

		*  need to understand in depth

	41) Logical AND assignment (&&=)
	42) Logical NOT (!)
	43) Logical OR (||)
	44) Logical OR assignment (||=)
	45) Multiplication (*)
	46) Multiplication assignment (*=)
	47) new	-
		* The new operator lets developers create an instance of a user-defined object type or of one of the built-in object types that has a constructor function.
		* function Car(make, model, year) {
			  this.make = make;
			  this.model = model;
			  this.year = year;
		   }
		   const car1 = new Car('Eagle', 'Talon TSi', 1993);			
		   console.log(car1.make);	// Expected output: "Eagle"


	48) new.target
	49) null
	50) Nullish coalescing assignment (??=)
	51) Nullish coalescing operator (??)
	52) Object initializer
	53) Operator precedence
	54) Optional chaining (?.)
	55) Property accessors
	56) Remainder (%)
	57) Remainder assignment (%=)
	58) Right shift (>>)
	59) Right shift assignment (>>=)
	60) Spread syntax (...)
	61) Strict equality (===)
	62) Strict inequality (!==)
	63) Subtraction (-)
	64) Subtraction assignment (-=)
	65) super
	66) this
	67) typeof
	68) Unary negation (-)
	69) Unary plus (+)
	70) Unsigned right shift (>>>)
	71) Unsigned right shift assignment (>>>=)
	72) void operator
	73) yield
	74) yield*

C) Statements & declarations
	1) async function - 
		* The async function declaration creates a binding of a new async function to a given name.
		* The await keyword is permitted within the function body, enabling asynchronous, promise-based behaviour to be written in a cleaner style and avoiding the need to configure promise chains explicitly.
		* You can also define async functions using the async function expression.
		* eg.
			function waitForData () {
			    return new Promise((res, rej) => {
			        setTimeout(() => {
			            res(10)
			        }, 3000)
			    })
			}
			console.log("before call");
			async function testAsyncFun(){
			    try {
			        console.log("line1");
			        const data = await waitForData();
			        console.log("line2", data);
			    } catch(e){
			        console.log("error", e)
			    }
			}
			testAsyncFun()
			console.log("outside line call");
		* In the above example, output like below -
			before call
			line1
			outside line call
			line2 10
		* Here, await help to stop execution till "waitForData" returns something and starts working on other code synchronously. once done with synchronous code, then moves to the "waitForData" function which is in microtask queues. 
		* An async function declaration creates an AsyncFunction object. Each time when an async function is called, it returns a new Promise which will be resolved with the value returned by the async function, or rejected with an exception uncaught within the async function.
		* Async functions can contain zero or more await expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of async and await enables the use of ordinary try / catch blocks around asynchronous code.
		* Note: The await keyword is only valid inside async functions within regular JavaScript code. If you use it outside of an async function's body, you will get a SyntaxError.
		* Note: The purpose of async/await is to simplify the syntax necessary to consume promise-based APIs. The behavior of async/await is similar to combining generators and promises.

		* Async functions always return a promise. If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise.
		* An async function will return a different reference, whereas Promise.resolve returns the same reference if the given value is a promise.
		  ex.
			const p = new Promise((res, rej) => {
			  res(1);
			});
			
			async function asyncReturn() {
			  return p;
			}
			
			function basicReturn() {
			  return Promise.resolve(p);
			}
			
			console.log(p === basicReturn()); // true
			console.log(p === asyncReturn()); // false

		* Async functions and execution order - check in mdn
		* await and concurrency - check in mdn
		* Rewriting a Promise chain with an async function - check in mdn

		* In situations like following - promise.all or promise.allSettled, don't use async await. 



	2) async function* -
		* The async function* declaration creates a binding of a new async generator function to a given name.
		* check "async function" in mdn

	3) block -
		* A block statement is used to group zero or more statements. The block is delimited by a pair of braces ("curly braces") and contains a list of zero or more statements and declarations.
		* {
			StatementList
		  }
		* The block statement is often called the compound statement in other languages.
		* It allows you to use multiple statements where JavaScript expects only one statement. Combining statements into blocks is a common practice in JavaScript, especially when used in association with control flow statements like if...else and for. The opposite behavior is possible using an empty statement, where you provide no statement, although one is required.
		* In addition, combined with block-scoped declarations like let, const, and class, blocks can prevent temporary variables from polluting the global namespace, just like IIFEs do.
		
		* Block scoping rules with var or function declaration in non-strict mode -
			var x = 1;
			{
			  var x = 2;
			}
			console.log(x); // 2	- bcz of variable enviornment 
			* In non-strict code, function declarations inside blocks behave strangely. Do not use them.

		* Block scoping rules with let, const, class, or function declaration in strict mode -
			let x = 1;
			{
			  let x = 2;
			}
			console.log(x); // 1	- bcz of lexical enviornment
			const c = 1;
			{
			  const c = 2;
			}
			console.log(c); // 1; does not throw SyntaxError

		* Using a block statement as the body of a for loop



	3) break -
		* The break statement terminates the current loop or switch statement and transfers program control to the statement following the terminated statement. It can also be used to jump past a labeled statement when used within that labeled statement
		* When break; is encountered, the program breaks out of the innermost switch or looping statement and continues executing the next statement after that.
		* break in while loop -
		* break in switch statements -
		* break in labeled blocks -
			* The following code uses break statements with labeled blocks. By using break outerBlock, control is transferred to the end of the block statement marked as outerBlock.

			outerBlock: {
			  innerBlock: {
			    console.log("1");
			    break outerBlock; // breaks out of both innerBlock and outerBlock
			    console.log(":-("); // skipped
			  }
			  console.log("2"); // skipped
			}
		* Unsyntactic break statements - check in mdn



	4) class -
		* class have more resembalnce with let.
		* The class declaration creates a binding of a new class to a given name.
		* You can also define classes using the class expression.
		* ex.
			class Polygon {
			  constructor(height, width) {
			    this.area = height * width;
			  }
			}
			console.log(new Polygon(4, 3).area);			// Expected output: 12

		* The class body of a class declaration is executed in strict mode. The class declaration is very similar to let:
			* class declarations are scoped to blocks as well as functions.
			* class declarations can only be accessed after the place of declaration is reached (see temporal dead zone). For this reason, class declarations are commonly regarded as non-hoisted (unlike function declarations).
			* class declarations do not create properties on globalThis when declared at the top level of a script (unlike function declarations).
			* class declarations cannot be redeclared by any other declaration in the same scope.
		* Outside the class body, class declarations can be re-assigned like let, but you should avoid doing so. Within the class body, the binding is constant like const.
			class Foo {
			  static {
			    Foo = 1; // TypeError: Assignment to constant variable.
			  }
			}
			
			class Foo2 {
			  bar = (Foo2 = 1); // TypeError: Assignment to constant variable.
			}
			
			class Foo3 {}
			Foo3 = 1;
			console.log(Foo3); // 1
		
		* A simple class declaration -
			* In the following example, we first define a class named Rectangle, then extend it to create a class named FilledRectangle.
			* Note that super(), used in the constructor, can only be used in constructors, and must be called before the this keyword can be used.
			* ex.
				class Rectangle {
				  constructor(height, width) {
				    this.name = "Rectangle";
				    this.height = height;
				    this.width = width;
				  }
				}
				
				class FilledRectangle extends Rectangle {
				  constructor(height, width, color) {
				    super(height, width);
				    this.name = "Filled rectangle";
				    this.color = color;
				  }
				}
	

	5) const -
		* The const declaration declares block-scoped local variables. The value of a constant can't be changed through reassignment using the assignment operator, but if a constant is an object, its properties can be added, updated, or removed.
		* ex.
				const number = 42;
				try {
				  number = 99;
				} catch (err) {
				  console.log(err);	  // Expected output: TypeError: invalid assignment to const 'number'	// (Note: the exact output may be browser-dependent)
				}
				
				console.log(number);				// Expected output: 42
		* syntax - 
			const name1 = value1;
			const name1 = value1, name2 = value2;
			const name1 = value1, name2 = value2, /* …, */ nameN = valueN;
		* The const declaration is very similar to let:
			* const declarations are scoped to blocks as well as functions.
			* const declarations can only be accessed after the place of declaration is reached (see temporal dead zone). For this reason, const declarations are commonly regarded as non-hoisted.
			* const declarations do not create properties on globalThis when declared at the top level of a script.
			* const declarations cannot be redeclared by any other declaration in the same scope.
			* const begins declarations, not statements. That means you cannot use a lone const declaration as the body of a block (which makes sense, since there's no way to access the variable).
		* The const declaration creates an immutable reference ( binding ) to a value. It does not mean the value it holds is immutable — just that the variable identifier cannot be reassigned.
		* Many style guides (including MDN's) recommend using const over let whenever a variable is not reassigned in its scope. This makes the intent clear that a variable's type (or value, in the case of a primitive) can never change. Others may prefer let for non-primitives that are mutated.
		* Basic const usage - common convention is to use all-uppercase letters, especially for primitives because they are truly immutable.
			const MY_FAV = 7;	console.log("my favorite number is: " + MY_FAV);	//7
		* Block scoping -
		* const in objects and arrays - 
			* Attempting to overwrite the object throws an error "Assignment to constant variable".
			* You would need to use Object.freeze() to make an object immutable.
		* Declaration with destructuring -



	6) continue -
		* The continue statement terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.
		* ex.
			let text = '';
			for (let i = 0; i < 10; i++) {
			  if (i === 3) {
			    continue;
			  }
			  text = text + i;
			}
			console.log(text);			// Expected output: "012456789"

		* In contrast to the break statement, continue does not terminate the execution of the loop entirely, but instead:
			* In a while or do...while loop, it jumps back to the condition.
			* In a for loop, it jumps to the update expression.
			* In a for...in, for...of, or for await...of loop, it jumps to the next iteration.
		* The continue statement can include an optional label that allows the program to jump to the next iteration of a labeled loop statement instead of the innermost loop. In this case, the continue statement needs to be nested within this labeled statement.
		* Using continue with while -
		* Using continue with a label - check in mdn
		* Unsyntactic continue statements - check in mdn



	7) debugger -
		* The debugger statement invokes any available debugging functionality, such as setting a breakpoint. If no debugging functionality is available, this statement has no effect.
		debugger;


	8) do...while -
		* The do...while statement creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.
		* ex.	
			let i = 0
			do {
				console.log("ii", ++i);
			} while( i < 5)
			console.log(i);
		* Like other looping statements, you can use control flow statements inside statement:
			* break stops statement execution and goes to the first statement after the loop.
			* continue stops statement execution and re-evaluates condition.
		* The do...while statement syntax requires a semicolon at the end, but the automatic semicolon insertion process may insert one for you if the lack of a semicolon results in invalid syntax.
		* Using do...while
		* Using false as do...while condition - check in mdn
		* Using an assignment as a condition - check in mdn

	9) empty -
		* An empty statement is used to provide no statement, although the JavaScript syntax would expect one.
		* ex.
			const array1 = [1, 2, 3];
			// Assign all array values to 0
			for (let i = 0; i < array1.length; array1[i++] = 0) /* empty statement */ ;
			console.log(array1);		// Expected output: Array [0, 0, 0]
		* The empty statement is a semicolon (;) indicating that no statement will be executed, even if JavaScript syntax requires one.
		* The opposite behavior, where you want multiple statements, but JavaScript only allows a single one, is possible using a block statement, which combines several statements into a single one.
		* Empty loop body -
			const arr = [1, 2, 3];
			for (let i = 0; i < arr.length; arr[i++] = 0) /* empty statement */ ;		// Assign all array values to 0			
			console.log(arr);			// [0, 0, 0]

		* Unintentional usage - check in mdn



	
	10) Export
		* The export declaration is used to export values from a JavaScript module. Exported values can then be imported into other programs with the import declaration or dynamic import. The value of an imported binding is subject to change in the module that exports it — when a module updates the value of a binding that it exports, the update will be visible in its imported value.
		* In order to use the export declaration in a source file, the file must be interpreted by the runtime as a module. In HTML, this is done by adding type="module" to the <script> tag, or by being imported by another module. Modules are automatically interpreted in strict mode.
		* two types of exports: 
			Named Exports (Zero or more exports per module),
			Default Exports (One per module)
		* Syntax -
			// Exporting declarations
			export let name1, name2/*, … */; // also var
			export const name1 = 1, name2 = 2/*, … */; // also var, let
			export function functionName() { /* … */ }
			export class ClassName { /* … */ }
			export function* generatorFunctionName() { /* … */ }
			export const { name1, name2: bar } = o;
			export const [ name1, name2 ] = array;
			
			// Export list
			export { name1, /* …, */ nameN };
			export { variable1 as name1, variable2 as name2, /* …, */ nameN };
			export { variable1 as "string name" };
			export { name1 as default /*, … */ };
			
			// Default exports
			export default expression;
			export default function functionName() { /* … */ }
			export default class ClassName { /* … */ }
			export default function* generatorFunctionName() { /* … */ }
			export default function () { /* … */ }
			export default class { /* … */ }
			export default function* () { /* … */ }
			
			// Aggregating modules
			export * from "module-name";
			export * as name1 from "module-name";
			export { name1, /* …, */ nameN } from "module-name";
			export { import1 as name1, import2 as name2, /* …, */ nameN } from "module-name";
			export { default, /* …, */ } from "module-name";
			export { default as name1 } from "module-name";
	
		* Every module can have two different types of export, named export and default export. You can have multiple named exports per module but only one default export. Each type corresponds to one of the above syntax.
		* Export declarations are not subject to temporal dead zone rules. You can declare that the module exports X before the name X itself is declared.
		* default export can be imported with any name. eg. import m from './test';
		* rename named exports to avoid naming conflicts. eg. export { myFunction as function1, myVariable as variable };
		* one can create a single module concentrating various exports from various modules.
			export { default as function1, function2 } from 'bar.js';
		* Re-exporting / Aggregating - 
			* A module can also "relay" values exported from other modules without the hassle of writing two separate import/export statements. This is often useful when creating a single module concentrating various exports from various modules (usually called a "barrel module").
			export { default as function1, function2 } from "bar.js";
		* Using named exports -
		* Using the default export -
		* Using export from


	11) Expression Statement -
		* An expression statement is an expression used in a place where a statement is expected. The expression is evaluated and its result is discarded — therefore, it makes sense only for expressions that have side effects, such as executing a function or updating a variable.
		* check in MDN

	11) for -
		* The for statement creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement (usually a block statement) to be executed in the loop.
		* ex. let str = '';
		for (let i = 0; i < 9; i++) {
		  str = str + i;
		}
		console.log(str);	// Expected output: "012345678"
		* Like other looping statements, you can use control flow statements inside statement:
			* break stops statement execution and goes to the first statement after the loop.
			* continue stops statement execution and re-evaluates afterthought then condition.
		* Using for -
		* Initialization block syntax -
		* Optional for expressions - All three expressions in the head of the for loop are optional
		* Lexical declarations in the initialization block - check in MDN
		* Using for without a body - check in MDN
		* Using for with two iterating variables -

	12) for await...of -
		* first need to learn about iterator, generator, then will come here

	13) for...in -
		* The for...in statement iterates over all enumerable string properties of an object (ignoring properties keyed by symbols), including inherited enumerable properties.
		* ex.
			const object = { a: 1, b: 2, c: 3 };
			for (const property in object) {
			  console.log(`${property}: ${object[property]}`);
			}
			// Expected output:
			// "a: 1"
			// "b: 2"
			// "c: 3"
		* The loop will iterate over all enumerable properties of the object itself and those the object inherits from its prototype chain (properties of nearer prototypes take precedence over those of prototypes further away from the object in its prototype chain).
		* Like other looping statements, you can use control flow statements inside statement:
			* break stops statement execution and goes to the first statement after the loop.
			* continue stops statement execution and goes to the next iteration of the loop.
		* A legacy syntax allows var declarations of the loop variable to have an initializer. This throws a syntax error in strict mode and is ignored in non–strict mode.
		* Deleted, added, or modified properties -
			* for...in visits property keys in the following fashion:
				* It first gets all own string keys of the current object, in a fashion very similar to Object.getOwnPropertyNames().
				* For each key, if no string with the same value has ever been visited, the property descriptor is retrieved and the property is only visited if it is enumerable. However, this property string will be marked as visited even if it's not enumerable.
				* Then, the current object is replaced with its prototype, and the process is repeated.

				This means:
				* Any property added to the currently visited object during iteration will not be visited, because all own properties of the current object have already been saved beforehand.
				* If multiple objects in the prototype chain have a property with the same name, only the first one will be considered, and it is only visited if it's enumerable. If it is non-enumerable, no other properties with the same name further up the prototype chain will be visited, even if they are enumerable.

			* In general, it is best not to add, modify, or remove properties from the object during iteration, other than the property currently being visited. The spec explicitly allows the implementation to not follow the algorithm above in one of the following cases:				
				* The object's prototype chain is modified during iteration.
				* A property is deleted from the object or its prototype chain during iteration.
				* A property is added to the object's prototype chain during iteration.
				* A property's enumerability is changed during iteration.

		* Array iteration and for...in - check in mdn
			* It is better to use a for loop with a numeric index, Array.prototype.forEach(), or the for...of loop, because they will return the index as a number instead of a string, and also avoid non-index properties.

		* Iterating over own properties only - 
			* If you only want to consider properties attached to the object itself, and not its prototypes, you can use one of the following techniques:	Object.keys(), Object.getOwnPropertyNames()
			* Object.keys will return a list of enumerable own string properties, while Object.getOwnPropertyNames will also contain non-enumerable ones.
		* Using for...in
		* Iterating own properties - use of Object.hasOwn(): the inherited properties are not displayed.
		* Concurrent modification - not much imp ( check in mdn )

	14) for...of -
		* The for...of statement executes a loop that operates on a sequence of values sourced from an iterable object. Iterable objects include instances of built-ins such as Array, String, TypedArray, Map, Set, NodeList (and other DOM collections), as well as the arguments object, generators produced by generator functions, and user-defined iterables.
		* ex.
			const array1 = ['a', 'b', 'c'];
			for (const element of array1) {
			  console.log(element);
			}
			// Expected output: "a"
			// Expected output: "b"
			// Expected output: "c"
		* A for...of loop operates on the values sourced from an iterable one by one in sequential order. Each operation of the loop on a value is called an iteration, and the loop is said to iterate over the iterable. Each iteration executes statements that may refer to the current sequence value.
		* When a for...of loop iterates over an iterable, it first calls the iterable's [@@iterator]() method, which returns an iterator, and then repeatedly calls the resulting iterator's next() method to produce the sequence of values to be assigned to variable.
		* A for...of loop exits when the iterator has completed (the next() result is an object with done: true). Like other looping statements, you can use control flow statements inside statement:
			break stops statement execution and goes to the first statement after the loop.
			continue stops statement execution and goes to the next iteration of the loop.
		* If the for...of loop exited early (e.g. a break statement is encountered or an error is thrown), the return() method of the iterator is called to perform any cleanup.
		* The variable part of for...of accepts anything that can come before the = operator. You can use const to declare the variable as long as it's not reassigned within the loop body (it can change between iterations, because those are two separate variables). Otherwise, you can use let.
		* Iterating over an Array
		* Iterating over a string 
		* Iterating over a TypedArray
		* Iterating over a Map
		* Iterating over a Set
		* Iterating over the arguments object
		* Iterating over a NodeList
		* Iterating over a user-defined iterable
		* Iterating over a generator
		* Early exiting
		* Difference between for...of and for...in - check in mdn
			* The for...in statement iterates over the enumerable string properties ( keys )  of an object, while the for...of statement iterates over values that the iterable object defines to be iterated over.


		


	14) function -
		* The function declaration creates a binding of a new function to a given name.
		* You can also define functions using the function expression.
		* ex. 
			function calcRectArea(width, height) {
			  return width * height;
			}
			console.log(calcRectArea(5, 6));			// Expected output: 30
		* A function declaration creates a Function object. Each time when a function is called, it returns the value specified by the last executed return statement, or undefined if the end of the function body is reached.
		* function declarations behave like a mix of var and let:
			* Like let, in strict mode, function declarations are scoped to the most closely containing block.
			* Like let, function declarations at the top level of a module or within blocks in strict mode cannot be redeclared by any other declaration.
			* Like var, function declarations at the top level of a script (strict or non-strict) become properties on globalThis. Function declarations at the top level of a script or function body (strict or non-strict) can be redeclared by another function or var.
			* Like both, function declarations can be re-assigned, but you should avoid doing so.
			* Unlike either, function declarations are hoisted together with its value and can be called anywhere in its scope.

		* Block-level function declaration - check in mdn
		* Hoisting - Function declarations in JavaScript are hoisted to the top of the enclosing function or global scope.
		* Redeclarations - 
			* Whether function declarations can be redeclared in the same scope depends on what scope it's contained in.
			* At the top level of a script, function declarations behave like var and can be redeclared by another function or var but not by let, const, or class.
			* When function declarations are redeclared by var, the var declaration's initializer always overrides the function's value, regardless of their relative position. This is because function declarations are hoisted before any initializer gets evaluated, so the initializer comes later and overrides the value.
			* At the top level of a module or a block in strict mode, function declarations behave like let and cannot be redeclared by any other declaration.
		* Using function -



	15) function*
	16) function declaration
	17) if...else -
		* The if...else statement executes a statement if a specified condition is truthy. If the condition is falsy, another statement in the optional else clause will be executed.
		* ex. 
			function testNum(a) {
			  let result;
			  if (a > 0) {
			    result = 'positive';
			  } else {
			    result = 'NOT positive';
			  }
			  return result;
			}
			
			console.log(testNum(-5));			// Expected output: "NOT positive"
		* Using if...else
		* Using else if
		* Using an assignment as a condition
		* 

	18) import.meta -
	19) import -
		* check in mdn
		* The static import declaration is used to import read-only live bindings which are exported by another module. The imported bindings are called live bindings because they are updated by the module that exported the binding, but cannot be re-assigned by the importing module.
		* In order to use the import declaration in a source file, the file must be interpreted by the runtime as a module. In HTML, this is done by adding type="module" to the <script> tag. Modules are automatically interpreted in strict mode.
		* There is also a function-like dynamic import(), which does not require scripts of type="module".
		* ex.
			import defaultExport from "module-name";
			import * as name from "module-name";
			import { export1 } from "module-name";
			import { export1 as alias1 } from "module-name";
			import { default as alias } from "module-name";
			import { export1, export2 } from "module-name";
			import { export1, export2 as alias2, /* … */ } from "module-name";
			import { "string name" as alias } from "module-name";
			import defaultExport, { export1, /* … */ } from "module-name";
			import defaultExport, * as name from "module-name";
			import "module-name";
		* import declarations can only be present in modules, and only at the top-level (i.e. not inside blocks, functions, etc.). If an import declaration is encountered in non-module contexts (for example, <script> tags without type="module", eval, new Function, which all have "script" or "function body" as parsing goals), a SyntaxError is thrown. To load modules in non-module contexts, use the dynamic import syntax instead.
		* All imported bindings cannot be in the same scope as any other declaration, including let, const, class, function, var, and import declaration.
		* import declarations are designed to be syntactically rigid (for example, only string literal specifiers, only permitted at the top-level, all bindings must be identifiers), which allows modules to be statically analyzed and linked before getting evaluated. This is the key to making modules asynchronous by nature, powering features like top-level await.
		* Forms of import declarations
			There are four forms of import declarations:
			
			Named import: import { export1, export2 } from "module-name";
			Default import: import defaultExport from "module-name";
			Namespace import: import * as name from "module-name";
			Side effect import: import "module-name";
		* Named import -
		* Default import -





	20) labeled statement -
		* A labeled statement is any statement that is prefixed with an identifier. You can jump to this label using a break or continue statement nested within the labeled statement.
		* ex.	
			let str = '';
			loop1: for (let i = 0; i < 5; i++) {
			  if (i === 1) {
			    continue loop1;
			  }
			  str = str + i;
			}
			console.log(str);			// Expected output: "0234"
		* You can use a label to identify a statement, and later refer to it using a break or continue statement. Note that JavaScript has no goto statement; you can only use labels with break or continue.
		* Any break or continue that references label must be contained within the statement that's labeled by label. Think about label as a variable that's only available in the scope of statement.
		* If a break label; statement is encountered when executing statement, execution of statement terminates, and execution continues at the statement immediately following the labeled statement.
		* continue label; can only be used if statement is one of the looping statements. If a continue label; statement is encountered when executing statement, execution of statement continues at the next iteration of the loop. continue; without a label can only continue the innermost loop, while continue label; allows continuing any given loop even when the statement is nested within other loops.
		* A statement can have multiple labels. In this case, the labels are all functionally equivalent.
		* Using a labeled continue with for loops -
			// The first for statement is labeled "loop1"
			loop1: for (let i = 0; i < 3; i++) {
			  // The second for statement is labeled "loop2"
			  loop2: for (let j = 0; j < 3; j++) {
			    if (i === 1 && j === 1) {
			      continue loop1;
			    }
			    console.log(`i = ${i}, j = ${j}`);
			  }
			}
			
			// Logs:
			// i = 0, j = 0
			// i = 0, j = 1
			// i = 0, j = 2
			// i = 1, j = 0
			// i = 2, j = 0
			// i = 2, j = 1
			// i = 2, j = 2
		* Notice how it skips both "i = 1, j = 1" and "i = 1, j = 2".

		* Using a labeled break with for loops -
			let i, j;
			
			// The first for statement is labeled "loop1"
			loop1: for (i = 0; i < 3; i++) {
			  // The second for statement is labeled "loop2"
			  loop2: for (j = 0; j < 3; j++) {
			    if (i === 1 && j === 1) {
			      break loop1;
			    }
			    console.log(`i = ${i}, j = ${j}`);
			  }
			}
			
			// Logs:
			// i = 0, j = 0
			// i = 0, j = 1
			// i = 0, j = 2
			// i = 1, j = 0
		* Using a labeled continue statement - 
			* check in mdn
			* Given an array of items and an array of tests, this example counts the number of items that pass all the tests.
		* Using a labeled break statement -
		* Using a labeled block with break -


	21) let - 
		* The let declaration declares re-assignable, block-scoped local variables, optionally initializing each to a value.
		* ex.
			let x = 1;
			if (x === 1) {
			  let x = 2;
			  console.log(x);		  // Expected output: 2
			}
			console.log(x);			// Expected output: 1
		* The scope of a variable declared with let is one of the following curly-brace-enclosed syntaxes that most closely contains the let declaration:
			Block statement
			switch statement
			try...catch statement
			Body of one of the for statements, if the let is in the header of the statement
			Function body
			Static initialization block
		* Or if none of the above applies:	
			The current module, for code running in module mode
			The global scope, for code running in script mode.

		* Compared with var, let declarations have the following differences:
			let declarations are scoped to blocks as well as functions.
			let declarations can only be accessed after the place of declaration is reached (see temporal dead zone). For this reason, let declarations are commonly regarded as non-hoisted.
			let declarations do not create properties on globalThis when declared at the top level of a script.
			let declarations cannot be redeclared by any other declaration in the same scope.
			let begins declarations, not statements. That means you cannot use a lone let declaration as the body of a block (which makes sense, since there's no way to access the variable).
		* Note that let is allowed as an identifier name when declared with var or function in non-strict mode, but you should avoid using let as an identifier name to prevent unexpected syntax ambiguities.
		* The list that follows the let keyword is called a binding list and is separated by commas, where the commas are not comma operators and the = signs are not assignment operators. Initializers of later variables can refer to earlier variables in the list.
		* Temporal dead zone (TDZ) - 
			* A variable declared with let, const, or class is said to be in a "temporal dead zone" (TDZ) from the start of the block until code execution reaches the place where the variable is declared and initialized.
			* While inside the TDZ, the variable has not been initialized with a value, and any attempt to access it will result in a ReferenceError. The variable is initialized with a value when execution reaches the place in the code where it was declared. If no initial value was specified with the variable declaration, it will be initialized with a value of undefined.
			* Using the typeof operator for a let variable in its TDZ will throw a ReferenceError.

		* Redeclarations - 
			* let declarations cannot be in the same scope as any other declaration, including let, const, class, function, var, and import declaration.
			{
			  let foo;
			  let foo; // SyntaxError: Identifier 'foo' has already been declared
			}
			
			* A let declaration within a function's body cannot have the same name as a parameter. A let declaration within a catch block cannot have the same name as the catch-bound identifier.
			function foo(a) {
			  let a = 1; // SyntaxError: Identifier 'a' has already been declared
			}
			try {
			} catch (e) {
			  let e; // SyntaxError: Identifier 'e' has already been declared
			}

			* To avoid the error, wrap each case in a new block statement.
				let x = 1;
				switch (x) {
				  case 0: {
				    let foo;
				    break;
				  }
				  case 1: {
				    let foo;
				    break;
				  }
				}

			* Scoping rules - Variables declared by let have their scope in the block for which they are declared, as well as in any contained sub-blocks. In this way, let works very much like var. The main difference is that the scope of a var variable is the entire enclosing function.
			* TDZ combined with lexical scoping -
				The following code results in a ReferenceError at the line shown:
				function test() {
				  var foo = 33;
				  if (foo) {
				    let foo = foo + 55; // ReferenceError
				  }
				}
				test();
	
				* The if block is evaluated because the outer var foo has a value. However due to lexical scoping this value is not available inside the block: the identifier foo inside the if block is the let foo. The expression foo + 55 throws a ReferenceError because initialization of let foo has not completed — it is still in the temporal dead zone.

			* Other situations
			* Declaration with destructuring


	22) return -
		* The return statement ends function execution and specifies a value to be returned to the function caller.
		* ex.
			function getRectArea(width, height) {
			  if (width > 0 && height > 0) {
			    return width * height;
			  }
			  return 0;
			}
			
			console.log(getRectArea(3, 4));
			// Expected output: 12
			
			console.log(getRectArea(-3, 4));
			// Expected output: 0
		* The return statement can only be used within function bodies. When a return statement is used in a function body, the execution of the function is stopped. The return statement has different effects when placed in different functions:
			In a plain function, the call to that function evaluates to the return value.
			In an async function, the produced promise is resolved with the returned value.
			In a generator function, the produced generator object's next() method returns { done: true, value: returnedValue }.
			In an async generator function, the produced async generator object's next() method returns a promise fulfilled with { done: true, value: returnedValue }.
		* If a return statement is executed within a try block, its finally block, if present, is first executed, before the value is actually returned.
		* Automatic semicolon insertion - 
			* The syntax forbids line terminators between the return keyword and the expression to be returned.
			* This makes the function return undefined and the a + b expression is never evaluated. This may generate a warning in the console.

		* Interrupt a function -
		* Returning a function -



	23) switch -
		* The switch statement evaluates an expression, matching the expression's value against a series of case clauses, and executes statements after the first case clause with a matching value, until a break statement is encountered. The default clause of a switch statement will be jumped to if no case matches the expression's value.
		* ex.
			const expr = 'Papayas';
			switch (expr) {
			  case 'Oranges':
			    console.log('Oranges are $0.59 a pound.');
			    break;
			  case 'Mangoes':
			  case 'Papayas':
			    console.log('Mangoes and papayas are $2.79 a pound.');
			    // Expected output: "Mangoes and papayas are $2.79 a pound."
			    break;
			  default:
			    console.log(`Sorry, we are out of ${expr}.`);
			}
		* A switch statement first evaluates its expression. It then looks for the first case clause whose expression evaluates to the same value as the result of the input expression (using the strict equality comparison) and transfers control to that clause, executing all statements following that clause.
		* The clause expressions are only evaluated when necessary — if a match is already found, subsequent case clause expressions will not be evaluated, even when they will be visited by fall-through.
		* If no matching case clause is found, the program looks for the optional default clause, and if found, transfers control to that clause, executing statements following that clause. If no default clause is found, the program continues execution at the statement following the end of switch. By convention, the default clause is the last clause, but it does not need to be so. A switch statement may only have one default clause; multiple default clauses will result in a SyntaxError.

		* Breaking and fall-through -
			* You can use the break statement within a switch statement's body to break out early, often when all statements between two case clauses have been executed. Execution will continue at the first statement following switch.
			* If break is omitted, execution will proceed to the next case clause, even to the default clause, regardless of whether the value of that clause's expression matches. This behavior is called "fall-through".
		* Lexical scoping - 
			* The case and default clauses are like labels: they indicate possible places that control flow may jump to. However, they don't create lexical scopes themselves (neither do they automatically break out — as demonstrated above). For example:
			* ex. 
				const action = "say_hello";
				switch (action) {
				  case "say_hello":
				    const message = "hello";
				    console.log(message);
				    break;
				  case "say_hi":
				    const message = "hi";
				    console.log(message);
				    break;
				  default:
				    console.log("Empty action received.");
				}
			* This example will output the error "Uncaught SyntaxError: Identifier 'message' has already been declared", because the first const message = 'hello'; conflicts with the second const message = 'hi'; declaration, even when they're within their own separate case clauses. Ultimately, this is due to both const declarations being within the same block scope created by the switch body.
			* To fix this, whenever you need to use let or const declarations in a case clause, wrap it in a block.

		* Using switch
		* Putting the default clause between two case clauses
			* If no match is found, execution will start from the default clause, and execute all statements after that.
			* It also works when you put default before all other case clauses.

		* Taking advantage of fall-through - check in mdn
		* An alternative to if...else chains - 
	

	24) throw -
		* The throw statement throws a user-defined exception. Execution of the current function will stop (the statements after throw won't be executed), and control will be passed to the first catch block in the call stack. If no catch block exists among caller functions, the program will terminate.
		* ex.
			function getRectArea(width, height) {
			  if (isNaN(width) || isNaN(height)) {
			    throw new Error('Parameter is not a number!');
			  }
			}
			
			try {
			  getRectArea(3, 'A');
			} catch (e) {
			  console.error(e);
			  // Expected output: Error: Parameter is not a number!
			}
		* The throw statement is valid in all contexts where statements can be used. Its execution generates an exception that penetrates through the call stack. For more information on error bubbling and handling, see Control flow and error handling.
		* The throw keyword can be followed by any kind of expression, for example:
			throw error; // Throws a previously defined value (e.g. within a catch block)
			throw new Error("Required"); // Throws a new Error object
		* Automatic semicolon insertion -
		* Throwing a user-defined error
		* Throwing an existing object


	25) try...catch -
		* The try...catch statement is comprised of a try block and either a catch block, a finally block, or both. The code in the try block is executed first, and if it throws an exception, the code in the catch block will be executed. The code in the finally block will always be executed before control flow exits the entire construct.
		* ex.
			try {
			  nonExistentFunction();
			} catch (error) {
			  console.error(error);
			  // Expected output: ReferenceError: nonExistentFunction is not defined
			  // (Note: the exact output may be browser-dependent)
			}
		* The try statement always starts with a try block. Then, a catch block or a finally block must be present. It's also possible to have both catch and finally blocks. This gives us three forms for the try statement:
			try...catch
			try...finally
			try...catch...finally

		* Unlike other constructs such as if or for, the try, catch, and finally blocks must be blocks, instead of single statements.
		* A catch block contains statements that specify what to do if an exception is thrown in the try block. If any statement within the try block (or in a function called from within the try block) throws an exception, control is immediately shifted to the catch block. If no exception is thrown in the try block, the catch block is skipped.
		* The finally block will always execute before control flow exits the try...catch...finally construct. It always executes, regardless of whether an exception was thrown or caught.
		* You can nest one or more try statements. If an inner try statement does not have a catch block, the enclosing try statement's catch block is used instead.

		* Catch binding -
		* The finally block -
			* The finally block contains statements to execute after the try block and catch block(s) execute, but before the statements following the try...catch...finally block. Control flow will always enter the finally block, which can proceed in one of the following ways:
				Immediately after the try block finishes execution normally (and no exceptions were thrown);
				Immediately after the catch block finishes execution normally;
				Immediately before a control-flow statement (return, throw, break, continue) is executed in the try block or catch block.

		* Unconditional catch block
		* Conditional catch blocks -
		* Nested try blocks
		* Returning from a finally block -
			If the finally block returns a value, this value becomes the return value of the entire try-catch-finally statement, regardless of any return statements in the try and catch blocks. This includes exceptions thrown inside of the catch block.








	26) var -
		* The var statement declares function-scoped or globally-scoped variables, optionally initializing each to a value.
		* The scope of a variable declared with var is one of the following curly-brace-enclosed syntaxes that most closely contains the var statement:
			Function body
			Static initialization block

			Or if none of the above applies:
			
			The current module, for code running in module mode
			The global scope, for code running in script mode.
		* Importantly, other block constructs, including block statements, try...catch, switch, headers of one of the for statements, do not create scopes for var, and variables declared with var inside such a block can continue to be referenced outside the block.
		* Hoisting -
		* Redeclarations -
			Duplicate variable declarations using var will not trigger an error, even in strict mode, and the variable will not lose its value, unless the declaration has an initializer.

	27) while -
		* The while statement creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.
		* ex.
			let n = 0;
			while (n < 3) {
			  n++;
			}
			
			console.log(n);			// Expected output: 3
		* Like other looping statements, you can use control flow statements inside statement:
			break stops statement execution and goes to the first statement after the loop.
			continue stops statement execution and re-evaluates condition.


	28) with

D) Functions -

1) Overview -
	* a function is a "subprogram" that can be called by code external (or internal, in the case of recursion) to the function.
	* a function is composed of a sequence of statements called the function body.
	* Values can be passed to a function as parameters, and the function will return a value.
	* functions are first-class objects, because they can be passed to other functions, returned from functions, and assigned to variables and properties.
	* They can also have properties and methods just like any other object.

	* Description -
		* Function values are typically instances of Function
	* Return value - By default, if a function's execution doesn't end at a return statement, or if the return keyword doesn't have an expression after it, then the return value is undefined.
	* Passing arguments -
		function formatNumber(num) {		// num - parameter
		  return num.toFixed(2);
		}
		
		formatNumber(2);	// 2- arguments
		
		* Arguments are always passed by value and never passed by reference. This means that if a function reassigns a parameter, the value won't change outside the function. More precisely, object arguments are passed by sharing, which means if the object's properties are mutated, the change will impact the outside of the function. For example:

	* Defining functions -
		* Broadly speaking, JavaScript has four kinds of functions:
			Regular function: can return anything; always runs to completion after invocation
			Generator function: returns a Generator object; can be paused and resumed with the yield operator
			Async function: returns a Promise; can be paused and resumed with the await operator
			Async generator function: returns an AsyncGenerator object; both the await and yield operators can be used
		* For every kind of function, there are three ways to define it:
			Declaration	-	function, function*, async function, async function*
			Expression	-	function, function*, async function, async function*
			Constructor	-	Function(), GeneratorFunction(), AsyncFunction(), AsyncGeneratorFunction()
		* In addition, there are special syntaxes for defining arrow functions and methods, which provide more precise semantics for their usage

		* ex.
			// Constructor
			const multiply = new Function("x", "y", "return x * y");
			
			// Declaration
			function multiply(x, y) {
			  return x * y;
			} // No need for semicolon here
			
			// Expression; the function is anonymous but assigned to a variable
			const multiply = function (x, y) {
			  return x * y;
			};
			// Expression; the function has its own name
			const multiply = function funcName(x, y) {
			  return x * y;
			};
			
			// Arrow function
			const multiply = (x, y) => x * y;
			
			// Method
			const obj = {
			  multiply(x, y) {
			    return x * y;
			  },
			};

			* The Function() constructor, function expression, and function declaration syntaxes create full-fledged function objects, which can be constructed with new. However, arrow functions and methods cannot be constructed. Async functions, generator functions, and async generator functions are not constructible regardless of syntax.
	The function declaration creates functions that are hoisted. Other syntaxes do not hoist the function and the function value is only visible after the definition.
	The arrow function and Function() constructor always create anonymous functions, which means they can't easily call themselves recursively. One way to call an arrow function recursively is by assigning it to a variable.
			* The arrow function syntax does not have access to arguments or this.
			* The Function() constructor cannot access any local variables — it only has access to the global scope.
			* The Function() constructor causes runtime compilation and is often slower than other syntaxes.

		* For function expressions, there is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be different from the variable the function is assigned to — they have no relation to each other. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or gets another value, if the same name is declared elsewhere).
		* A function declaration also creates a variable with the same name as the function name. Thus, unlike those defined by function expressions, functions defined by function declarations can be accessed by their name in the scope they were defined in, as well as in their own body.
		* A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a Function constructor does not inherit any scope other than the global scope (which all functions inherit).
		* Function parameters -
			* There are three special parameter syntaxes:
				Default parameters allow formal parameters to be initialized with default values if no value or undefined is passed.
				The rest parameter allows representing an indefinite number of arguments as an array.
				Destructuring allows unpacking elements from arrays, or properties from objects, into distinct variables.

		* The arguments object -
			* You can refer to a function's arguments within the function by using the arguments object.
		* Getter and setter functions -
			* You can define accessor properties on any standard built-in object or user-defined object that supports the addition of new properties. Within object literals and classes, you can use special syntaxes to define the getter and setter of an accessor property.
			* get - Binds an object property to a function that will be called when that property is looked up.
			* set - Binds an object property to a function to be called when there is an attempt to set that property.

		* Block-level functions -
			* In strict mode, functions inside blocks are scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.
			* ex.
				"use strict";
				
				function f() {
				  return 1;
				}
				
				{
				  function f() {
				    return 2;
				  }
				}
				
				f() === 1; // true
				// f() === 2 in non-strict mode

		* Block-level functions in non-strict code - check in mdn

2) Arrow function expressions -
	* An arrow function expression is a compact alternative to a traditional function expression, with some semantic differences and deliberate limitations in usage:
		* Arrow functions don't have their own bindings to this, arguments, or super, and should not be used as methods.
		* Arrow functions cannot be used as constructors. Calling them with new throws a TypeError. They also don't have access to the new.target keyword.
		* Arrow functions cannot use yield within their body and cannot be created as generator functions.
	* Rest parameters, default parameters, and destructuring within params are supported, and always require parentheses.
	* Arrow functions can be async by prefixing the expression with the async keyword.
	* Function body -
	* Cannot be used as methods - 
		* check in mdn
		* Arrow function expressions should only be used for non-method functions because they do not have their own this.
	* No binding of arguments - 
	* Cannot be used as constructors
		Arrow functions cannot be used as constructors and will throw an error when called with new. They also do not have a prototype property.
	* Cannot be used as generators
	* Line break before arrow
	* Precedence of arrow


3) Default parameters -
	* Default function parameters allow named parameters to be initialized with default values if no value or undefined is passed.
	* In JavaScript, function parameters default to undefined. However, it's often useful to set a different default value. This is where default parameters can help.
	* Passing undefined vs. other falsy values
	* Evaluated at call time - check in mdn
	* Earlier parameters are available to later default parameters
	* Destructured parameter with default value assignment
	

4) get -
	* The get syntax binds an object property to a function that will be called when that property is looked up. It can also be used in classes.
	* ex.
		const obj = {
		  log: ['a', 'b', 'c'],
		  get latest() {
		    return this.log[this.log.length - 1];
		  },
		};
		
		console.log(obj.latest);		// Expected output: "c"
	* Sometimes it is desirable to allow access to a property that returns a dynamically computed value, or you may want to reflect the status of an internal variable without requiring the use of explicit method calls. In JavaScript, this can be accomplished with the use of a getter.
	* An object property is either a data property or an accessor property, but it cannot simultaneously be both. Read Object.defineProperty() for more information. The getter syntax allows you to specify the getter function in an object initializer.

	* Defining a getter on new objects in object initializers
	* Using getters in classes -
		* You can use the exact same syntax to define public instance getters that are available on class instances. In classes, you don't need the comma separator between methods.
		* ex.
			class ClassWithGetSet {
			  #msg = "hello world";
			  get msg() {
			    return this.#msg;
			  }
			  set msg(x) {
			    this.#msg = `hello ${x}`;
			  }
			}
			
			const instance = new ClassWithGetSet();
			console.log(instance.msg); // "hello world"
			
			instance.msg = "cake";
			console.log(instance.msg); // "hello cake"
		* Getter properties are defined on the prototype property of the class and are thus shared by all instances of the class. Unlike getter properties in object literals, getter properties in classes are not enumerable.

	* Deleting a getter using the delete operator - 
		If you want to remove the getter, you can just delete it: delete obj.latest;
	* Defining a getter on existing objects using defineProperty -
		To append a getter to an existing object later at any time, use Object.defineProperty().
		ex.
			const o = { a: 0 };
			Object.defineProperty(o, "b", {
			  get() {
			    return this.a + 1;
			  },
			});
			
			console.log(o.b); // Runs the getter, which yields a + 1 (which is 1)

	* Using a computed property name -
	* Defining static getters -
	* Smart / self-overwriting / lazy getters -
		* Getters give you a way to define a property of an object, but they do not calculate the property's value until it is accessed. A getter defers the cost of calculating the value until the value is needed. If it is never needed, you never pay the cost.
		* An additional optimization technique to lazify or delay the calculation of a property value and cache it for later access are smart (or memoized) getters. The value is calculated the first time the getter is called, and is then cached so subsequent accesses return the cached value without recalculating it. This is useful in the following situations:
			If the calculation of a property value is expensive (takes much RAM or CPU time, spawns worker threads, retrieves remote file, etc.).
			If the value isn't needed just now. It will be used later, or in some case it's not used at all.
			If it's used, it will be accessed several times, and there is no need to re-calculate that value will never be changed or shouldn't be re-calculated.


	* get vs. defineProperty -
		* When using get the property will be defined on the instance's prototype, while using Object.defineProperty() the property will be defined on the instance it is applied to.


5) Method definitions -
	* Method definition is a shorter syntax for defining a function property in an object initializer. It can also be used in classes.
	* Properties defined using this syntax are own properties of the created object, and they are configurable, enumerable, and writable, just like normal properties.
	* Method definitions are not constructable -
		Methods cannot be constructors! They will throw a TypeError if you try to instantiate them. On the other hand, a property created as a function can be used as a constructor.
	* Using super in method definitions -
		Only functions defined as methods have access to the super keyword. super.prop looks up the property on the prototype of the object that the method was initialized on.
		ex.
			const obj = {
			  __proto__: {
			    prop: "foo",
			  },
			  notAMethod() {
			    console.log(super.prop); // foo
			  },
			};
	* Using method definitions -
	* Method definitions in classes -
		* You can use the exact same syntax to define public instance methods that are available on class instances. In classes, you don't need the comma separator between methods.
		* ex.	class ClassWithPublicInstanceMethod {
			  publicMethod() {
			    return "hello world";
			  }
			  secondPublicMethod() {
			    return "goodbye world";
			  }
			}
			
			const instance = new ClassWithPublicInstanceMethod();
			console.log(instance.publicMethod()); // "hello world"

		* Public instance methods are defined on the prototype property of the class and are thus shared by all instances of the class. They are writable, non-enumerable, and configurable.

		* Inside instance methods, this and super work like in normal methods. Usually, this refers to the instance itself. In subclasses, super lets you access the prototype of the object that the method is attached to, allowing you to call methods from the superclass.
		* ex. 	class BaseClass {
			  msg = "hello world";
			  basePublicMethod() {
			    return this.msg;
			  }
			}
			
			class SubClass extends BaseClass {
			  subPublicMethod() {
			    return super.basePublicMethod();
			  }
			}
			
			const instance = new SubClass();
			console.log(instance.subPublicMethod()); // "hello world"

	* Computed property names
	* Generator methods
	* Async methods -
		// Using a named property
		const obj = {
		  f: async function () {
		    await somePromise;
		  },
		};
		
		// The same object using shorthand syntax
		const obj2 = {
		  async f() {
		    await somePromise;
		  },
		};
	* Async generator methods



6) Rest parameters -
	* The rest parameter syntax allows a function to accept an indefinite number of arguments as an array, providing a way to represent variadic functions in JavaScript.
	* A function definition's last parameter can be prefixed with ... (three U+002E FULL STOP characters), which will cause all remaining (user supplied) parameters to be placed within an Array object.
	* syntax- 	function f(a, b, ...theArgs) {
			  // …
			}
	* ex.
		function myFun(a, b, ...manyMoreArgs) {
		  console.log("a", a);
		  console.log("b", b);
		  console.log("manyMoreArgs", manyMoreArgs);
		}
		
		myFun("one", "two", "three", "four", "five", "six");
		
		// Console Output:
		// a, one
		// b, two
		// manyMoreArgs, ["three", "four", "five", "six"]

	* The difference between rest parameters and the arguments object -
		* There are three main differences between rest parameters and the arguments object:
			* The arguments object is not a real array, while rest parameters are Array instances, meaning methods like sort(), map(), forEach() or pop() can be applied on it directly.
			* The arguments object has the additional (deprecated) callee property.
			* In a non-strict function with simple parameters, the arguments object syncs its indices with the values of parameters. The rest parameter array never updates its value when the named parameters are re-assigned.
			* The rest parameter bundles all the extra parameters into a single array, but does not contain any named argument defined before the ...restParam. The arguments object contains all of the parameters — including the parameters in the ...restParam array — bundled into one array-like object.

	* Using rest parameters -
	* Argument length
	* Using rest parameters in combination with ordinary parameters - check in mdn
	* From arguments to an array -
	

7) set -
	* The set syntax binds an object property to a function to be called when there is an attempt to set that property. It can also be used in classes.
	* A setter must have exactly one parameter.
	* In JavaScript, a setter can be used to execute a function whenever an attempt is made to change a property's value. Setters are most often used in conjunction with getters.
	* An object property is either a data property or an accessor property, but it cannot simultaneously be both. Read Object.defineProperty() for more information. The setter syntax allows you to specify the setter function in an object initializer.
		const obj = {
		  set prop() {
		    // setter, the code executed when setting obj.prop
		  },
		}
	* Defining a setter on new objects in object initializers
	* Using setters in classes
	* Removing a setter with the delete operator
	* Defining a setter on existing objects using defineProperty
	* Using a computed property name
	

8) The arguments object -
	* arguments is an array-like object accessible inside functions that contains the values of the arguments passed to that function.
	* The arguments object is a local variable available within all non-arrow functions. You can refer to a function's arguments inside that function by using its arguments object. It has entries for each argument the function was called with, with the first entry's index at 0.
	* You can use arguments.length to count how many arguments the function was called with.
	*  If you instead want to count how many parameters a function is declared to accept, inspect that function's length property.

	* Assigning to indices	- check in mdn
		* Each argument index can also be set or reassigned.	arguments[1] = "new value";
		* Non-strict functions that only have simple parameters (that is, no rest, default, or destructured parameters) will sync the new value of parameters with the arguments object, and vice versa:

	* arguments is an array-like object - check in mdn
	* Defining a function that concatenates several strings
	* Defining a function that creates HTML lists
	* Using typeof with arguments - The typeof operator returns 'object' when used with arguments


E) Classes

1) Overview - 
	* Classes are a template for creating objects. They encapsulate data with code to work on that data. Classes in JS are built on prototypes but also have some syntax and semantics that are unique to classes.
	* Defining classes -
		* Classes are in fact "special functions", and just as you can define function expressions and function declarations, a class can be defined in two ways: a class expression or a class declaration.
		* ex. // Declaration
			class Rectangle {
			  constructor(height, width) {
			    this.height = height;
			    this.width = width;
			  }
			}
			
			// Expression; the class is anonymous but assigned to a variable
			const Rectangle = class {
			  constructor(height, width) {
			    this.height = height;
			    this.width = width;
			  }
			};
			
			// Expression; the class has its own name
			const Rectangle = class Rectangle2 {
			  constructor(height, width) {
			    this.height = height;
			    this.width = width;
			  }
			};
		* Like function expressions, class expressions may be anonymous, or have a name that's different from the variable that it's assigned to. However, unlike function declarations, class declarations have the same temporal dead zone restrictions as let or const and behave as if they are not hoisted.

	* Class body -
		* The body of a class is the part that is in curly braces {}. This is where you define class members, such as methods or constructor.
		* The body of a class is executed in strict mode even without the "use strict" directive.
		* A class element can be characterized by three aspects:
			Kind: Getter, setter, method, or field
			Location: Static or instance
			Visibility: Public or private
		* Together, they add up to 16 possible combinations. To divide the reference more logically and avoid overlapping content, the different elements are introduced in detail in different pages:
			Method definitions - Public instance method
			getter	-	Public instance getter
			setter -	Public instance setter
			Public class fields - Public instance field
			static	-	Public static method, getter, setter, and field			
			Private properties -	Everything that's private
		* In addition, there are two special class element syntaxes: constructor and static initialization blocks, with their own references.


	* Constructor -
		* The constructor method is a special method for creating and initializing an object created with a class. There can only be one special method with the name "constructor" in a class — a SyntaxError is thrown if the class contains more than one occurrence of a constructor method.
		* A constructor can use the super keyword to call the constructor of the super class.
		You can create instance properties inside the constructor:
			class Rectangle {
			  constructor(height, width) {
			    this.height = height;
			    this.width = width;
			  }
			}
		* Alternatively, if your instance properties' values do not depend on the constructor's arguments, you can define them as class fields.

	* Static initialization blocks -
		* Static initialization blocks allow flexible initialization of static properties, including the evaluation of statements during initialization, while granting access to the private scope.
		* Multiple static blocks can be declared, and these can be interleaved with the declaration of static fields and methods (all static items are evaluated in declaration order).

	* Methods -
		* Methods are defined on the prototype of each class instance and are shared by all instances. Methods can be plain functions, async functions, generator functions, or async generator functions. For more information, see method definitions.

	* Static methods and fields -
		* The static keyword defines a static method or field for a class. Static properties (fields and methods) are defined on the class itself instead of each instance. Static methods are often used to create utility functions for an application, whereas static fields are useful for caches, fixed-configuration, or any other data that doesn't need to be replicated across instances.

	* Field declarations - 
		* With the class field declaration syntax, the constructor example can be written as:
			class Rectangle {
			  height = 0;
			  width;
			  constructor(height, width) {
			    this.height = height;
			    this.width = width;
			  }
			}
		* Class fields are similar to object properties, not variables, so we don't use keywords such as const to declare them. In JavaScript, private properties use a special identifier syntax, so modifier keywords like public and private should not be used either.
		* As seen above, the fields can be declared with or without a default value. Fields without default values default to undefined. By declaring fields up-front, class definitions become more self-documenting, and the fields are always present, which help with optimizations.

	* Private properties -
		* Using private fields, the definition can be refined as below.
			class Rectangle {
			  #height = 0;
			  #width;
			  constructor(height, width) {
			    this.#height = height;
			    this.#width = width;
			  }
			}

	* Inheritance - The extends keyword is used in class declarations or class expressions to create a class as a child of another constructor (either a class or a function).

	* Evaluation order -
		* When a class declaration or class expression is evaluated, its various components are evaluated in the following order:
			1) The extends clause, if present, is first evaluated. It must evaluate to a valid constructor function or null, or a TypeError is thrown.
			2) The constructor method is extracted, substituted with a default implementation if constructor is not present. However, because the constructor definition is only a method definition, this step is not observable.
			3) The class elements' property keys are evaluated in the order of declaration. If the property key is computed, the computed expression is evaluated, with the this value set to the this value surrounding the class (not the class itself). None of the property values are evaluated yet.
			4) Methods and accessors are installed in the order of declaration. Instance methods and accessors are installed on the prototype property of the current class, and static methods and accessors are installed on the class itself. Private instance methods and accessors are saved to be installed on the instance directly later. This step is not observable.
			5) The class is now initialized with the prototype specified by extends and implementation specified by constructor. For all steps above, if an evaluated expression tries to access the name of the class, a ReferenceError is thrown because the class is not initialized yet.
			6) The class elements' values are evaluated in the order of declaration:
				* For each instance field (public or private), its initializer expression is saved. The initializer is evaluated during instance creation, at the start of the constructor (for base classes) or immediately before the super() call returns (for derived classes).
				* For each static field (public or private), its initializer is evaluated with this set to the class itself, and the property is created on the class.
				* Static initialization blocks are evaluated with this set to the class itself.
			The class is now fully initialized and can be used as a constructor function.

	* Binding this with instance and static methods -
		* When a static or instance method is called without a value for this, such as by assigning the method to a variable and then calling it, the this value will be undefined inside the method. This behavior is the same even if the "use strict" directive isn't present, because code within the class body is always executed in strict mode.
		* ex.
			class Animal {
			  speak() {
			    return this;
			  }
			  static eat() {
			    return this;
			  }
			}
			
			const obj = new Animal();
			obj.speak(); // the Animal object
			const speak = obj.speak;
			speak(); // undefined
			
			Animal.eat(); // class Animal
			const eat = Animal.eat;
			eat(); // undefined
		* If we rewrite the above using traditional function-based syntax in non–strict mode, then this method calls are automatically bound to globalThis. In strict mode, the value of this remains as undefined.
		* ex.
			function Animal() {}
			
			Animal.prototype.speak = function () {
			  return this;
			};
			
			Animal.eat = function () {
			  return this;
			};
			
			const obj = new Animal();
			const speak = obj.speak;
			speak(); // global object (in non–strict mode)
			
			const eat = Animal.eat;
			eat(); // global object (in non-strict mode)


2) Constructor -
	* The constructor method is a special method of a class for creating and initializing an object instance of that class.
	* ex.		class Polygon {
			  constructor() {
			    this.name = 'Polygon';
			  }
			}
			
			const poly1 = new Polygon();
			
			console.log(poly1.name);
			// Expected output: "Polygon"

	* There are some additional syntax restrictions:
		A class method called constructor cannot be a getter, setter, async, or generator.
		A class cannot have more than one constructor method.
	* A constructor enables you to provide any custom initialization that must be done before any other methods can be called on an instantiated object.
		class Person {
		  constructor(name) {
		    this.name = name;
		  }
		
		  introduce() {
		    console.log(`Hello, my name is ${this.name}`);
		  }
		}
		
		const otto = new Person("Otto");
		
		otto.introduce(); // Hello, my name is Otto
	* If you don't provide your own constructor, then a default constructor will be supplied for you. If your class is a base class, the default constructor is empty:
		constructor() {}
	* If your class is a derived class, the default constructor calls the parent constructor, passing along any arguments that were provided:
		constructor(...args) {
		  super(...args);
		}
	* Using new on a class goes through the following steps:
		(If it's a derived class) The constructor body before the super() call is evaluated. This part should not access this because it's not yet initialized.
		(If it's a derived class) The super() call is evaluated, which initializes the parent class through the same process.
		The current class's fields are initialized.
		The constructor body after the super() call (or the entire body, if it's a base class) is evaluated.


















D) Regular Expressions 
	1) Backreference: \1, \2
	2) Capturing group: (...)
	3) Character class escape: \d, \D, \w, \W, \s, \S
	4) Character class: [...], [^...]
	5) Character escape: \n, \u{...}
	6) Disjunction: |
	7) Input boundary assertion: ^, $
	8) Literal character: a, b
	9) Lookahead assertion: (?=...), (?!...)
	10) Lookbehind assertion: (?<=...), (?<!...)
	11) Named backreference: \k<name>
	12) Named capturing group: (?<name>...)
	13) Non-capturing group: (?:...)
	14) Quantifier: *, +, ?, {n}, {n,}, {n,m}
	15) Unicode character class escape: \p{...}, \P{...}
	16) Wildcard: .
	17) Word boundary assertion: \b, \B


Reference Links -
* https://codedamn.com/news/programming/comprehensive-guide-javascript-event-loop ( Event Queue / Loop, microtask, async await)  


Points need to be done to improve interview -
async await
promise
prototype and its chain
class
call, apply, bind
object.create and object.assign
methods of array, object, string, number
date
event propagation
recursion
symbol
Iterators and generators
Map, set, 




