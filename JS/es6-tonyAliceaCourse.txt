
4) Block Scoping: why?
* Block Scoping: Variable scope is defined lexically by a block. In Js, curly braces.
* Block scoping added to es6, to reduce bugs

5) Block statements and Lexical Enviornments -
* In creation of execution context, we will get following - "window, this, reference to outer variable enviornment, variable enviornment, lexical enviornment and code".
* In code, if there's block using curl braces, it will create separate lexical environments in execution contexts.
* If we declare variable in that block using var keyword, then it will store it in variable enviorment

6) let -
* ex. let myVar = 1;
      if(true) {
        console.log(myVar);  //will print 1.
        if(true){
        }
      }
* In above example, it will create 3 lexical enviornments, one above another. Our console statement is in  2nd lexical enviorment. when it won't be able to find variable in that lexical enviornment, it moves to outer lexical enviornment to look for myVar. Hence, we were able to print 1. Here, we also have reference to outer lexical enviorment for each lexical enviorment.
* if(true) {
        console.log(myVar);  // give error.
        if(true){
        let myVar = 1;        
        }
      }
* In above example, engine won't be able to find in same lexical enviorment and above one too. hence it gives error.
* If we declare variable with let, we won't be able to log using "window.myVar". 
      let myVar = true
      console.log(myVar);      //true
      console.log(windw.myVar)      // undefined
      Bcz "myVar" is store it in lexical enviornment not in variable enviorment.
* redeclaring variable using var keyword is allow in JS, but not with let.
* {} will declare block scope
* ex. let myVar = 1;
      {
            console.log(myVar);           // 1. bcz of reference of outer lexical enviornment
      }
* ex. let myVar = 1;
      {
            let myVar = 2;
            console.log(myVar);      // 2. in same scope, myVar declared with 2
      }
* ex. let myVar = 1;
      {
            let myVar = 2;
            console.log(myVar);      //2
      }
      console.log(myVar);            //1
* ex. let myVar = 1;
      {
            console.log(myVar);      // give error.  initialization required with or without value before using let variable
            let myVar = 2;
      }
      console.log(myVar);            //1
* curly braces with code is required for block scope. In switch statement and object literal method, it won't create extra lexical enviornment.
* double declaration of let variable in switch statement create error. If we add block within case, it will create another lexical enviornment.
* ex. let person = {
      firstName: ["s", "s2"]
}
for(let person of person.firstName){
      console.log(person);      //error. bcz person actually pointing to same variable which we declare in for loop, not the one which we declare with let before
}
* let person of person.firstName - is actually within block, not outside
*  ex. let person = {
            firstName: ["s", "s2"]
      }
      let person2 = person;
      for(let person of person2.firstName){
            console.log(person);      // s, s2
      }
* ex. let person = {
            firstName: ["s", "s2"]
      }
      for(person of person.firstName){
            console.log(person);      // s, s2
      }
      console.log(person);      //s2. eventually we update person object


7) Conceptual Aside: Bindings -
* Binding - connection (pointer) between a variable name and a specific location in computer's memory that holds the value.

8) Const -
* When variable is declare with const, binding is immutable.
* ex. const myVar = 1;
      {
            const myVar = 2;
            console.log(myVar);      //2
      }
      console.log(myVar);            //1
works same like let.
* ex. const myVar = 1;
      myVar = 2;                 // error
      console.log(myVar);
* In above example, assignment operator is trying connection between existing name and new memory location and const won't allow this.
* ex. 
      let me = {
            fname: "s", lname: "s2"
      }
      me.fname = "sss"
      console.log(me.fname);      //sss
Here, we are looking for memory location of fname. for that, it will check for object memory location using binding and from there it will find memory location of fname. once we got location, we can update the values of fname.
* but if we try to update the value of actual object, it will give error. Bcz we try to change binding and binding is immutable for const.


9) Templates: Why -
* It is cumbersome to write with old-fashioned methods.

10) Conceptual Aside: Whitespace Characters -
* 

11) Multi-line Strings -
* It's pretty easy to write multiline strings in template literal.
* let a = `sumeet
shedge`
* whitespaces are actually invisible characters, just remember it.


12) Interpolation -
* Interpolation - Replacing portions of strings with other strings. You "insert" or "inject" strings into another string.
* Tagged Template Literals -  
function greet(strings, firstName, lastName){
      console.log(strings);  //array ["Hello, ", " ", ""]
      console.log(firstName);  //"Tony"
      console.log(lastName);  //"Alicea"
}
const firstName = "Tony"
const lastName = "Alicea"
const greeting = greet`Hello, ${firstName} ${lastName}`


13) Classes -
* classes are another way to create objects in JS
* JS have prototyped based languages, hence class in JS works differently as compared to other language classes.

14) Conceptual Aside: Classes -
* A structure in a programming language that provides a way to create objects 
* In other languages, classes are able to create new types and objects too. In Js, only create objects and prototype chain.
* Syntactic sugar - A different way of accomplish something in a programming language, that doesn't actually introduce anything new under-the-hood.

15) Declarations and Expressions -
* classes in JS are actually just functions.
* ex. 
class Person {}      // this is declaration much like function declaration
* ex.
let p = class {}      //anonymous class assigned to variable "p"
typeof(p);      //function
* when you create a class, you're creating a function object.
* Parser add a special value to the function object ( isClassConstructor = true ). It will mark the function object as a class constructor. this property is hidden under the hood.

* ex. 
function logClass(c){
      console.log(c);
}
logClass(p);
logClass(class {

})
* even we observe call, apply, bind in class.
let p = class {}
p.bind      // available
* so it's clear that creating class is really just creating functions


16) Conceptual Aside: Instances -
* Instances - the actual object created from an object creation feature (like a class)
* we created this object using object creation feature. so its now an instance of that object creation feature. using a class or other creation method, we can create various instances, various separate objects with same structure.

17) Public Instances Fields -
* public - Directly accessible to both code written inside the object (methods) and code written outside the project.
* field - this is more generic name. A property created using the field syntax. Fields may or may not be accessible outside the object.
* for most part, field and property are almost interchangable names. Field is bit more generic and can be both public or not public
* ex. 
class Person {
      firstName = "Sumeet"
}
var me = new Person()
console.log(me);      //{ firstName: "sumeet" }
Person();      // will give error with following - class can't invoke without new keyword

* ex.
var me = new Person();
var me2 = new Person();
me2.firstName = "Anthony";
console.log(me);      // { firstName: "Tony" }
console.log(me2);      // { firstName: "Anthony"}
* above example shows, objects created using class, is completely different two objects.



18) Constructor -
* using constructor, we can create objects with given values.
* within constructor, we can set value to fields
* ex. 
class Person{
      firstName = "Tony"      // default value
      constructor(name){
            this.firstName = name
      }
}
* there is always a constructor function even if we don't create one. class without constructor will create empty object.
* prototype chain in class - It's actually same like function constructor.

ex.
class Person{
      firstName;      // default value
      constructor(name){
            this.firstName = name
      }
}
let me = new Person("Tony")
let me2 = new Person("Anthony")
console.log(me);
console.log(me2);

console.log(me.__proto__)
console.log(Person.prototype)
console.log(me.__proto__ === Person.prototype);      // true. it shows that class prototype is not prototype for class but for object which created from that class.
console.log(me2.__proto__ === Person.prototype);      // true


19) Methods -
* ex.
class Person{
      firstName;      // default value
      constructor(name){
            this.firstName = name
      }

      //greet method added within prototype
      greet(){
            return `hi ${this.firstName}`
      }
}
let me = new Person("Tony")
let me2 = new Person("Anthony")
console.log(me);
console.log(me2);
me.greet();
me2.greet();


20) extends and Prototypal inheritance -
* extends helps to implement prototypal inheritance.
* ex.
class Person{
      firstName;
      constructor(name){
            this.firstName = name
      }
      greet(){
            return `hi ${this.firstName}`
      }
}
class Tony extends Person {
      meet(){
            return `nice to meet you`
      }
}
let me = new Tony("Tony");
console.log(me.greet());      //Hi Tony
console.log(me2.meet());      //nice to meet you
console.log(me.__proto__);
console.log(me.__proto__ === Tony.prototype)
console.log(me.__proto__.__proto__)
console.log(Tony.prototype.__proto__ === Person.prototype)


* you can extends a function constructor or built in types also.
* ex.
class myNum extends Number {
      addOne(){
            return `this is addone`
      }
}
var a = new myNum(22.00222);
console.log(a.toFixed(1));
console.log(a.addOne());


21) super -
* in derived class, we must call "super" in constructor. If we don't specify constructor in it, then it will arrange by itself.
class Person{
      firstName;
      constructor(name){
            this.firstName = name
      }
      greet(){
            return `hi ${this.firstName}`
      }
}
class Tony extends Person {
      constructor(name){
            super(name)
      }
      meet(){
            return `nice to meet you`
      }
      greet(){      
            let greeting = super.greet();      // will call greet from Person class
            return "${greeting} Hi:"
      }
}
let me = new Tony("Tony");
console.log(me.greet());      //"hi Tony Hi:". will call greet from Tony class and inside method, will call Person class method


