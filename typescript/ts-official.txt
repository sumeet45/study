Typescript Official Site -

* The Basics -
  * It shows why we need to use typing with Javascript.
  * TypeScript can catch bugs when we make mistakes in our code. That’s great, but TypeScript can also prevent us from making those mistakes in the first place.
  * Need to understand...

1) Everyday Types -
      * Types can also appear in many more places than just type annotations. As we learn about the types themselves, we’ll also learn about the places where we can refer to these types to form new constructs.
    
      * The primitives: string, number, and boolean
      
      * Array - To specify the type of an array like [1, 2, 3], you can use the syntax - number[] or Array<number>
      
      * any - TypeScript also has a special type, any, that you can use whenever you don’t want a particular value to cause typechecking errors.
      
      * noImplicitAny - 
         * When you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to any.
         * You usually want to avoid this, though, because any isn’t type-checked. Use the compiler flag noImplicitAny to flag any implicit any as an error.
      
      * Type Annotations on Variables -
          let myName: string = "Alice";     // you can optionally add a type annotation to explicitly specify the type of the variable
          * TypeScript doesn’t use “types on the left”-style declarations like int x = 0; Type annotations will always go after the thing being typed.
      
      * Functions -  Functions are the primary means of passing data around in JavaScript. TypeScript allows you to specify the types of both the input and output values of functions.
    
    
      * Parameter Type Annotations - When you declare a function, you can add type annotations after each parameter to declare what types of parameters the function accepts. Parameter type annotations go after the parameter name: 
          // Parameter type annotation
          function greet(name: string) {
            console.log("Hello, " + name.toUpperCase() + "!!");
          }
    
    
      * Return Type Annotations - You can also add return type annotations. Return type annotations appear after the parameter list:
          function getFavoriteNumber(): number {
             return 26;
           }
    
    
      * Functions Which Return Promises - If you want to annotate the return type of a function which returns a promise, you should use the Promise type:
          async function getFavoriteNumber(): Promise<number> {
            return 26;
          }
    
    
      * Anonymous Functions - 
            *  Anonymous functions are a little bit different from function declarations. When a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types.
             const names = ["Alice", "Bob", "Eve"];
              
             // Contextual typing for function - parameter s inferred to have type string
             names.forEach(function (s) {
               console.log(s.toUpperCase());
             });
              
             // Contextual typing also applies to arrow functions
             names.forEach((s) => {
               console.log(s.toUpperCase());
             });
    
           * Even though the parameter s didn’t have a type annotation, TypeScript used the types of the forEach function, along with the inferred type of the array, to determine the type s will have. This process is called contextual typing because the context that the function occurred within informs what type it should have.
    
    
      * Object Types -
            // The parameter's type annotation is an object type
            function printCoord(pt: { x: number; y: number }) {          // can use , or ;
              console.log("The coordinate's x value is " + pt.x);
              console.log("The coordinate's y value is " + pt.y);
            }
            printCoord({ x: 3, y: 7 });
    
    
      * Optional Properties -
         function printName(obj: { first: string; last?: string }) {      // To do this, add a ? after the property name
            // ...
         }
         * In JavaScript, if you access a property that doesn’t exist, you’ll get the value undefined rather than a runtime error. Because of this, when you read from an optional property, you’ll have to check for undefined before using it.


     * Unions - 
         * TypeScript’s type system allows you to build new types out of existing ones using a large variety of operators. 
    
         * Defining a Union Type - The first way to combine types you might see is a union type. A union type is a type formed from two or more other types, representing values that may be any one of those types. We refer to each of these types as the union’s members.
          function printId(id: number | string) {
             console.log("Your ID is: " + id);
           }
    
         * Working with Union Types -
           * TypeScript will only allow an operation if it is valid for every member of the union. For example, if you have the union string | number, you can’t use methods that are only available on string:
           ex.    function printId(id: number | string) {
                    console.log(id.toUpperCase());          // Property 'toUpperCase' does not exist on type 'number'.
                 }
           
           ex.  solution for above code -
                 function printId(id: number | string) {
                   if (typeof id === "string") {
                     // In this branch, id is of type 'string'
                     console.log(id.toUpperCase());
                   } else {
                     // Here, id is of type 'number'
                     console.log(id);
                   }
                 }
    
          * Type Aliases -
             ex.  
                  type Point = {
                     x: number,
                     y: number
                  }
                  let b: Point = {
                    x: 2,
                    y: 5
                  }
              * You can actually use a type alias to give a name to any type at all, not just an object type. For example, a type alias can name a union type:  
                  type ID = number | string;
    
            * Interfaces 
                 * An interface declaration is another way to name an object type:
                   ex.  interface Int11 {
                          name: string;
                          age: number
                        }
                      let person: Int11 = {
                        name: "s",
                        age: 23
                      }
    
            * Differences Between Type Aliases and Interfaces -
                   * key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.
    
            * Type Assertions -
                 * Sometimes you will have information about the type of a value that TypeScript can’t know about.
                 ex.   const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;
                       const myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas");   // can write in this way also
    
            * Literal Types -
                * In addition to the general types string and number, we can refer to specific strings and numbers in type positions.
                  let x: "hello" = "hello";
    
            * Literal Inference -

        * null and undefined -
           * JavaScript has two primitive values used to signal absent or uninitialized value: null and undefined.
           
           * strictNullChecks off - With strictNullChecks off, values that might be null or undefined can still be accessed normally, and the values null and undefined can be assigned to a property of any type.
           * strictNullChecks on - With strictNullChecks on, when a value is null or undefined, you will need to test for those values before using methods or properties on that value. Just like checking for undefined before using an optional property, we can use narrowing to check for values that might be null: 
                 function doSomething(x: string | null) {
                     if (x === null) {
                       // do nothing
                     } else {
                       console.log("Hello, " + x.toUpperCase());
                     }
                   }

             * Non-null Assertion Operator (Postfix !) - TypeScript also has a special syntax for removing null and undefined from a type without doing any explicit checking. Writing ! after any expression is effectively a type assertion that the value isn’t null or undefined:
                   function liveDangerously(x?: number | null) {
                       // No error
                       console.log(x!.toFixed());
                   }


        * Enums -  Enums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants.

        * Less Common Primitives - 
                * bigint -
                        const oneHundred: bigint = BigInt(100);                        // Creating a bigint via the BigInt function
                        const anotherHundred: bigint = 100n;                        // Creating a BigInt via the literal syntax
                * symbol -
                        There is a primitive in JavaScript used to create a globally unique reference via the function Symbol():
                        const firstName = Symbol("name");
                        const secondName = Symbol("name");
                         
                        if (firstName === secondName) {
                              // This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap.
                              // Can't ever happen
                        }


2) Narrowing -
         ex    function padLeft(padding: number | string, input: string): string {
                      if (typeof padding === "number") {
                        return " ".repeat(padding) + input;
                      }
                      return padding + input;
                    }
        * Within our if check, TypeScript sees typeof padding === "number" and understands that as a special form of code called a type guard
        * look at these special checks (called type guards) and assignments, and the process of refining types to more specific types than declared is called narrowing.

        * typeof type guards - TypeScript expects this to return a certain set of strings while narrowing.
                "string", "number", "bigint", "boolean", "symbol", "undefined", "object" ,"function"
        * In TypeScript, checking against the value returned by typeof is a type guard.
        * in TS, typeof null is actually "object"!


        * Truthiness narrowing - 
                * Values like 0, NaN, "" (the empty string), 0n (the bigint version of zero), null, undefined coerce to false

                    function printAll(strs: string | string[] | null) {
                          if (strs && typeof strs === "object") {        // eliminate strs error of null possibility
                            for (const s of strs) {
                              console.log(s);
                            }
                          } else if (typeof strs === "string") {
                            console.log(strs);
                          }
                        }
                * narrowing by truthiness is that Boolean negations with ! filter out from negated branches

        * Equality narrowing -
                * TypeScript also uses switch statements and equality checks like ===, !==, ==, and != to narrow types.
                * JavaScript’s looser equality checks with == and != also get narrowed correctly. If you’re unfamiliar, checking whether something == null actually not only checks whether it is specifically the value null - it also checks whether it’s potentially undefined. The same applies to == undefined: it checks whether a value is either null or undefined.
                ex        interface Container {
                              value: number | null | undefined;
                            }
                         
                        function multiplyValue(container: Container, factor: number) {
                          // Remove both 'null' and 'undefined' from the type.
                          if (container.value != null) {
                              console.log(container.value);
                              container.value *= factor;// Now we can safely multiply 'container.value'.
                          }
                        }


        * The in operator narrowing - 
                * JavaScript has an operator for determining if an object or its prototype chain has a property with a name: the in operator. TypeScript takes this into account as a way to narrow down potential types.
                    function move(animal: Fish | Bird) {
                      if ("swim" in animal) {
                        return animal.swim();
                      }
                      return animal.fly();
                    }


        * instanceof narrowing - 
            * JavaScript has an operator for checking whether or not a value is an “instance” of another value
            * As you might have guessed, instanceof is also a type guard, and TypeScript narrows in branches guarded by instanceofs.

        * Assignments -
            * As we mentioned earlier, when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately.
            * ex.
                    let x = Math.random() < 0.5 ? 10 : "hello world!";        //let x: string | number
                       
                    x = 1;
                    console.log(x);            //  let x: number
                               
                    x = "goodbye!";
                    console.log(x);            //let x: string

                    x = true;
                    console.log(x);                //Type 'boolean' is not assignable to type 'string | number'.

        * Control flow analysis -
            * 


        * Using type predicates - We’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code.
                 function isFish(pet: Fish | Bird): pet is Fish {
                  return (pet as Fish).swim !== undefined;
                }

                 // Both calls to 'swim' and 'fly' are now okay.
                 let pet = getSmallPet();
                  
                 if (isFish(pet)) {
                   pet.swim();
                 } else {
                   pet.fly();
                 }

        * Assertion functions - Types can also be narrowed using Assertion functions.

        * Discriminated unions - 
            * Here, It shows way to using union in type, we can manage narrowing.
            * we can apply narrowing in switch also

        * The never type -
            * When narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, TypeScript will use a never type to represent a state which shouldn’t exist.

        * Exhaustiveness checking -
            * The never type is assignable to every type; however, no type is assignable to never (except never itself). This means you can use narrowing and rely on never turning up to do exhaustive checking in a switch statement.
            * For example, adding a default to our getArea function which tries to assign the shape to never will not raise an error when every possible case has been handled.
                type Shape = Circle | Square;
                 
                function getArea(shape: Shape) {
                  switch (shape.kind) {
                    case "circle":
                      return Math.PI * shape.radius ** 2;
                    case "square":
                      return shape.sideLength ** 2;
                    default:
                      const _exhaustiveCheck: never = shape;
                      return _exhaustiveCheck;
                  }
                }

        * Adding a new member to the Shape union, will cause a TypeScript error.





3) More on Functions -
        * Function Type Expressions -
            * The simplest way to describe a function is with a function type expression.
            * The syntax (a: string) => void means “a function with one parameter, named a, of type string, that doesn’t have a return value”. Just like with function declarations, if a parameter type isn’t specified, it’s implicitly any.
                
                 type GreetFunction = (a: string) => void;
                function greeter(fn: GreetFunction) {}

        * Call Signatures -
            * In JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesn’t allow for declaring properties. If we want to describe something callable with properties, we can write a call signature in an object type.
                    type DescribableFunction = {
                      description: string;
                      (someArg: number): boolean;
                    };
                    function doSomething(fn: DescribableFunction) {
                      console.log(fn.description + " returned " + fn(6));
                    }
                     
                    function myFunc(someArg: number) {
                      return someArg > 3;
                    }
                    myFunc.description = "default description";
                    doSomething(myFunc);

        * Construct Signatures -
            * JavaScript functions can also be invoked with the new operator. TypeScript refers to these as constructors because they usually create a new object. You can write a construct signature by adding the new keyword in front of a call signature:
            * ex.        type SomeConstructor = {
                            new (s: string): SomeObject;
                          };
                          function fn(ctor: SomeConstructor) {
                              return new ctor("hello");
                          }
            * Some objects, like JavaScript’s Date object, can be called with or without new. You can combine call and construct signatures in the same type arbitrarily:
            * ex.
                    interface CallOrConstruct {
                      (n?: number): string;
                       new (s: string ): Date;
                    }

       * Generic Functions -
             * generics are used when we want to describe a correspondence between two values. We do this by declaring a type parameter in the function signature
             * ex.
                    function firstElement<Type>(arr: Type[]): Type | undefined {
                       return arr[0];
                    }

              * Inference
                 * Note that we didn’t have to specify Type in this sample. The type was inferred - chosen automatically - by TypeScript.
                 * We can use multiple type parameters as well. For example, a standalone version of map would look like this:
                     function map<I, O>(arr: I, func: (arg: I) => O): O[] {
                          return arr.map(func);
                     }
    
    

               * Constraints -
                   * We’ve written some generic functions that can work on any kind of value. Sometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a constraint to limit the kinds of types that a type parameter can accept.
                   * Let’s write a function that returns the longer of two values. To do this, we need a length property that’s a number. We constrain the type parameter to that type by writing an extends clause:
                   * ex.
                         function longest <Type extends { length: number }>(a: Type, b: Type): Type {
                           return (a.length >= b.length)? a: b;
                         }
                     
                     const longerArray = longest([1, 2], [1, 2, 3]);   // longerArray is of type 'number[]'
                     const longerString = longest("alice", "bob");               // longerString is of type 'alice' | 'bob'
                     const notOK = longest(10, 100);               // Error! Numbers don't have a 'length' property
      

                * Working with Constrained Values -
                           function minimumLength<Type extends { length: number }>(
                              obj: Type,
                              minimum: number
                            ): Type {
                              if (obj.length >= minimum) {
                                return obj;
                              } else {
                                return { length: minimum };
                            Type '{ length: number; }' is not assignable to type 'Type'.
                              '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.
                              }
                            }
      
                       * It might look like this function is OK - Type is constrained to { length: number }, and the function either returns Type or a value matching that constraint. The problem is that the function promises to return the same kind of object as was passed in, not just some object matching the constraint. If this code were legal, you could write code that definitely wouldn’t work:
                                         // 'arr' gets value { length: 6 }
                                         const arr = minimumLength([1, 2, 3], 6);
                                         // and crashes here because arrays have
                                         // a 'slice' method, but not the returned object!
                                         console.log(arr.slice(0));



                  * Specifying Type Arguments -
                       * TypeScript can usually infer the intended type arguments in a generic call, but not always. For example, let’s say you wrote a function to combine two arrays:
                           function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
                             return arr1.concat(arr2);
                           }
                           const arr = combine([1, 2, 3], ["hello"]);     //Type 'string' is not assignable to type 'number'.
                       * so for this, we can write like following -
                              const arr = combine<string | number>([1, 2, 3], ["hello"]);     //possible way


                  * Guidelines for Writing Good Generic Functions -
                      * Push Type Parameters Down - push type parameters down refers to the practice of passing type parameters to functions and type constructors as arguments, rather than constraining them. This can help to improve the type safety and readability of your code.
                          check again
                      * Use Fewer Type Parameters - check again
                      * Type Parameters Should Appear Twice -check again



          * Optional Parameters - we can make parameter as optional.
                 function f(x?: number) {}

          * Optional Parameters in Callbacks - 
                 * Rule: When writing a function type for a callback, never write an optional parameter unless you intend to call the function without passing that argument

          * Function Overloads -
                * we can specify a function that can be called in different ways by writing overload signatures. 
                * To do this, write some number of function signatures (usually two or more), followed by the body of the function
                * In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the overload signatures.
                * ex.
                     function makeDate(timestamp: number): Date;
                     function makeDate(m: number, d: number, y: number): Date;
                     function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
                       if (d !== undefined && y !== undefined) {
                         return new Date(y, mOrTimestamp, d);
                       } else {
                         return new Date(mOrTimestamp);
                       }
                     }
                     const d1 = makeDate(12345678);
                     const d2 = makeDate(5, 5, 5);
                     const d3 = makeDate(1, 3);
                 *  Then, we wrote a function implementation with a compatible signature. Functions have an implementation signature, but this signature can’t be called directly. Even though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters

           * Overload Signatures and the Implementation Signature -
                    ex. 
                        function fn(x: string): void;
                        function fn() {
                          // ...
                        }
                        // Expected to be able to call with zero arguments
                        fn();
                        Expected 1 arguments, but got 0.
                  
                     * The implementation signature must also be compatible with the overload signatures. For example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:
                         function fn(x: boolean): void;
                         // Argument type isn't right
                         function fn(x: string): void;
                         This overload signature is not compatible with its implementation signature.
                         function fn(x: boolean) {}


                        function fn(x: string): string;
                        // Return type isn't right
                        function fn(x: number): boolean;
                        This overload signature is not compatible with its implementation signature.
                        function fn(x: string | number) {
                          return "oops";
                        }


           * Writing Good Overloads - 
                    ex.
                           function len(s: string): number;
                           function len(arr: any[]): number;
                           function len(x: any) {
                             return x.length;
                           }
                    * This function is fine; we can invoke it with strings or arrays. However, we can’t invoke it with a value that might be a string or an array, because TypeScript can only resolve a function call to a single overload:
                         len(""); // OK
                         len([0]); // OK
                         len(Math.random() > 0.5 ? "hello" : [0]);

                         //error
                               No overload matches this call.
                               Overload 1 of 2, '(s: string): number', gave the following error.
                                 Argument of type 'number[] | "hello"' is not assignable to parameter of type 'string'.
                                   Type 'number[]' is not assignable to type 'string'.
                               Overload 2 of 2, '(arr: any[]): number', gave the following error.
                                 Argument of type 'number[] | "hello"' is not assignable to parameter of type 'any[]'.
                                   Type 'string' is not assignable to type 'any[]'.
 
                    * Because both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:
                           function len(x: any[] | string) {
                            return x.length;
                          }


           * Declaring this in a Function - 
               * The JavaScript specification states that you cannot have a parameter called this, and so TypeScript uses that syntax space to let you declare the type for this in the function body.
               check again

           * Other Types to Know About -
               * void -
                   * void represents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any return statements, or doesn’t return any explicit value from those return statements.
                        function noop() {
                          return;
                        }
                    * However, void and undefined are not the same thing in TypeScript

              * object -
                   * The special type object refers to any value that isn’t a primitive
                   * This is different from the empty object type { }, and also different from the global type Object. It’s very likely you will never use Object
                   * object is not Object. Always use object!
                   * Note that in JavaScript, function values are objects: They have properties, have Object.prototype in their prototype chain, are instanceof Object, you can call Object.keys on them, and so on. For this reason, function types are considered to be objects in TypeScript.

              * unknown -
                   * The unknown type represents any value.
                   * This is similar to the any type, but is safer because it’s not legal to do anything with an unknown value.
                      function f2(a: unknown) {
                        a.b();     //'a' is of type 'unknown'.
                      }

              * never - Some functions never return a value. 
                   * The never type represents values which are never observed. In a return type, this means that the function throws an exception or terminates execution of the program.
                     function fail(msg: string): never {
                       throw new Error(msg);
                     }
                    * never also appears when TypeScript determines there’s nothing left in a union.

             * Function -
                * The global type Function describes properties like bind, call, apply, and others present on all function values in JavaScript. It also has the special property that values of type Function can always be called; these calls return any.


   * Rest Parameters and Arguments -
                 * Rest Parameters - A rest parameter appears after all other parameters, and uses the ... syntax.
                 * Rest Arguments - check again

             * Parameter Destructuring - 
                    * You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this.
                    function sum({ a, b, c }) {
                      console.log(a + b + c);
                    }
                    sum({ a: 10, b: 3, c: 9 });

              * Assignability of Functions -
                    * Return type void
                       check again

5) Object Types -
      * In JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through object types.
      * they can be anonymous or they can be named by using either an interface
      * cheatsheet - https://www.typescriptlang.org/cheatsheets

      * Property Modifiers -
          * Each property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to.
          * Optional Properties - we can mark properties as optional by adding a question mark (?) to the end of their names. Here, they mention about - " TS tell us that, parameter might be undefined, if they didn't set  with default value for optional property". and "we can set default value".

      * readonly Properties - 
            * Properties can also be marked as readonly for TypeScript. While it won’t change any behavior at runtime, a property marked as readonly can’t be written to during type-checking.
          ex.
              interface SomeType {
                readonly prop: string;
              }
               
              function doSomething(obj: SomeType) {
                console.log(`prop has the value '${obj.prop}'.`);    // We can read from 'obj.prop'.
                obj.prop = "hello";                // But we can't re-assign it.  Cannot assign to 'prop' because it is a read-only property.
              }

            * we cannot update the property itself. but we can update value of properties which is inside of given property.
            * Using the readonly modifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed. It just means the property itself can’t be re-written to.

            * ex.
                              interface Home {
                                readonly resident: { name: string; age: number };
                              }
                               
                              function visitForBirthday(home: Home) {
                                // We can read and update properties from 'home.resident'.
                                console.log(`Happy birthday ${home.resident.name}!`);
                                home.resident.age++;
                              }
                               
                              function evict(home: Home) {
                                // But we can't write to the 'resident' property itself on a 'Home'.
                                home.resident = {
                              Cannot assign to 'resident' because it is a read-only property.
                                  name: "Victor the Evictor",
                                  age: 42,
                                };
                              }



      * Index Signatures - 
            * Sometimes you don’t know all the names of a type’s properties ahead of time, but you do know the shape of the values.
             ex.   interface StringArray {
                      [index: number]: string | number;
                    }
                   const myArray: StringArray = getStringArray();
                   const secondItem = myArray[1];
                   
             * Only some types are allowed for index signature properties: string, number, symbol, template string patterns, and union types consisting only of these.
             * properties of different types are acceptable if the index signature is a union of the property types
             * you can make index signatures readonly in order to prevent assignment to their indices.
                    interface ReadonlyStringArray {
                      readonly [index: number]: string;
                    }
                    let myArray: ReadonlyStringArray = getReadOnlyStringArray();
                    myArray[2] = "Mallory";          //Index signature in type 'ReadonlyStringArray' only permits reading.


      * Excess Property Checks - 
           * Where and how an object is assigned a type can make a difference in the type system. One of the key examples of this is in excess property checking, which validates the object more thoroughly when it is created and assigned to an object type during creation.
               interface SquareConfig {
                 color?: string;
                 width?: number;
               }
               function createSquare(config: SquareConfig): { color: string; area: number } {
                 return {
                   color: config.color || "red",
                   area: config.width ? config.width * config.width : 20,
                 };
               }
               let mySquare = createSquare({ colour: "red", width: 100 });  // Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
           * Object literals get special treatment and undergo excess property checking when assigning them to other variables, or passing them as arguments. 
           * If an object literal has any properties that the “target type” doesn’t have, you’ll get an error: - 
                   let mySquare = createSquare({ colour: "red", width: 100 }); 
                   // Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?

      * Extending Types -
            * interface Colorful {
                color: string;
              }
              interface Circle {
                radius: number;
              }
              interface ColorfulCircle extends Colorful, Circle {}
              const cc: ColorfulCircle = {
                color: "red",
                radius: 42,
              };

      * Intersection Types - 
            * interfaces allowed us to build up new types from other types by extending them. TypeScript provides another construct called intersection types that is mainly used to combine existing object types.
            * An intersection type is defined using the & operator.
            interface Colorful {
              color: string;
            }
            interface Circle {
              radius: number;
            }
             
            type ColorfulCircle = Colorful & Circle;

     * Interfaces vs. Intersections -
          * We just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an extends clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principal difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type.

          * If interfaces are defined with the same name, TypeScript will attempt to merge them if the properties are compatible. If the properties are not compatible (i.e., they have the same property name but different types), TypeScript will raise an error.

          * In the case of intersection types, properties with different types will be merged automatically. When the type is used later, TypeScript will expect the property to satisfy both types simultaneously, which may produce unexpected results.
          
          For example, the following code will throw an error because the properties are incompatible:
                      interface Person {
                        name: string;
                      }
                      interface Person {
                        name: number;
                      }

          In contrast, the following code will compile, but it results in a never type:
                       interface Person1 {
                         name: string;
                       }
                        
                       interface Person2 {
                         name: number;
                       }
                        
                       type Staff = Person1 & Person2
                        
                       declare const staffer: Staff;
                       staffer.name;
                                
                       (property) name: never


 

     * Generic Object Types -
         interface Box<Type> {
            contents: Type
         }
         * Think of Box as a template for a real type, where Type is a placeholder that will get replaced with some other type.
         * When TypeScript sees Box<string>, it will replace every instance of Type in Box<Type> with string, and end up working with something like { contents: string }
         * means that we can avoid overloads entirely by instead using generic functions.
            function setContents<Type>(box: Box<Type>, newContents: Type) {
             box.contents = newContents;
           }
         * using a type alias -
              type Box<Type> = {
                 contents: Type;
               };

         * Since type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types.

      * The Array Type -
          * Whenever we write out types like number[] or string[], that’s really just a shorthand for Array<number> and Array<string>.

      * The ReadonlyArray Type -
           * The ReadonlyArray is a special type that describes arrays that shouldn’t be changed.
           * Unlike Array, there isn’t a ReadonlyArray constructor that we can use.
           * Just as TypeScript provides a shorthand syntax for Array<Type> with Type[], it also provides a shorthand syntax for ReadonlyArray<Type> with readonly Type[].
           * ex. values: readonly string[]
           * One last thing to note is that unlike the readonly property modifier, assignability isn’t bidirectional between regular Arrays and ReadonlyArrays.
                     let x: readonly string[] = [];
                     let y: string[] = [];
                      
                     x = y;
                     y = x;
                     The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.


      * Tuple Types -
           * A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.
           * type StringNumberPair = [string, number];

      * readonly Tuple Types -
           * function doSomething(pair: readonly [string, number]) { // ... }


* Type Manipulation -
      * Generics -
                 * function identity<Type>(arg: Type): Type {
                     return arg;
                   }
                   let output = identity<string>("myString");  
                   let output = identity("myString");
     
                 * Working with Generic Type Variables -
                        function loggingIdentity<Type>(arg: Array<Type>): Array<Type> {
                          console.log(arg.length); // Array has a .length, so no more error
                          return arg;
                        }
                         OR
                        function loggingIdentity<Type>(arg: Type[]): Type[] {
                          console.log(arg.length);
                          return arg;
                        }
                  * check in detail

            * Generic Types -

            * Generic Classes -
                  * A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (<>) following the name of the class.
                  * ex. 
                           class GenericNumber<NumType> {
                              zeroValue: NumType;
                              add: (x: NumType, y: NumType) => NumType
                           }
                           let myNum = new GenericNumber<number>();
                           // let stringNumeric = new GenericNumber<string>();    // for string
                           myNum.zeroValue = 0;
                           myNum.add = function( x, y ) => {
                                     return x + y;
                           }
                   * As we cover in our section on classes, a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class’s type parameter.


         * Generic Constraints -
              * working with any and all types, we’d like to constrain this function to work with any and all types that also  have the .length property. As long as the type has this member, we’ll allow it, but it’s required to have at least this member.
              * ex.
                   interface Lengthwise {
                     length: number;
                   }
                   function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {
                     console.log(arg.length); // Now we know it has a .length property, so no more error
                     return arg;
                   }
                  // loggingIdentity(3);    //Error - Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.


        * Using Type Parameters in Generic Constraints -
              * You can declare a type parameter that is constrained by another type parameter. For example, here we’d like to get a property from an object given its name. We’d like to ensure that we’re not accidentally grabbing a property that does not exist on the obj, so we’ll place a constraint between the two types.
              * ex.
                    function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
                     return obj[key];
                   }
                   let x = { a: 1, b: 2, c: 3, d: 4 };
                   getProperty(x, "a");
                   getProperty(x, "m");                  // Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.


         * Using Class Types in Generics -
               * When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,
               * function create<Type>(c: { new (): Type }): Type {
                   return new c();
                 }

         * Generic Parameter Defaults -
                check again


   * Keyof Type Operator -
         * The keyof type operator - 
              * The keyof operator takes an object type and produces a string or numeric literal union of its keys. The following type P is the same type as type P = "x" | "y":
                type Point = { x: number; y: number };
                type P = keyof Point;      // keyof point will represent "x" or "y"
                let d: P = "x";    // "x" or "y"

   * The typeof type operator -
               * JavaScript already has a typeof operator you can use in an expression context.
                 console.log(typeof "Hello world");         // Prints "string"
               * TypeScript adds a typeof operator you can use in a type context to refer to the type of a variable or property:
                 let s = "hello";
                 let n: typeof s;

    * Indexed Access Types -
         * We can use an indexed access type to look up a specific property on another type:
             type Person = { age: number; name: string; alive: boolean };
             type Age = Person["age"];             //type Age = number
         * The indexing type is itself a type, so we can use unions, keyof, or other types entirely:
             type I1 = Person["age" | "name"];            //type I1 = string | number
              
             type I2 = Person[keyof Person];             // type I2 = string | number | boolean
              
             type AliveOrName = "alive" | "name";
             type I3 = Person[AliveOrName];              // type I3 = string | boolean

             check again


   * Conditional Types -
         * ex.
                interface Animal {
                  live(): void;
                }
                interface Dog extends Animal {
                  woof(): void;
                }
                type Example1 = Dog extends Animal ? number : string;                // type Example1 = number                 
                type Example2 = RegExp extends Animal ? number : string;             //   type Example2 = string

          * Conditional types take a form that looks a little like conditional expressions (condition ? trueExpression : falseExpression) in JavaScript:
                   SomeType extends OtherType ? TrueType : FalseType;
          * power of conditional types comes from using them with generics.


             check again


    * Mapped Types -
          * 

    * Template Literal Types -


    * Classes -

    * Modules -


--------------------------------------------------------------------------------------------------------------------------------------------------------
Referenece -

1) Utility Types -
     * Awaited<Type> -
          * This type is meant to model operations like await in async functions, or the .then() method on Promises - specifically, the way that they recursively unwrap Promises.
             type A = Awaited<Promise<string>>;      //   type A = string
             type B = Awaited<Promise<Promise<number>>>;     //   type B = number
             type C = Awaited<boolean | Promise<number>>;      //  type C = number | boolean

     * Partial<Type> - Constructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type.
            interface Todo {
              title: string;
              description: string;
            }
            function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
              return { ...todo, ...fieldsToUpdate };
            }
            const todo1 = {
              title: "organize desk",
              description: "clear clutter",
            };
            const todo2 = updateTodo(todo1, {
              description: "throw out trash",
            });

     * Required<Type> - Constructs a type consisting of all properties of Type set to required. The opposite of Partial.
            interface Props {
               a?: number;
               b?: string;
             }
             const obj: Props = { a: 5 };
             const obj2: Required<Props> = { a: 5 };

      * Readonly<Type> - Constructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.
              interface Todo {
                 title: string;
               } 
               const todo: Readonly<Todo> = {
                 title: "Delete inactive users",
               };
               todo.title = "Hello";               // Cannot assign to 'title' because it is a read-only property.

      * Record<Keys, Type> - Constructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.
             interface CatInfo {
               age: number;
               breed: string;
             }
             type CatName = "miffy" | "boris" | "mordred";
             const cats: Record<CatName, CatInfo> = {
               miffy: { age: 10, breed: "Persian" },
               boris: { age: 5, breed: "Maine Coon" },
               mordred: { age: 16, breed: "British Shorthair" },
             };
             cats.boris;             // const cats: Record<CatName, CatInfo>

      * Pick<Type, Keys> - Constructs a type by picking the set of properties Keys (string literal or union of string literals) from Type.
             interface Todo {
               title: string;
               description: string;
               completed: boolean;
             }
             type TodoPreview = Pick<Todo, "title" | "completed">;
             const todo: TodoPreview = {
               title: "Clean room",
               completed: false,
             };
              
             todo;               // const todo: TodoPreview

       * Omit<Type, Keys> - Constructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals). The opposite of Pick.
       * Exclude<UnionType, ExcludedMembers> - Constructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers.
            type T0 = Exclude<"a" | "b" | "c", "a">;             // type T0 = "b" | "c"
            type T1 = Exclude<"a" | "b" | "c", "a" | "b">;                // type T1 = "c"
       * Extract<Type, Union> - Constructs a type by extracting from Type all union members that are assignable to Union.
            type T0 = Extract<"a" | "b" | "c", "a" | "f">;              // type T0 = "a"
            type T1 = Extract<string | number | (() => void), Function>;          //type T1 = () => void
       * NonNullable<Type> - Constructs a type by excluding null and undefined from Type.
            type T0 = NonNullable<string | number | undefined>;            //type T0 = string | number
            type T1 = NonNullable<string[] | null | undefined>;              //type T1 = string[]
       * Parameters<Type> - Constructs a tuple type from the types used in the parameters of a function type Type.
            


3) Decorators -
  * With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members.


4) Declaration Merging -
  * 

5) Enums -

6) Iterators and Generator - 

7) JSX -

8) Mixins -
   * Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes
   * The pattern relies on using generics with class inheritance to extend a base class. TypeScript’s best mixin support is done via the class expression pattern.
   * ex.
   class Sprite {
     name = "";
     x = 0;
     y = 0;
    
     constructor(name: string) {
       this.name = name;
     }
   }
   
    
   type Constructor = new (...args: any[]) => {};
   function Scale<TBase extends Constructor>(Base: TBase) {
     return class Scaling extends Base {
       // Mixins may not declare private/protected properties
       // however, you can use ES2020 private fields
       _scale = 1;
    
       setScale(scale: number) {
         this._scale = scale;
       }
    
       get scale(): number {
         return this._scale;
       }
     };
   }
   
   const EightBitSprite = Scale(Sprite);
    
   const flappySprite = new EightBitSprite("Bird");
   flappySprite.setScale(0.8);
   console.log(flappySprite.scale);
   console.log(flappySprite.x);
   console.log(flappySprite.y);
   

9) Namespace -
   * This post outlines the various ways to organize your code using namespaces (previously “internal modules”) in TypeScript. As we alluded in our note about terminology, “internal modules” are now referred to as “namespaces”. 

10) Namespace and modules -

11) Symbols -
   * Starting with ECMAScript 2015, symbol is a primitive data type, just like number and string.
   * Symbols are immutable, and unique.
   ex. 
           let sym2 = Symbol("key");
           let sym3 = Symbol("key");
           sym2 === sym3; // false, symbols are unique
   * Just like strings, symbols can be used as keys for object properties.

   * Well-known Symbols
       In addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.  
       * Here is a list of well-known symbols:
       
       Symbol.asyncIterator - A method that returns async iterator for an object, compatible to be used with for await..of loop.
       
       Symbol.hasInstance -  A method that determines if a constructor object recognizes an object as one of the constructor’s instances. Called by the semantics of the instanceof operator.
       
       Symbol.isConcatSpreadable -  A Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat.
       
       Symbol.iterator -  A method that returns the default iterator for an object. Called by the semantics of the for-of statement.
       
       Symbol.match - A regular expression method that matches the regular expression against a string. Called by the String.prototype.match method.
       
       Symbol.replace - A regular expression method that replaces matched substrings of a string. Called by the String.prototype.replace method.
       
       Symbol.search - A regular expression method that returns the index within a string that matches the regular expression. Called by the String.prototype.search method.
       
       Symbol.species - A function valued property that is the constructor function that is used to create derived objects.
       
       Symbol.split - A regular expression method that splits a string at the indices that match the regular expression. Called by the String.prototype.split method.
       
       Symbol.toPrimitive - A method that converts an object to a corresponding primitive value. Called by the ToPrimitive abstract operation.
       
       Symbol.toStringTag - A String value that is used in the creation of the default string description of an object. Called by the built-in method Object.prototype.toString.
       
       Symbol.unscopables - An Object whose own property names are property names that are excluded from the ‘with’ environment bindings of the associated objects.


12) Triple-slash directive

13) Type Compatibility -
    * Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:
         interface Pet {
           name: string;
         }
         class Dog {
           name: string;
         }
         let pet: Pet;
         // OK, because of structural typing
         pet = new Dog();

     * In nominally-typed languages like C# or Java, the equivalent code would be an error because the Dog class does not explicitly describe itself as being an implementer of the Pet interface.

     * Starting out - The basic rule for TypeScript’s structural type system is that x is compatible with y if y has at least the same members as x.
          interface Pet {
            name: string;
          }
          let pet: Pet;
          // dog's inferred type is { name: string; owner: string; }
          let dog = { name: "Lassie", owner: "Rudd Weatherwax" };
          pet = dog;

14) Type Inference

15) variable declaration -
  * var declarations -
     * Declaring a variable in JavaScript has always traditionally been done with the var keyword.
     * example which shows scope chain 
     * Scoping rules -
     * Variable capturing quirks

  * let declarations
      * Block-scoping
      * Re-declarations and Shadowing
      * Block-scoped variable capturing
      * const declarations

  * let vs. const

  * Destructuring
      * Array destructuring
      * Tuple destructuring
      * Object destructuring -
             let o = {
               a: "foo",
               b: 12,
               c: "bar",
             };
             let { a, b } = o;

          * property renaming -
                 let { a: newName1, b: newName2 } = o;
                 let { a: newName1, b: newName2 }: { a: string; b: number } = o;
          
          * Default values -
                 function keepWholeObject(wholeObject: { a: string; b?: number }) {
                  let { a, b = 1001 } = wholeObject;
                }


    * Function declarations

Spread
using declarations
null and undefined
Defining a disposable resource
await using declarations
Defining an asynchronously disposable resource
await using vs await
await using and return
using and await using in for and for..of statements
using and await using in older runtimes
Is this page helpful?
YesNo


   * you usually don’t need type annotation because TypeScript will infer type at its own
   * 
