Understanding TypeScript - 2022 Edition ( Maximillian, Udemy )

5)
TS Advantages - 
* TS adds types and data.we can avoid errors with the help of types.
* we can use next gen JS feature, by adding TS file and converting it to JS workaround for older version of browser.
* TS introduce interface and generics
* TS also have decorators
* rich configuation options


9)
* create simple setup 
* add another package called 'lite-server', development server to keep reload website on saving new changes.
* install "sudo npm i -g typescript"
* tsc app.ts
* npm init -y
* npm i --save-dev lite-server


11) Using Types =
Core Types
* Number = number is type which available in JS and TS. ex. 4,4.2,-19
* String = string is type which available in JS and TS. ex. "s", 's', `s`
* boolean = true and false

12, 13)* typescript uses for mostly preventing errors by specifying types.
* Using TS, we can assign types and much more, so we avoid mistakes by other developer.
* TS work at compilation level, means it converts ts files into JS files. bcz browser doesnt understand ts.
* JS uses "dynamic types" (resolved at runtime) and TS uses "static types" (resolved at development).
* Core primitives in TS, all are lowercase.


14) Working with number, string and boolean:-



15) Type Assignment and Type Inference = 
* we can assign type to variable in TS. var a: number = 34; It's redundant, not necessary.
* TS provide type Inference, which decide type of variable on its own. var a = 34
* TS using Type Inference, yells on us when assigning another type of value.


16) Object Types =
* Object Types are look like JS objects, but do have ";" instead ","
* Object Types inferred by TS, we do have key-type pairs.
* like number, we do have generic type called "object".
* we can use "object" type instead to be more generic. "object" is built in generic type.
ex. var person: {
    name: string;
    age: number
} = {
    name: "sumeet",
    age: 30
}


17) Nested Objects and types =
* Of course object types can also be created for nested objects.
* Let's say you have this JavaScript object:
    const product = {
      id: 'abc1',
      price: 12.99,
      tags: ['great-offer', 'hot-and-new'],
      details: {
        title: 'Red Carpet',
        description: 'A great carpet - almost brand-new!'
      }
    }
* This would be the type of such an object:
    {
      id: string;
      price: number;
      tags: string[];
      details: {
        title: string;
        description: string;
      }
    }


18) Array Types = 
* var a = ["cooking", "travel"]     // IDE able to show => a: string[]
* In above statement, it shows we can add only value of "string" type. It won't allow other types of data.


19) Working with Tuples = 
* tuple = its fixed length and fixed type array
* TypeScript introduced a new data type called Tuple. If we know in advance, about value and its type, then we can able to apply more strictness using tuple also.
* You can declare an array of tuple also.
* push is allow with tuples. its an exception.
* ex. 
    var employee: [number, string][];
    employee = [[1, "Steve"], [2, "Bill"], [3, "Jeff"]];
* ex. 
    const person: {
        name: string;
        role: [number, number, string]
    } = {
        name: "sumeet",
        role: [2,4, "sumeett"]
    }

    person.role.push(4, 5, "sdsdd");        // exception with push
    console.log("ohjhhhhhhhhhhhhhhh", person.role);


20) Working with Enums =
* Enums or enumerations are a new data type supported in TypeScript.
* In simple words, enums allow us to declare a set of named constants i.e. a collection of related values that can be numeric or string values.
* enums are like global variable with value. so when we want to update value, we need to update at single place.
* ex. 
    enum Role { Admin, Author, Developer }          //
    enum Role { Admin = "R", Author = 100, Developer = "code" }     // contain string, number and so on.


21) Any type =
* variable contain any value
* if you know types of data, just specify.



22) Union types = 
* To use one from multiple types.
* ex.
    var a: string | number | boolean = 23;



23) Literal Types =
* using value as type.
* ex. let result: "sumeet" | "shedge" = "sumeet";



24) Type Aliases/ Custom Types =
* Type Aliases used as Aliases.

ex. type Combinable = number | string;
var a: Combinable | boolean = 23;


25) Type Aliases & Object Types
* Type aliases can be used to "create" your own types. You're not limited to storing union types though - you can also provide an alias to a (possibly complex) object type.

For example:
    type User = { name: string; age: number };
    const u1: User = { name: 'Max', age: 30 }; // this works!
* This allows you to avoid unnecessary repetition and manage types centrally.

For example, you can simplify this code:
    function greet(user: { name: string; age: number }) {
        console.log('Hi, I am ' + user.name);
    }
    
    function isOlder(user: { name: string; age: number }, checkAge: number) {
        return checkAge > user.age;
    }
To:

    type User = { name: string; age: number };
    function greet(user: User) {
        console.log('Hi, I am ' + user.name);
    }
    
    function isOlder(user: User, checkAge: number) {
        return checkAge > user.age;
    }


26) function return types and void
* TS provide way to infer type of return value.
*ex. function vv(a: number, b: number): number {
    return a + b;
}
* when function doesnt return anything, TS provide "void" for this.


27) Functions as Types =
* To add function as type.
* var examFunc: (a: number, b: number) => number        // Take 2 arguments and return value


28) function Types and callbacks =
* we can pass function as callback.
* callback functions can return something, even if the argument on which they're passed does NOT expect a returned value.
* ex. function sayHi(): void {
    ...
}
* "void" doesn't force you to return anything if you don't want to return something.


29) Unknown =
* use "Unknown" instead of "any", if you knew something will assigned there in future.
* its bit risky.


30)The "Never" type =
* "Never" assign to Error function


31) wrap up -



34) The typescript compiler and its configuration -
* use "-- watch" mode to see new changes without re-running command.
* command  - tsc index.ts --watch


35) compiling the Entire Project / Multiple Files -
* run "tsc --init" to create TS configuration.
* run "tsc --watch" or "tsc -w".


36) Including and Excluding Files -
* to exclude and include file, we can add property in tsconfig.json.
* "file" option also used for add files. but it only takes single files.

37) Setting a Compilation Target -
* by setting target, we can target to specific version. 


38) Understanding TypeScript Core Libs -
* TS config has "lib" property, which helps to provide support for "dom", "es6" and many more. TS don't know about Dom, es6 and others. by including these options, we can able to give support. by default, it has support for browser related features.


39) 




Classes and Interfaces -

58) what are classes?
* class are blueprint of object.
* we call object as "instance of class".

59) Creating a First Class -
* ex. 
class Department {
    name: string;       // field of class (key: type)

    constructor(n: string){     // called when creating obj from class
        this.name = n;
    }
}

const accounting = new Department("accounting");    // create obj
console.log(accounting);


61) constructor function and this keyword =
* ex. 
class Department {
    name: string;

    constructor(n: string){
        this.name = n;
    }
    describe(){
        console.log(`value ${this.name}`);
    }
}

const accounting = new Department("accounting");
console.log(accounting);

const accountingCopy = { describe: accounting.describe, name: "sumeet" }
console.log(accounting);



62) "private" and "public" access modifiers =
* "private" and "public" are available in TS compilation time, not runtime

class Department {
    public name: string;                    // public is default
    private employee: string[] = [];        // properties becomes private, accessible only from inside
    constructor(n){
        this.name = n;
    }
    describe(){
        console.log(`value ${this.name}`);
        this.employee.push("s");
    }
    rr = () => {
        console.log(`value ${this.name}`)
        this.employee.push("s");
    }
}

const accounting = new Department("accounting");
console.log(accounting);

const accounting1 = new Department("accounting");
console.log(accounting1);

accounting.describe()
accounting.rr()

accounting1.describe()
accounting1.rr()


63) shorthand initialization = 
*  here, in following code,we can initialize and assign "id" and "name" in constructor, instead of seprate declaration and initialization
*

class Department {
    // public name: string;         // no need
    // private id: string;          // no need
    private employee: string[] = [];
    constructor(public name: string, private id: string){       // we need to use same name for property declaration
        // this.name = n;
    }
    ....
}

const accounting = new Department("accounting", "d1");


64) "readonly" properties =
* we have certain fields which should not just be private or public. they also shouldn't change after their initialization.
ex.  
    public readonly name: string;
    or
    constructor(public name: string, private readonly id: string){
* to add some extra safety, we can add "readonly"



65) Inheritance -
* we can't inherit multiple class, only one class inherited

class ITDepart extends Department {
    constructor(id: string, admins: string[] ){
        super(id, "IT");                    // will call constructor of base class.
    }
}
var de = new ITDepart("name", "Information Tech");



66) Overriding Properties and the "protected" modifier =
* we can't access "private" property of parent class from child class. in above code, ITDepart one.
* hence, we will use "protected" instead "private". so we can access from any child class, and at the same time, it's not accessible from outside of class like "private".
* we can override methods of your base class.

class Department {
    ...
    protected employee: string[] = [];
    ...
}


67) Getters and Setters -
* if we want to read or change the values of private members outside the class, we'll have to use the public get and set methods. The get method is used to return the data/value. It is also known as an accessor method. The set method is used to set or update the value/data.
* ex - 
    class ITDepart extends Department {
        private lastReport: string;
        get mostRecentReport(){
            return this.lastReport;
        }
        set mostRecentReport(val:string){
            this.addReport(val);
        }
        addReport(text:string){
            this.lastReport = text
        }
    }
    ITDepart.mostRecentReport = "Year end report";
    ITDepart.addReport('something went wrong');
    console.log(ITDepart.mostRecentReport);


68) Static Methods and Properties -
* Static properties and methods allow you to add properties and methods to classes which are not accessed on an instance of class. Instead you can access directly from class.
* you cannot access static properties and methods within non static code.
ex. class Dep {
        static fiscalYear = 2020;
        static createEmployee (name: string){
            return { name: name }
        }
        callApi = () => {
            console.log(this.fiscalYear);       // error, won't allow
        }
    }
    console.log(Dep.createEmployee());
    console.log(Dep.fiscalYear);
}


69) Abstract Classes -
* when you can't provide general implementation in base class and inheriting class need to provide their own implementation. we can acheive this by using "abstract class".
* abstract method should be available in abstract class.
* abstract class Dep {
    abstract display(this: Department): void;
}
class ITDepart extends Dep {
    display(){
        console.log("abstract class")
    }
}
* All classes based on some other class share common method or property. but at the same time you want to make sure that you don't have to provide concrete value, the concrete implementation in base class, but instead inheriting class do that.
* abstract class can't be instantiate


70) Singletons and Private Constructors -
* we can create only exactly one object based on this class in singleton pattern.
* need to learn again


71) Classes - A summary =
* we learned about classes, their properties, access modifier, private for internal access, protected for internal classes and inherited class, and public for access from anywhere, inheritance, get and set, readonly.
* static method and properties , abstract class,method and properties
* singleton pattern and private constructor


72) A First Interface =
* Interface - use it to describe how an object should look like. we can use interface as custom type. we can define structure not concrete value.
* interface Person {
    name: string;
    age: number;

    greet(phrase: string):void
}


73) Using interfacess with Classes -
* diff between custom types and interface - 
    1) interface and type can only be used to describe the structure of an object. but inside of custom type, we can store other things like union types and so on. But Interface is more clearer than custom type.
    2) when it comes to defining object types, you more often see interfaces out there in the wild, than custom types.

* implement interface with class - we can implement interface to multiple class like we do with extending ( inheritance ) a class. we can implement more than 1 interface. That's diff between inheritance and interface.
* So often we use interface to share functionality among the mulitple classes. Here, diff between abstract and interface, interface doesn't have implementation details at all. And abstract class have mixture of overwrite part and concrete implementation.

    class Person implements Greetable, Greetable1 {     // multiple interface implement
        name:string;
        constructor(name:string ){
            this.name = name;
        }
        greet(str:string){
            console.log("hi");
        }
    }


74) Why interfaces? =
* 


75) readonly interface properties =
* readonly modifier used in interface to set property of object once and bceomes read only. so after that, we can't be able to change after that. we can use "readonly" with custom type

76) Extendin interfaces =
* Interface can inherit multiple interface with "extend" keyword. we use this when we want to create small interface, which is required in multiple interface

*   interface Named {
        readonly name: string;
    }
    interface Greetable extends Named, AnotherInterface {
        greet(str: string): void;
    }


76) Interface as function types =
*   interface AddFn {
        (a: number, b: number): number
    }
    let add: AddFn;
    add = (n1: number, n2: number) => {
        return n1+n2;
    }


77) Optional Parameters and Properties =
* you can specify property "Optional" in class and interface as well.
* ex. - interface Named {
            optionalName?: string
        }
        class Names extend Named {
            name?: string;              // not necessary to make optional here
        }

--------------------------------------------------------------------------------------------------------------------------------

Number
String
boolean
object
array
enum
any
union
literal
type aliases
function return type and void type
Functions as types
Function types and callbacks
unknown
never


class Dep { 
    constructor(){ 
        this.tak = () => {
            console.log(this);      // { name: 'sumeet', age: 30, dis: ƒ, tak: ƒ }
        } 
    } 
    name = "sumeet";                
    age = 30;                       // instance member
    display(){                      // prototype member
        console.log(this);          // { name: 'sumeet', age: 30, dis: ƒ, tak: ƒ }
    }; 
    dis = () => {
        console.log(this);          // { name: 'sumeet', age: 30, dis: ƒ, tak: ƒ }
    }
}



enum Role { Admin = "R" }
type TypeName = { 
    name: string;
    age: number; 
}

var person: {
    name: string;
    age: number;
    arrayVal: string[];
    tuplesEx: [number, string][];
    unionType: string | number | array;
    literalType: "sumeet" | "shedge";
    typeEx: TypeName;
} = {}

function A (): number {
    return a+b      // OR   void
}

var examFunc: (a: number; b: number) => number  // function as types
-----------------------------------------------------------------------------------------------------------------------------------------------

StyleGuide for Typescript -
https://google.github.io/styleguide/tsguide.html


------------------

Handbook-

The Basics ->
* Static Type-Checking

The primitives:  string,  number, and boolean -
ex.
let ex1: string = "Hello world!"
let ex2: number = 43
let ex3: boolean = true

Arrays - 
let ex4: number[] = [1,2,3]
let ex5: string[] = ["i", "j", "k"]
let ex6: Array<number> = [4,5,6]    //we can write this way also

any -
let ex7: any = true
noImplicitAny - Use the compiler flag noImplicitAny to flag any implicit any as an error.

Type Annotations on Variables -
let ex8: string = "sumeet"

Functions -
Functions are the primary means of passing data around in JavaScript. TypeScript allows you to specify the types of both the input and output values of functions.

Parameter Type Annotations -
    function ex9 (a: string){}

Return Type Annotations -
    function ex9 (a: string): string{}

Functions Which Return Promises -
    async function getFavoriteNumber(): Promise<number> {
        return 26;
    }

Anonymous Functions -
    const names = ["Alice", "Bob", "Eve"];
    
    // Contextual typing for function - parameter s inferred to have type string
    names.forEach(function (s) {
        console.log(s.toUpperCase());
    });
    
    // Contextual typing also applies to arrow functions
    names.forEach((s) => {
        console.log(s.toUpperCase());
    });

* Even though the parameter s didn’t have a type annotation, TypeScript used the types of the forEach function, along with the inferred type of the array, to determine the type s will have.
* This process is called contextual typing because the context that the function occurred within informs what type it should have.

Object Types - 
    function printCoord(pt: { x: number; y: number }) {}

Optional Properties -
    functoin printName(pt: { x: number, y?: number }) {
        if (obj.last !== undefined) {
            console.log(obj.last.toUpperCase());
        }
        console.log(obj.last?.toUpperCase());   //modern approach
    }


Union Types -
TypeScript’s type system allows you to build new types out of existing ones using a large variety of operators

Defining a Union Type -
A union type is a type formed from two or more other types, representing values that may be any one of those types. 


---------------------------------------------------------------------------------------------
typescript Class - 22092023

class Point {
  x: number = 0; //here, x is declaration, "number" is type annotation and x is initalize with 0
  
  y // if type not specified, by default "any" will be present
  readonly readOnlyEx: string = "hello world!"

  constructor(readonlyName:string = "default val"){   //constructors are very similar to functions
    this.readOnlyEx = readonlyName  // readonly-prevents assignments to the field outside of the constructor.
  }
}
const pt = new Point()
console.log(`${pt.x}${pt.y} - ${pt.readOnlyEx}`);

// Constructors
// few differences between class constructor signatures and function signatures:
// 1.Constructors can’t have type parameters - these belong on the outer class declaration,
// 2.Constructors can’t have return type annotations - the class instance type is always what’s returned


class Base {
  k = 4
}
class Derived extends Base {
  _length = 0;
  constructor(){
    super();    //dervied class must have "super" call.
  }
  scale(n: number): void{   //A function property on a class is called a method. 
    console.log(this.k);    //to access fields and other methods via "this"
  }
  get length(){
    return this._length
  }
  set length(val){
    this._length = val
  }
}

class IndexSignatureEx {
  [s: string]: boolean | ((s:string) => boolean);
}


// interface
interface Address {
  add: string;
  phone: number;
}
interface PinCode{
  pin: number
}
class InterfaceExample implements Address, PinCode{
  add = "Omkara hills";
  phone = 80880990;
  pin = 201230;
}


// extends
// Classes may extend from a base class. A derived class has all the properties and methods of its base class, and can also define additional members.
class Animal {
  move(){}
  greet(){}
}
class Dog extends Animal {
  checkSpeed(){}

  // A derived class can also override a base class field or property. You can use the super. 
  greet(val?:string){
    if(val){
      console.log("val", val);
    } else {
      super.greet()
    }
  }
}
const extendExample = new Dog();
extendExample.checkSpeed(); // child method
extendExample.move();   // parent method

class ParentClass1 {
  greet(){}
}
class ChildClass1 extends ParentClass1 {
  greet(){}
}
const d:ParentClass1 = new ChildClass1()


//Type-only Field Declarations ?


// Initialization Order
class Base1 {
  name = "base";
  constructor(){
    console.log(`this name is ${this.name}`)
  }
}
class Derived1 extends Base1 {
  name = "Derived";
}
const d1 = new Derived1();

// The order of class initialization, as defined by JavaScript, is:
//1. The base class fields are initialized
//2. The base class constructor runs
//3. The derived class fields are initialized
//4. The derived class constructor runs
// This means that the base class constructor saw its own value for name during its own constructor, because the derived class field initializations hadn’t run yet.



//Inheriting Built-in Types ?



// Member Visibility - Public, Protected, Private
// Public - The default visibility of class members is public.
// Protected - protected members are only visible to subclasses of the class they’re declared in
// Private - private is like protected, but doesn’t allow access to the member even from subclasses
class Greeter {
  public greet(){}
  protected greetName(){ return "Hi!!!"}
  private x = 0;
}
class GreetSpecial extends Greeter {
  greetSpecial(){
    console.log(`this is value: ${this.greetName()}`)
  }
}
const g = new GreetSpecial();
g.greetSpecial();
// console.log(g.x); - will give error, bcz x is private
// g.greetName(); - will give error



// Exposure of protected members
class Base2 {
  protected m = 10;
  private n = 11;
}
class Derived2 extends Base2 {
  m = 15;
}
let a = new Derived2()
console.log(a.m)
a.m = 19
console.log(a.m)


// Cross-hierarchy protected access


// Cross-instance private access

// Caveats


// Static Members
// Classes may have static members. These members aren’t associated with a particular instance of the class. They can be accessed through the class constructor object itself.
// Static members can also use the same public, protected, and private visibility modifiers
class MyClass {
  static x = 0;
  private static y = 10;
  static getGreeting(){
    return "Hello world";
  }
  static printX(){
    console.log(MyClass.x)
  }
}
class Der extends MyClass {
  myGreeting = MyClass.getGreeting();  // Static members are also inherited:
}
console.log(MyClass.x)
console.log(MyClass.printX)
//MyClass.y = 10;  will give error


// Special Static Names
// TypeScript (and JavaScript) don’t have a construct called static class the same way as, for example, C# does.
// Function properties like name, length, and call aren’t valid to define as static members.


// Why No Static Classes?
// TypeScript (and JavaScript) don’t have a construct called static class the same way as, for example, C# does.
// Those constructs only exist because those languages force all data and functions to be inside a class; because that restriction doesn’t exist in TypeScript, there’s no need for them. 
// For example, we don’t need a “static class” syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:


// static Blocks in Classes
// Static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals.



// Generic Classes
// Classes can use generic constraints and defaults the same way as interfaces.
class Base3<Type> {
  content: Type
  constructor(value: Type){
    this.content = value
  }
}
const gc = new Base3("Hello")
const g1c = new Base3(90)

// Type Parameters in Static Members



// this at Runtime in Classes
// by default, the value of this inside a function depends on how the function was called. 
class MyClass1 {
  name = "MyClass";
  getName(){
    return this.name;
  }
}
const myClass12 = new MyClass1()
let obj = {
  name: "obj",
  getName: myClass12.getName
}
console.log(obj.getName()); // will print "obj", not "MyClass"


// Arrow Functions
// If you have a function that will often be called in a way that loses its this context, it can make sense to use an arrow function property instead of a method definition:



// this parameters
// In a method or function definition, an initial parameter named this has special meaning in TypeScript. These parameters are erased during compilation:
// TypeScript input with 'this' parameter


// this Types



// this -based type guards



// Parameter Properties
// TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers public, private, protected, or readonly. The resulting field gets those modifier(s):
class Params {
  constructor(
     public readonly x: number,
     protected y: number,
     private z: number
  ){
  }
  getName(){
    console.log(this.x, this.y, this.z)
  }
}
const Pa = new Params(1,2,3)
console.log(Pa.x, )


// Class Expressions
const someClass = class<Type>{
  content: Type;
  constructor(value: Type){
    this.content = value
  }
}
const n = new someClass(90)


// Constructor Signatures



// abstract Classes and Members
// Classes, methods, and fields in TypeScript may be abstract.
// An abstract method or abstract field is one that hasn’t had an implementation provided. These members must exist inside an abstract class, which cannot be directly instantiated.
// The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesn’t have any abstract members, it is said to be concrete

abstract class Base4 {
  abstract getName():string
  printName(){
    console.log(this.getName())
  }
}
class Derived4 extends Base4 {
  getTeam(){}
  getName(){
    return "Hello"
  }
}
// const a1 = new Base4();  //Cannot create an instance of an abstract class.(2511)
// if getName method implementation not done in Derived4, will give error => Non-abstract class 'Derived4' does not implement all abstract members of 'Base4'(18052)



// Abstract Construct Signatures


// Relationships Between Classes
// In most cases, classes in TypeScript are compared structurally, the same as other types.
class Point1 {
  x = 0;
  y = 0;
}
class Point2 {
  x = 0;
  y = 0;
} 
// OK
const p: Point1 = new Point2();

