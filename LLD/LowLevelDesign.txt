Scaler - https://refactoring.guru/,	Head First Design Patterns: Building Extensible and Maintainable Object-Oriented Software

https://www.youtube.com/watch?v=aJxx-Y42rF0 -
  The Object Oriented Thought Process - https://amzn.to/3oqxt9g
  ✒ Design Patterns: Elements of Reusable Object-Oriented Software - https://amzn.to/31m2RgB
  ✒ Head First Design Patterns: Building Extensible and Maintainable Object-Oriented Software - https://amzn.to/3xTUwMZ
  ✒ Clean Code: A Handbook of Agile Software Craftsmanship - https://amzn.to/3pmfkZy
  ✒ Head First Object-Oriented Analysis and Design - https://amzn.to/3lB7QRt


---------------------------------------------------------------------------------------------------------------------------
// example given by Navin Reddy on youtube shorts - "Loose Coupling"
interface Computer {
    compile: () => void
}
class Desktop implements Computer {
    compile(){
        console.log("Desktop")
    }
}
class Laptop implements Computer {
    compile(){
        console.log("Laptop")
    }
}
class Programming {
    check(cl: Computer){
        cl.compile()
    }
}

class LooseCoupling {
    checkLC(){
        let deskInstance = new Desktop();
        let lapInstance = new Laptop();
        let d = new Programming();
        d.check(deskInstance);
        d.check(lapInstance);
    }
}
let c = new LooseCoupling();
c.checkLC();


---------------------------------------------------------------------------------------------------------------------------

// factory pattern
// When you have complex object creation logic and want to encapsulate it.
// When you need to create different types of related objects (e.g., different shapes, animals, or vehicles) in a flexible way.
// When you want to decouple object creation from client code, allowing flexibility in object instantiation.
// When you want to adhere to the Open/Closed Principle, making it easy to add new types without modifying existing code.
// When you need to control or manage the object creation process, such as ensuring singletons, pooling, or caching.
// When object creation depends on external input such as user preferences, configurations, or environment settings.
// When you need to isolate the client from concrete class implementations, allowing flexibility in changing the underlying logic without breaking the client.

interface Platform {
    getPlatformName: () => void
}
class Android implements Platform {
    getPlatformName(){
        console.log("Android");
    }
}
class Ios implements Platform{
    getPlatformName(){
        console.log("Ios")
    }
}

let OS = "Android";

// wrong approach
// const btn = OS === "ios"? new Android(): new Ios();

class createPlatformSpecific {
    createButton(OS: string){
        if(OS === "Android"){
            return new Android();
        } else {
            return new Ios();
        }
    }
}
let d = new createPlatformSpecific();
let e = d.createButton(OS);
console.log("factory pattern", e);      //"factory pattern",  Android: {} 

// Here "createPlatformSpecific" is factory function, which returns object based on given input, either "Android" or "Ios" object


---------------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------------

Builder Pattern -

// In TypeScript, the Builder pattern can be implemented to build an object by chaining methods, instead of giving multiple parameters
// Reasons -
// 1) When Object Construction Has Many Optional Parameters
// 2) When You Want to Avoid Large Constructors (Telescoping Constructor Problem)


// Step 1: Define the Product class
class User {
    public name: string;
    public age: number;
    public email: string;
    public address: string;

    constructor(builder: UserBuilder) {
        this.name = builder.name;
        this.age = builder.age;
        this.email = builder.email;
        this.address = builder.address;
    }
}

// Step 2: Create the Builder class
class UserBuilder {
    public name: string;
    public age: number;
    public email: string;
    public address: string;

    constructor(name: string) {
        this.name = name;  // Required field
    }

    public setAge(age: number): this {
        this.age = age;
        return this;
    }

    public setEmail(email: string): this {
        this.email = email;
        return this;
    }

    public setAddress(address: string): this {
        this.address = address;
        return this;
    }

    public build(): User {
        return new User(this);
    }
}

// Step 3: Using the builder pattern
const user = new UserBuilder('John Doe')  // Required name
    .setAge(30);

console.log("user ", user);  //  UserBuilder: { "name": "John Doe", "age": 30 } 

user.setEmail('john.doe@example.com') 
    .setAddress('123 Main St')           
    .build();                        
console.log(user);      // UserBuilder: { "name": "John Doe", "age": 30, "email": "john.doe@example.com", "address": "123 Main St"} 


---------------------------------------------------------------------------------------------------------------------------

Singleton Pattern -

class Singleton {
  private static instance: Singleton;

  // Make the constructor private to prevent direct instantiation
  private constructor() {
    // Your initialization code here
    this.data = "Singleton Data";
  }

  public data: string;

  // Provide a global point of access to the instance
  public static getInstance(): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }

  // Example method
  public getData(): string {
    return this.data;
  }
}

// Usage
const singleton1 = Singleton.getInstance();
const singleton2 = Singleton.getInstance();

console.log(singleton1 === singleton2); // true
console.log(singleton1.getData()); // Singleton Data

---------------------------------------------------------------------------------------------------------------------------

Facade Pattern -

* The Facade Pattern provides a simplified interface to a complex subsystem, making it easier to use. It hides the complexities of the system and provides a simple interface to the client. This pattern is particularly useful when you have a complex system with multiple subsystems and you want to provide a simpler API to the client.

// Subclasses
class TV {
  on() {
    console.log("TV is on");
  }

  off() {
    console.log("TV is off");
  }

  setInputChannel() {
    console.log("TV channel is set");
  }
}

class SoundSystem {
  on() {
    console.log("Sound system is on");
  }

  off() {
    console.log("Sound system is off");
  }

  setVolume(volume: number) {
    console.log(`Sound system volume set to ${volume}`);
  }
}

class DVDPlayer {
  on() {
    console.log("DVD Player is on");
  }

  off() {
    console.log("DVD Player is off");
  }

  play(movie: string) {
    console.log(`Playing movie: ${movie}`);
  }

  stop() {
    console.log("Stopping movie");
  }
}

class Lights {
  dim() {
    console.log("Lights are dimmed");
  }

  on() {
    console.log("Lights are on");
  }
}


// HomeTheaterFacade
class HomeTheaterFacade {
  private tv: TV;
  private soundSystem: SoundSystem;
  private dvdPlayer: DVDPlayer;
  private lights: Lights;

  constructor(tv: TV, soundSystem: SoundSystem, dvdPlayer: DVDPlayer, lights: Lights) {
    this.tv = tv;
    this.soundSystem = soundSystem;
    this.dvdPlayer = dvdPlayer;
    this.lights = lights;
  }

  watchMovie(movie: string) {
    console.log("Get ready to watch a movie...");
    this.lights.dim();
    this.tv.on();
    this.soundSystem.on();
    this.soundSystem.setVolume(5);
    this.dvdPlayer.on();
    this.dvdPlayer.play(movie);
  }

  endMovie() {
    console.log("Shutting movie theater down...");
    this.dvdPlayer.stop();
    this.dvdPlayer.off();
    this.soundSystem.off();
    this.tv.off();
    this.lights.on();
  }
}


// use of facade class
// Creating instances of subsystems
const tv = new TV();
const soundSystem = new SoundSystem();
const dvdPlayer = new DVDPlayer();
const lights = new Lights();

// Creating the facade
const homeTheater = new HomeTheaterFacade(tv, soundSystem, dvdPlayer, lights);

// Using the facade to watch a movie
homeTheater.watchMovie("Inception");

// Using the facade to end the movie
homeTheater.endMovie();

---------------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------------
Prototyal Pattern

* The Prototypal Pattern, also known as Prototype Pattern, is a creational design pattern used to create new objects by copying an existing object, known as the prototype. This pattern is particularly useful when the creation of an object is costly or complex. Instead of creating new instances from scratch, you clone the prototype. JavaScript's prototypal inheritance makes this pattern easy to implement

// Prototype object
const carPrototype = {
  init(make, model) {
    this.make = make;
    this.model = model;
  },
  getDetails() {
    return `${this.make} ${this.model}`;
  }
};

// Creating a new car instance by cloning the prototype
const car1 = Object.create(carPrototype);
car1.init('Toyota', 'Corolla');
console.log(car1.getDetails()); // Output: Toyota Corolla

const car2 = Object.create(carPrototype);
car2.init('Honda', 'Civic');
console.log(car2.getDetails()); // Output: Honda Civic

---------------------------------------------------------------------------------------------------------------------------
