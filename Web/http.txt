
HTTP -

---------------------------------------------------------------
Resources and URIs -
1) Identifying resources on the Web -
      * The target of an HTTP request is called a "resource", whose nature isn't defined further; it can be a document, a photo, or anything else. Each resource is identified by a Uniform Resource Identifier (URI) used throughout HTTP for identifying resources.

* URLs and URNs
    URLs - The most common form of URI is the Uniform Resource Locator (URL), which is known as the web address.
    * A URL is composed of different parts, some mandatory and others optional. A more complex example might look like this:
      http://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument

    * URNs - A Uniform Resource Name (URN) is a URI that identifies a resource by name in a particular namespace.

* Syntax of Uniform Resource Identifiers (URIs)

  * Scheme or protocol - http:// is the protocol. It indicates which protocol the browser must use. Usually it is the HTTP protocol or its secured version, HTTPS. The Web requires one of these two, but browsers also know how to handle other protocols such as mailto: (to open a mail client) or ftp: to handle a file transfer, so don't be surprised if you see such protocols. Common schemes are:
        Scheme	            Description
        data	              Data URLs
        file	              Host-specific file names
        ftp	                File Transfer Protocol
        http/https	        Hyper text transfer protocol (Secure)
        javascript	        URL-embedded JavaScript code
        mailto	            Electronic mail address
        ssh	                Secure shell
        tel	                telephone
        urn	                Uniform Resource Names
        view-source	        Source code of the resource
        ws/wss	            WebSocket connections (Secure)

  * Authority - www.example.com is the domain name or authority that governs the namespace. It indicates which Web server is being requested. Alternatively, it is possible to directly use an IP address, but because it is less convenient, it is not often used on the Web.

  * Port - :80 is the port in this instance. It indicates the technical "gate" used to access the resources on the web server. It is usually omitted if the web server uses the standard ports of the HTTP protocol (80 for HTTP and 443 for HTTPS) to grant access to its resources. Otherwise, it is mandatory.

  * Path - /path/to/myfile.html is the path to the resource on the Web server. In the early days of the Web, a path like this represented a physical file location on the Web server. Nowadays, it is mostly an abstraction handled by Web servers without any physical reality.

  * Query - ?key1=value1&key2=value2 are extra parameters provided to the Web server. Those parameters are a list of key/value pairs separated with the & symbol. The Web server can use those parameters to do extra stuff before returning the resource to the user. Each Web server has its own rules regarding parameters, and the only reliable way to know how a specific Web server is handling parameters is by asking the Web server owner.

  * Fragment -


* Usage notes
        * When using URLs in HTML content, you should generally only use a few of these URL schemes. When referring to subresources — that is, files that are being loaded as part of a larger document — you should only use the HTTP and HTTPS schemes. Increasingly, browsers are removing support for using FTP to load subresources, for security reasons.
        * FTP is still acceptable at the top level (such as typed directly into the browser's URL bar, or the target of a link), although some browsers may delegate loading FTP content to another application
        * 
                        https://developer.mozilla.org/en-US/docs/Learn
                        tel:+1-816-555-1212
                        git@github.com:mdn/browser-compat-data.git
                        ftp://example.org/resource.txt
                        urn:isbn:9780141036144
                        mailto:help@supercyberhelpdesk.info


2) Data URLs -
     * Data URLs, URLs prefixed with the data: scheme, allow content creators to embed small files inline in documents. They were formerly known as "data URIs" until that name was retired by the WHATWG.
     * Syntax -
                    Data URLs are composed of four parts: a prefix (data:), a MIME type indicating the type of data, an optional base64 token if non-textual, and the data itself:
                                   data:[<mediatype>][;base64],<data>
     * The mediatype is a MIME type string, such as 'image/jpeg' for a JPEG image file. If omitted, defaults to text/plain;charset=US-ASCII
     * If the data contains characters defined in RFC 3986 as reserved characters, or contains space characters, newline characters, or other non-printing characters, those characters must be percent-encoded.
     * A few examples:
               data:,Hello%2C%20World%21
               The text/plain data Hello, World!. Note how the comma is percent-encoded as %2C, and the space character as %20.
               
               data:text/plain;base64,SGVsbG8sIFdvcmxkIQ==
               base64-encoded version of the above
               
               data:text/html,%3Ch1%3EHello%2C%20World%21%3C%2Fh1%3E
               An HTML document with <h1>Hello, World!</h1>
               
               data:text/html,%3Cscript%3Ealert%28%27hi%27%29%3B%3C%2Fscript%3E
               An HTML document with <script>alert('hi');</script> that executes a JavaScript alert. Note that the closing script tag is required.

3) Introduction to MIME types -
4) Common MIME types -

5) Choosing between www and non-www URLs -
     * What are domain names?
          * In an HTTP URL, the first substring that follows the initial http:// or https:// is called the domain name. This domain name is hosted on a server where the document resides.
          * A server isn't necessarily a physical machine: several servers can reside on the same physical machine. Or, one server can be handled by several machines, cooperating to produce the answer or balancing the load of the requests between them. The key point is that semantically one domain name represents one single server.

     * So, do I have to choose one or the other for my website?
          * Yes, you need to choose one and stick with it. The choice of which one to have as your canonical location is yours, but if you choose one, stick with it. It will make your website appear more consistent to your users and to search engines. This includes always linking to the chosen domain (which shouldn't be hard if you're using relative URLs in your website) and always sharing links (by email/social networks, etc.) to the same domain.

          * No, you can have two. What is important is that you are coherent and consistent with which one is the official domain. This official domain is called the canonical name. All your absolute links should use it. But even so, you can still have the other domain working: HTTP allows two techniques so that it is clear for your users, or search engines, which domain is the canonical one, while still allowing the non-canonical domain to work and provide the expected pages.

     * Techniques for canonical URLs
          * Using HTTP 301 redirects
               In this case, you need to configure the server receiving the HTTP requests (which is most likely the same for 'www' and 'non-www' URLs) to respond with an adequate HTTP 301 response to any request to the non-canonical domain. This will redirect the browser trying to access the non-canonical URLs to their canonical equivalent. For example, if you've chosen to use 'non-www' URLs as the canonical type, you should redirect all 'www' URLs to their equivalent URL without the 'www'.
               * Example:          
                    A server receives a request for http://www.example.org/whaddup (when the canonical domain is example.org).
                    The server answers with a code 301 with the Location header Location: http://example.org/whaddup.
                    The client issues a request to the location under the canonical domain: http://example.org/whaddup.

          * Using <link rel="canonical"> - 
               * It is possible to add a special HTML <link> element to a page to indicate what the canonical address of a page is. This has no impact on the human reader of the page, but tells search engine crawlers where the page actually lives. This way, search engines don't index the same page several times, potentially leading to it being considered as duplicate content or spam, and even removing or lowering your page from the search engine result pages.
               * When adding such a tag, you serve the same content for both domains, telling search engines which URL is canonical. In the previous example, http://www.example.org/whaddup would serve the same content as http://example.org/whaddup, but with an additional <link> element in the head:
                         <link href="http://example.org/whaddup" rel="canonical" />

     * Make your page work for both - With these techniques, you can configure your server to respond correctly for both, the www-prefixed and the non-www-prefixed domains. It is good advice to do this since you can't predict which URL users will type in their browser's URL bar. It is a matter of choosing which type you want to use as your canonical location, then redirecting the other type to it.


---------------------------------------------------------------
HTTP Guide -

1) An overview of HTTP -
     * HTTP is a protocol for fetching resources such as HTML documents. It is the foundation of any data exchange on the Web and it is a client-server protocol, which means requests are initiated by the recipient, usually the Web browser. A complete document is typically constructed from resources such as text content, layout instructions, images, videos, scripts, and more.

     * Clients and servers communicate by exchanging individual messages (as opposed to a stream of data). The messages sent by the client are called requests and the messages sent by the server as an answer are called responses.
     * Designed in the early 1990s, HTTP is an extensible protocol which has evolved over time. It is an application layer protocol that is sent over TCP, or over a TLS-encrypted TCP connection, though any reliable transport protocol could theoretically be used. Due to its extensibility, it is used to not only fetch hypertext documents, but also images and videos or to post content to servers, like with HTML form results. HTTP can also be used to fetch parts of documents to update Web pages on demand.

     * Components of HTTP-based systems -
          * HTTP is a client-server protocol: requests are sent by one entity, the user-agent (or a proxy on behalf of it). Most of the time the user-agent is a Web browser, but it can be anything, for example, a robot that crawls the Web to populate and maintain a search engine index.
          * Each individual request is sent to a server, which handles it and provides an answer called the response. Between the client and the server there are numerous entities, collectively called proxies, which perform different operations and act as gateways or caches.
          * In reality, there are more computers between a browser and the server handling the request: there are routers, modems, and more. Thanks to the layered design of the Web, these are hidden in the network and transport layers. HTTP is on top, at the application layer. Although important for diagnosing network problems, the underlying layers are mostly irrelevant to the description of HTTP.

     * Proxies -
          * Between the Web browser and the server, numerous computers and machines relay the HTTP messages. Due to the layered structure of the Web stack, most of these operate at the transport, network or physical levels, becoming transparent at the HTTP layer and potentially having a significant impact on performance. Those operating at the application layers are generally called proxies. These can be transparent, forwarding on the requests they receive without altering them in any way, or non-transparent, in which case they will change the request in some way before passing it along to the server. Proxies may perform numerous functions:
               caching (the cache can be public or private, like the browser cache)
               filtering (like an antivirus scan or parental controls)
               load balancing (to allow multiple servers to serve different requests)
               authentication (to control access to different resources)
               logging (allowing the storage of historical information)


     * Basic aspects of HTTP
          * HTTP is simple - HTTP is generally designed to be simple and human-readable, even with the added complexity introduced in HTTP/2 by encapsulating HTTP messages into frames. HTTP messages can be read and understood by humans, providing easier testing for developers, and reduced complexity for newcomers.
          * HTTP is extensible - Introduced in HTTP/1.0, HTTP headers make this protocol easy to extend and experiment with. New functionality can even be introduced by a simple agreement between a client and a server about a new header's semantics.
          * HTTP is stateless, but not sessionless - HTTP is stateless: there is no link between two requests being successively carried out on the same connection. This immediately has the prospect of being problematic for users attempting to interact with certain pages coherently, for example, using e-commerce shopping baskets. But while the core of HTTP itself is stateless, HTTP cookies allow the use of stateful sessions. Using header extensibility, HTTP Cookies are added to the workflow, allowing session creation on each HTTP request to share the same context, or the same state.
          * HTTP and connections - 
                    * A connection is controlled at the transport layer, and therefore fundamentally out of scope for HTTP. HTTP doesn't require the underlying transport protocol to be connection-based; it only requires it to be reliable, or not lose messages (at minimum, presenting an error in such cases). Among the two most common transport protocols on the Internet, TCP is reliable and UDP isn't. HTTP therefore relies on the TCP standard, which is connection-based.
                    * Before a client and server can exchange an HTTP request/response pair, they must establish a TCP connection, a process which requires several round-trips. The default behavior of HTTP/1.0 is to open a separate TCP connection for each HTTP request/response pair. This is less efficient than sharing a single TCP connection when multiple requests are sent in close succession.
                    * In order to mitigate this flaw, HTTP/1.1 introduced pipelining (which proved difficult to implement) and persistent connections: the underlying TCP connection can be partially controlled using the Connection header. HTTP/2 went a step further by multiplexing messages over a single connection, helping keep the connection warm and more efficient.
                    * Experiments are in progress to design a better transport protocol more suited to HTTP. For example, Google is experimenting with QUIC which builds on UDP to provide a more reliable and efficient transport protocol.


     * What can be controlled by HTTP -
          * This extensible nature of HTTP has, over time, allowed for more control and functionality of the Web. Cache and authentication methods were functions handled early in HTTP history. The ability to relax the origin constraint, by contrast, was only added in the 2010s.
          * Here is a list of common features controllable with HTTP:
                    * Caching: How documents are cached can be controlled by HTTP. The server can instruct proxies and clients about what to cache and for how long. The client can instruct intermediate cache proxies to ignore the stored document.
                    * Relaxing the origin constraint: To prevent snooping and other privacy invasions, Web browsers enforce strict separation between websites. Only pages from the same origin can access all the information of a Web page. Though such a constraint is a burden to the server, HTTP headers can relax this strict separation on the server side, allowing a document to become a patchwork of information sourced from different domains; there could even be security-related reasons to do so.
                    * Authentication: Some pages may be protected so that only specific users can access them. Basic authentication may be provided by HTTP, either using the WWW-Authenticate and similar headers, or by setting a specific session using HTTP cookies.
                    * Proxy and tunneling: Servers or clients are often located on intranets and hide their true IP address from other computers. HTTP requests then go through proxies to cross this network barrier. Not all proxies are HTTP proxies. The SOCKS protocol, for example, operates at a lower level. Other protocols, like ftp, can be handled by these proxies.
                    * Sessions: Using HTTP cookies allows you to link requests with the state of the server. This creates sessions, despite basic HTTP being a state-less protocol. This is useful not only for e-commerce shopping baskets, but also for any site allowing user configuration of the output.


     * HTTP flow -
          * When a client wants to communicate with a server, either the final server or an intermediate proxy, it performs the following steps:
               * Open a TCP connection: The TCP connection is used to send a request, or several, and receive an answer. The client may open a new connection, reuse an existing connection, or open several TCP connections to the servers.
               * Send an HTTP message: HTTP messages (before HTTP/2) are human-readable. With HTTP/2, these simple messages are encapsulated in frames, making them impossible to read directly, but the principle remains the same. For example:
               http - 
                    GET / HTTP/1.1
                    Host: developer.mozilla.org
                    Accept-Language: fr
               
               Read the response sent by the server, such as:
               http
                         HTTP/1.1 200 OK
                         Date: Sat, 09 Oct 2010 14:28:02 GMT
                         Server: Apache
                         Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
                         ETag: "51142bc1-7449-479b075b2891b"
                         Accept-Ranges: bytes
                         Content-Length: 29769
                         Content-Type: text/html     
                         <!DOCTYPE html>… (here come the 29769 bytes of the requested web page)
               * Close or reuse the connection for further requests.

               * If HTTP pipelining is activated, several requests can be sent without waiting for the first response to be fully received. HTTP pipelining has proven difficult to implement in existing networks, where old pieces of software coexist with modern versions. HTTP pipelining has been superseded in HTTP/2 with more robust multiplexing requests within a frame.

     * HTTP Messages
          HTTP messages, as defined in HTTP/1.1 and earlier, are human-readable. In HTTP/2, these messages are embedded into a binary structure, a frame, allowing optimizations like compression of headers and multiplexing. Even if only part of the original HTTP message is sent in this version of HTTP, the semantics of each message is unchanged and the client reconstitutes (virtually) the original HTTP/1.1 request. It is therefore useful to comprehend HTTP/2 messages in the HTTP/1.1 format.
          
          There are two types of HTTP messages, requests and responses, each with its own format.
               * Request - 
                              GET / HTTP/1.1
                              Host: developer.mozilla.org
                              Accept-Language: fr
               * Requests consist of the following elements:
                    * An HTTP method, usually a verb like GET, POST, or a noun like OPTIONS or HEAD that defines the operation the client wants to perform. Typically, a client wants to fetch a resource (using GET) or post the value of an HTML form (using POST), though more operations may be needed in other cases.
                    * The path of the resource to fetch; the URL of the resource stripped from elements that are obvious from the context, for example without the protocol (http://), the domain (here, developer.mozilla.org), or the TCP port (here, 80).
                    * The version of the HTTP protocol.
                    * Optional headers that convey additional information for the servers.
                    * A body, for some methods like POST, similar to those in responses, which contain the resource sent.

               * Response - 
                    HTTP/1.1 200 OK
                    Date: Sat, 09 Oct 2010 14:28:02 GMT
                    Server: Apache
                    Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
                    ETag: "51142bc1-7449-479b075b2891b"
                    Accept-Ranges: bytes
                    Content-Length: 29769
                    Content-Type: text/html
                    
                    <!DOCTYPE html>… (here come the 29769 bytes of the requested web page)

               * Responses consist of the following elements:
                         The version of the HTTP protocol they follow.
                         A status code, indicating if the request was successful or not, and why.
                         A status message, a non-authoritative short description of the status code.
                         HTTP headers, like those for requests.
                         Optionally, a body containing the fetched resource.

2) Evolution of HTTP -

3) HTTP Messages -

4) A typical HTTP session -

5) connection management in HTTP/1.x

6) Protocol upgrade mechanism

---------------------------------------------------------------
HTTP security
Content Security Policy (CSP)
HTTP Strict Transport Security (HSTS)
X-Content-Type-Options
X-Frame-Options
X-XSS-Protection
Practical security implementation guides
HTTP Observatory

---------------------------------------------------------------
A) HTTP access control (CORS) -
     * CORS is designed to prevent unauthorized websites from accessing resources on a different domain without explicit permission from the resource owner.4
     * How CORS Works:
          1) Same-Origin Policy (SOP): 
               * By default, web browsers follow the Same-Origin Policy, which restricts web pages from making requests to a different domain than the one that served the web page. This policy is crucial for security but can be restrictive when legitimate cross-origin requests are needed.
          2) Preflight Requests:
               * For certain types of HTTP requests, particularly those that are not considered "simple" (like PUT or DELETE requests), the browser sends an OPTIONS request to the server (called a preflight request) before the actual request. This preflight request checks whether the server allows the cross-origin request.
               * The server must respond with the appropriate CORS headers (like Access-Control-Allow-Origin) to permit the actual request.
          3) CORS Headers:
               Access-Control-Allow-Origin: Specifies which origins are allowed to access the resource. This could be a specific domain, * (allow all domains), or the origin that made the request.
               Access-Control-Allow-Methods: Indicates the HTTP methods (GET, POST, PUT, DELETE, etc.) that are allowed when accessing the resource.
               Access-Control-Allow-Headers: Specifies which HTTP headers can be used when making the actual request.
               Access-Control-Allow-Credentials: If true, the browser includes credentials (like cookies or HTTP authentication) with the requests.
               Access-Control-Max-Age: Indicates how long the results of a preflight request can be cached.
          Example:
               Suppose you have a frontend application served from https://frontend.example.com that needs to make an API request to https://api.example.com. If https://api.example.com has CORS configured, it might include the following headers in its response:
                    Access-Control-Allow-Origin: https://frontend.example.com
                    Access-Control-Allow-Methods: GET, POST, PUT, DELETE
                    Access-Control-Allow-Headers: Content-Type

     * CORS Errors:
          If a request is blocked due to CORS, the browser will typically show a CORS error in the console, indicating that the server did not respond with the appropriate headers.

     * Practical Use:
          Developers: Need to configure their servers to include the appropriate CORS headers if they want to allow cross-origin requests.
          APIs: Public APIs often need to implement CORS to allow third-party applications to access them.
          Security: Misconfiguring CORS can lead to security vulnerabilities, like exposing sensitive data to unauthorized domains.
          Understanding and correctly implementing CORS is essential for web developers who work with APIs and need to allow cross-domain communication in a secure manner.


B) HTTP authentication -
     HTTP authentication is a method used to protect web resources by requiring the user to authenticate themselves before gaining access to those resources. When a user tries to access a protected resource, the server prompts for authentication credentials, typically a username and password. If the credentials are correct, the server grants access to the resource; otherwise, it denies the request.

     Types of HTTP Authentication
          * Basic Authentication:
               How it works: The client sends the username and password encoded in Base64 as part of the HTTP header in every request to the server. The header looks like this:
                       ex.  Authorization: Basic <Base64 encoded credentials>
               Security Concerns:
                    * The credentials are not encrypted, just Base64-encoded, which means they can be easily decoded if intercepted.
                    * It is recommended to use Basic Authentication only over HTTPS, where the connection is encrypted, to prevent credentials from being exposed.

          * Digest Authentication:     
               How it works:
                    The server sends a challenge (nonce) to the client.
                    The client responds with a hash (MD5 or other algorithms) of the username, password, and other details.
                    The server compares the hash to validate the credentials.
               Security Advantages:
                    Unlike Basic Authentication, the credentials are never sent in plain text. Instead, they are hashed, making it more secure.
                    However, this method is still considered less secure compared to modern authentication methods.
     
          * Bearer Authentication (Token-based):     
               How it works:
                    The client first authenticates with the server (usually via a login API) and receives a token.
                    The token is then sent in the Authorization header for subsequent requests:
                         ex.     Authorization: Bearer <token>
                    The server validates the token to grant or deny access.
               Common Use:
                    Often used in OAuth2 and JWT (JSON Web Token) based authentication systems.
                    Tokens can have expiration times and scopes, offering more control over access.
     
          * HOBA (HTTP Origin-Bound Authentication):     
               How it works:
                    Uses digital signatures to authenticate clients.
                    The client generates a public-private key pair and signs the authentication request with the private key.
               Security:
                    The server verifies the signature using the public key.
                    HOBA is designed to be resistant to phishing and man-in-the-middle attacks.

          * Mutual Authentication (Client Certificates):               
               How it works:
                    Both the client and the server authenticate each other using digital certificates.
                    The client presents a certificate to the server, which validates it against a trusted certificate authority (CA).
                    The server also presents its certificate to the client.
               Use Case:
                    Often used in environments requiring a high level of security, such as in financial services or sensitive government applications.
     
          * NTLM (Windows NT LAN Manager):     
               How it works:
                    NTLM is a challenge-response authentication protocol used mainly in Microsoft environments.
                    It provides a way to authenticate users over an insecure network without sending the actual password.
               Use Case:
                    Commonly used in Windows-based networks but has largely been replaced by more secure methods like Kerberos.
     
     * How HTTP Authentication Works in Practice
          * Client Request:
               The client (e.g., a web browser or a script) requests a protected resource on the server.
          * Server Challenge:     
               The server responds with a 401 Unauthorized status code and includes a WWW-Authenticate header indicating the type of authentication required (e.g., Basic or Digest).
          * Client Response:
               The client sends back the credentials in the Authorization header according to the specified authentication type.
          * Server Verification:     
               The server checks the provided credentials. If valid, the server returns the requested resource with a 200 OK status.
          * Subsequent Requests:     
               The client continues to include the Authorization header in subsequent requests to access protected resources without being re-challenged.
     
     * Security Considerations
          * HTTPS: Always use HTTPS to protect credentials during transmission, especially with Basic and Digest authentication.
          * Token Expiration: Implement token expiration and revocation mechanisms to limit the validity of tokens.
          * Multi-Factor Authentication (MFA): Combine HTTP authentication with MFA for added security.
          * Secure Storage: Store passwords securely on the server side using hashing algorithms with salts.
     
     HTTP authentication is a crucial part of web security, enabling the protection of resources by ensuring that only authorized users can access them. However, it's essential to choose the appropriate method and implement additional security measures to protect against various attacks.

     * Authentication in web applications -
          Token authentication
          Multi factor authentication
          Adaptive authentication
          Basic Auth
          OAuth 2
          Passwords
          Authentication
          Cookie-based authentication
          OpenID
          API key
          Biometric authentication
          Session management
          Web Authentication
          Common authentication methods
          Digest auth
          SAML
          Hash and salt passwords
          JWT authentication
          Security Assertion Markup Language
          SSO
          Biometrics
          Facial recognition
          Fingerprint
          NTLM auth


C) HTTP caching -
     * HTTP caching is a technique used to store copies of web resources (like HTML pages, images, or scripts) in order to reduce latency, decrease server load, and improve the overall user experience by delivering content more quickly. Caching is a fundamental aspect of optimizing web performance, and it can occur at various levels, including the browser, proxy servers, and content delivery networks (CDNs).
     * How HTTP Caching Works -
          When a client (like a web browser) makes an HTTP request for a resource, the server can include cache-related headers in the response that tell the client or intermediary caches how to store and reuse the resource in future requests.

     * Key HTTP Caching Headers
               1) Cache-Control:        
                   * Description: This is the primary HTTP header used for controlling caching behavior. It allows both the client and server to specify how and for how long a resource should be cached.
                   * Common Directives:
                         max-age=<seconds>: Specifies the maximum amount of time (in seconds) a resource is considered fresh.
                         no-cache: Forces revalidation with the server before using the cached resource.
                         no-store: Prevents caching altogether. The resource must be fetched from the server every time.
                         public: Indicates that the resource is cacheable by any cache, including browsers and intermediary caches.
                         private: Indicates that the resource is cacheable only by the browser (not by shared caches like proxies).
                         must-revalidate: Indicates that once a resource becomes stale, it must be revalidated with the server before being served.
               
               2) Expires:
                    * Description: An older header used to specify an absolute expiry date and time for the cached resource. After this time, the resource is considered stale and should be revalidated with the server.
                         Expires: Wed, 21 Oct 2023 07:28:00 GMT
                    * Note: Cache-Control is preferred over Expires because it is more flexible.

               3) ETag (Entity Tag):
                    * Description: A unique identifier (often a hash) assigned to a specific version of a resource. When the client has a cached resource, it can send the ETag to the server using the If-None-Match header to check if the resource has changed.
                    * How It Works:
                         If the server finds that the resource has not changed, it responds with a 304 Not Modified status, allowing the client to use the cached version.
                         If the resource has changed, the server sends the updated resource along with a new ETag.
                              ETag: "abc123"
               4) Last-Modified:
                    * Description: Indicates the date and time when the resource was last modified. The client can send this date back to the server using the If-Modified-Since header to check if the resource has been updated.
                    * How It Works:
                         If the resource has not been modified since the specified date, the server returns a 304 Not Modified status.
                         If it has been modified, the server returns the updated resource.
                              Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT

     * Types of Caches
               1) Browser Cache:        
                    Description: The cache built into web browsers that stores resources like HTML, CSS, JavaScript, and images locally on the user's device.
                    Usage: Reduces the need to re-download resources when navigating back to a previously visited page or reloading a page.
               2) Proxy Cache:               
                    Description: Caches located between the client and the server, often at the network level (e.g., ISP or enterprise proxy servers). These caches store responses for multiple users.
                    Usage: Reduces server load and speeds up access for multiple users by serving cached content from a closer or shared proxy.
               3) Content Delivery Network (CDN):               
                    Description: A network of distributed servers that cache content closer to users. CDNs are often used to improve the load time of static assets like images, stylesheets, and scripts.
                    Usage: Reduces latency by serving content from a server geographically closer to the user and offloading traffic from the origin server.


     * Benefits of HTTP Caching
               * Performance: Improves page load times by reducing the need to fetch resources from the server.
               * Bandwidth Savings: Reduces the amount of data transferred over the network by reusing cached resources.
               * Server Load Reduction: Decreases the number of requests and responses that the server must handle, freeing up resources for other tasks.
               * Improved User Experience: Users experience faster page loads and smoother interactions with the application.



D) HTTP compression -
          * HTTP compression is a technique used to reduce the size of data sent from the server to the client, typically to improve the performance of web applications by reducing the amount of bandwidth required and speeding up the loading time of web pages. The most common types of data that benefit from HTTP compression include HTML, CSS, JavaScript, and JSON responses.

          * How HTTP Compression Works
               When a client (such as a web browser) requests a resource, it can indicate its support for various compression methods through the Accept-Encoding HTTP header. The server, if capable of compressing the resource, responds by compressing the resource using one of the supported compression algorithms and indicates the compression method used in the Content-Encoding header.

          * Common HTTP Compression Methods
               * Gzip:
                    Description: Gzip is the most widely used compression method for HTTP. It uses the DEFLATE algorithm, which combines the LZ77 and Huffman coding algorithms.
                    Usage:
                         The client sends: Accept-Encoding: gzip.
                         The server responds with: Content-Encoding: gzip if it chooses to use gzip compression.
                    Pros: Provides a good balance between compression ratio and speed, widely supported across all browsers and servers.

               * Brotli:
                    Description: Brotli is a newer compression algorithm that typically achieves higher compression ratios than gzip, especially for text-based files. It was developed by Google and is supported by most modern browsers.
                    Usage:
                         The client sends: Accept-Encoding: br.
                         The server responds with: Content-Encoding: br if it chooses to use Brotli compression.
                    Pros: Offers better compression efficiency than gzip, particularly for web assets like HTML, CSS, and JavaScript.
                    Cons: Slightly slower compression speed compared to gzip, though the difference is usually negligible for most use cases.

               * Deflate:
                    Description: Deflate is a compression method that combines the LZ77 algorithm with Huffman coding. It is similar to gzip but without the additional header and footer metadata.
                    Usage:
                         The client sends: Accept-Encoding: deflate.
                         The server responds with: Content-Encoding: deflate if it chooses to use deflate compression.
                    Pros: Offers decent compression and speed, though it is less commonly used than gzip and Brotli.
                    Cons: Can lead to compatibility issues because of differences in implementation across servers and browsers.

               * Other Methods (Less Common):
                    Compress: An older algorithm that uses LZW (Lempel-Ziv-Welch) compression. It's largely obsolete and replaced by gzip.
                    Identity: Indicates that no compression is used. This is the default if no other encoding is specified.

     * HTTP Headers Involved in Compression
               * Accept-Encoding:
                    Description: Sent by the client to indicate which compression methods it supports.
                         Accept-Encoding: gzip, deflate, br
               * Content-Encoding:
                    Description: Sent by the server to indicate which compression method was used to compress the response.
                         Content-Encoding: gzip

     * Benefits of HTTP Compression
          Reduced Bandwidth Usage, Faster Page Load Times, Improved SEO, Reduced Server Load

     * Considerations and Best Practices
          * Choose the Right Compression Method:          
               Use Brotli for maximum compression efficiency, especially for text-based assets. Gzip is a good fallback for older browsers and systems.
          * Compress the Right Files:
               Compress text-based assets like HTML, CSS, JavaScript, and JSON. Do not compress already compressed files like JPEG, PNG, or MP4, as this can lead to larger files.
          * Use Conditional Requests:
               Use ETag and Last-Modified headers along with compression to ensure that only updated resources are transferred, further reducing bandwidth usage.
          * Test Compatibility:
               Ensure that the chosen compression methods are supported by the client base. While gzip is almost universally supported, Brotli is only supported by modern browsers.
          * Monitor Performance:
               Regularly monitor the performance impact of compression on both server and client-side to ensure that the benefits outweigh the costs in terms of CPU usage and latency.

     * Example of Compressed HTTP Response
               HTTP/1.1 200 OK
               Content-Type: text/html; charset=UTF-8
               Content-Encoding: gzip
               Vary: Accept-Encoding
               Content-Length: 512




HTTP conditional requests -
     * HTTP conditional requests are a mechanism that allows a client to make requests that include specific conditions. These conditions are used to determine whether a request should be fulfilled based on the state of the resource on the server. If the conditions are met, the server processes the request as usual. If the conditions are not met, the server may return a status code indicating that the request does not need to be fulfilled, such as 304 Not Modified.

     * Conditional requests are particularly useful for reducing unnecessary data transfer, improving efficiency, and ensuring that clients have the most up-to-date version of a resource.
     * Key HTTP Headers Used in Conditional Requests -
          * If-Modified-Since:
                    Description: The client uses this header to indicate that it only wants the resource if it has been modified since the specified date and time.
                    Usage:
                         The client sends: If-Modified-Since: <date-time>.
                         The server checks the resource’s last modification date. If it hasn't changed since the specified date, the server responds with 304 Not Modified.
                    If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT

          * If-Unmodified-Since:
                    Description: The client uses this header to indicate that it only wants the resource if it has not been modified since the specified date and time.
                    Usage:
                         The client sends: If-Unmodified-Since: <date-time>.
                         If the resource has been modified since the specified date, the server responds with 412 Precondition Failed.
                    If-Unmodified-Since: Wed, 21 Oct 2023 07:28:00 GMT

          * If-None-Match:
                    Description: The client uses this header to indicate that it only wants the resource if the provided ETag does not match the current ETag of the resource on the server.
                    Usage:
                         The client sends: If-None-Match: "<etag>".
                         The server compares the provided ETag with the current ETag. If they match, the server responds with 304 Not Modified.
                    If-None-Match: "abc123"

          * If-Match:
                    Description: The client uses this header to indicate that it only wants the resource if the provided ETag matches the current ETag of the resource on the server.
                    Usage:
                         The client sends: If-Match: "<etag>".
                         If the ETag does not match, the server responds with 412 Precondition Failed.
                    If-Match: "abc123"

          * If-Range:

     * Status Codes Used in Conditional Requests
               304 Not Modified:
               412 Precondition Failed:

     * Example of a Conditional Request and Response
          Client Request:
               GET /index.html HTTP/1.1
               Host: example.com
               If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT
               If-None-Match: "abc123"

          Server Response (if the resource has not changed):
               HTTP/1.1 304 Not Modified

     


HTTP content negotiation -
          

HTTP cookies -
          * HTTP cookies are small pieces of data that are stored on the client side (typically in a web browser) and are sent back to the server with each subsequent request. They are widely used for managing state, user sessions, preferences, and other data that needs to persist between requests. Cookies play a crucial role in web development, especially in the context of authentication, personalization, and tracking.
          * How HTTP Cookies Work
               * Setting a Cookie:                    
                    The server sends a Set-Cookie header in the HTTP response to instruct the client to store a cookie.
                    The cookie contains a name-value pair, and may also include optional attributes such as expiration time, domain, path, security settings, etc.
                    ex.  Set-Cookie: sessionId=abc123; Expires=Wed, 21 Oct 2023 07:28:00 GMT; HttpOnly; Secure

               * Sending a Cookie:
                    Once a cookie is set, the client automatically includes it in subsequent requests to the server within the specified domain and path.
                    The cookie is included in the Cookie header of the HTTP request.
                         GET /dashboard HTTP/1.1
                         Host: example.com
                         Cookie: sessionId=abc123

               * Cookie Attributes:
                    Name-Value Pair: The key-value data stored in the cookie.
                         Example: username=JohnDoe
                    Expires/Max-Age: Determines the lifespan of the cookie. Expires specifies the exact date and time the cookie expires, while Max-Age sets the lifetime of the cookie in seconds.
                         Example: Expires=Wed, 21 Oct 2023 07:28:00 GMT or Max-Age=3600 (1 hour).
                    Domain: Specifies the domain to which the cookie belongs. If not specified, it defaults to the domain of the document originating the cookie.
                         Example: Domain=example.com
                    Path: Defines the URL path for which the cookie is valid. If not specified, it defaults to the path of the document that set the cookie.
                         Example: Path=/account
                    Secure: Ensures the cookie is only sent over HTTPS connections.
                         Example: Secure
                    HttpOnly: Prevents the cookie from being accessed via JavaScript, helping to mitigate certain attacks like cross-site scripting (XSS).
                         Example: HttpOnly
                    SameSite: Restricts how cookies are sent with cross-site requests, helping to mitigate cross-site request forgery (CSRF) attacks.
                         Example: SameSite=Strict (other options: Lax, None)

               * Deleting a Cookie:
                    A cookie can be deleted by setting its Expires attribute to a past date, or by setting its Max-Age to 0.
                                   Set-Cookie: sessionId=abc123; Expires=Thu, 01 Jan 1970 00:00:00 GMT

     * Use Cases for HTTP Cookies -
               Session Management, Personalization, Tracking and Analytics, Shopping Carts
     * Security Considerations
               Secure Attribute - Always use the Secure attribute for cookies that store sensitive information, ensuring they are only sent over HTTPS connections.

               HttpOnly Attribute - Use the HttpOnly attribute to prevent cookies from being accessed via JavaScript, which can help protect against XSS attacks.
               SameSite Attribute -
                         Configure the SameSite attribute to control whether cookies are sent with cross-site requests, helping to prevent CSRF attacks.
                         SameSite=Strict is the most secure, but SameSite=Lax can be a good balance for most use cases.
               Third-Party Cookies:
                         Be cautious with third-party cookies, as they can pose privacy concerns and are increasingly being blocked or restricted by browsers.
               Encryption:     
                         Avoid storing sensitive information directly in cookies. Instead, store a token or session identifier and keep sensitive data on the server side.

     * Best Practices for Using HTTP Cookies
               Minimize Cookie Size:
                    Keep cookies as small as possible to reduce overhead in HTTP requests. Only store essential data in cookies.
               Set Appropriate Expiration:          
                    Use session cookies (Expires or Max-Age not set) for temporary data, and set explicit expiration times for persistent cookies.
               Use Separate Cookies for Separate Concerns:
                    Avoid combining unrelated data in a single cookie. Use separate cookies for different purposes (e.g., session management, preferences).
               Regularly Review and Clean Up Cookies:          
                    Periodically audit cookies to ensure they are necessary and being used correctly. Remove any stale or unused cookies.
               Comply with Privacy Regulations:         
                    Ensure cookie usage complies with privacy laws like the GDPR, which require obtaining user consent before setting cookies, especially for tracking and analytics.




HTTP range requests
HTTP redirects
HTTP specifications
Permissions Policy


------------------------------------------------------
HTTP Headers -
1) Accept - 
     * The Accept request HTTP header indicates which content types, expressed as MIME types, the client is able to understand. 
     * Content types that are acceptable for the response
     Accept: text/html, Accept: text/plain
2) Accept-CH -
     * The Accept-CH header may be set by a server to specify which client hints headers a client should include in subsequent requests.
          Accept-CH: Viewport-Width, Width

3) Accept-Charset -
     * The Accept-Charset request HTTP header was a header that advertised a client's supported character encodings. It is no longer widely used.
     * Character sets that are acceptable

4) Accept-Encoding
     * The Accept-Encoding request HTTP header indicates the content encoding (usually a compression algorithm) that the client can understand. 
     Accept-Encoding: gzip, deflate

5) Accept-Language
     * The Accept-Language request HTTP header indicates the natural language and locale that the client prefers.

6) Cache-Control
     * Used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain
     

https://kapeli.com/cheat_sheets/HTTP_Header_Fields.docset/Contents/Resources/Documents/index


------------------------------------------------------
Forbidden header name
A forbidden header name is the name of any HTTP header that cannot be modified programmatically; specifically, an HTTP request header name (in contrast with a Forbidden response header name).

Modifying such headers is forbidden because the user agent retains full control over them. Names starting with Sec- are reserved for creating new headers safe from APIs that grant developers control over headers, such as fetch().

Forbidden header names start with Proxy- or Sec-, or are one of the following names:

Accept-Charset
Accept-Encoding
Access-Control-Request-Headers
Access-Control-Request-Method
Connection
Content-Length
Cookie
Date
DNT
Expect
Host
Keep-Alive
Origin
Permissions-Policy
Proxy-
Sec-
Referer
TE
Trailer
Transfer-Encoding
Upgrade
Via


     * Character sets that are acceptable
     
