maximillian video (youtube) =

* Why Testing - when we update any changes in code, does it affect our application by using Automated Testing.

* Why Test? (advantages) = get an error if you break code, save time, Think about possible issues and bugs, integrate into build workflow, break up complex dependancies, improves code

*Test are of 3 types = 
1) Fully Isloated (testing 1 function),
2) Unit Tests (testing a function that calls a function),
3) E2E test(Full Flow or part application test, feature)

* we need test runner, assertions library, Headless browser to test code.
* Test runner - execute tests, summarize results. e.g. mocha
* assertions library - Defining test logic, expected outcome to compare with conditions. eg. chai
* Jest is great replacement for mocha and chai.

------------------------------------------------------
Jest Coverage link - https://medium.com/steve-cruz/awesome-jest-tip-coverage-report-6f1e303ef07




Mock Functions -
  * Using a mock function -
      * when we mock function, we will get object within mock property of mock function. All mock functions have this special .mock property, which is where data about how the function has been called and what the function returned is kept. 
      ex. const mockCallback = jest.fn(x => 42 + x);
           forEachs([0,1], mockCall);
          console.log(mockCall.mock);    
          /*-- {
            calls: [ [ 0 ], [ 1 ] ],
            instances: [ undefined, undefined ],
            invocationCallOrder: [ 1, 2 ],
            results: [ { type: 'return', value: 42 }, { type: 'return', value: 43 } ]
          } --*/
          expect(mockCall.mock.calls).toHaveLength(2);

    * Mock Return Values -
        const myMock = jest.fn();
        console.log(myMock());        // > undefined
        myMock.mockReturnValueOnce(10).mockReturnValueOnce('x').mockReturnValue(true);
        console.log(myMock(), myMock(), myMock(), myMock());        // > 10, 'x', true, true

    * Mocking Modules -
        * ex. import axios from 'axios';
              class Users {
                static all() {
                  return axios.get('/users.json').then(resp => resp.data);
                }
              }
              export default Users;
        * we can use the jest.mock(...) function to automatically mock the axios module.
          ex.     import axios from 'axios';
                  import Users from './users';
                  jest.mock('axios');
                  test('should fetch users', () => {
                    const users = [{name: 'Bob'}];
                    const resp = {data: users};
                    axios.get.mockResolvedValue(resp);
                    // or you could use the following depending on your use case:
                    // axios.get.mockImplementation(() => Promise.resolve(resp))
                    return Users.all().then(data => expect(data).toEqual(users));
                  });

    * Mocking Partials -
        ex. export const foo = 'foo';
            export const bar = () => 'bar';
            export default () => 'baz';

        //test.js
        import defaultExport, {bar, foo} from '../foo-bar-baz';        
        jest.mock('../foo-bar-baz', () => {
          const originalModule = jest.requireActual('../foo-bar-baz');        
          //Mock the default export and named export 'foo'
          return {
            __esModule: true,
            ...originalModule,
            default: jest.fn(() => 'mocked baz'),
            foo: 'mocked foo',
          };
        });
        
        test('should do a partial mock', () => {
          const defaultExportResult = defaultExport();
          expect(defaultExportResult).toBe('mocked baz');
          expect(defaultExport).toHaveBeenCalled();        
          expect(foo).toBe('mocked foo');
          expect(bar()).toBe('bar');
        });

    * Mock Implementations -
        * it's useful to go beyond the ability to specify return values and full-on replace the implementation of a mock function. This can be done with jest.fn or the mockImplementationOnce method on mock functions.
          const myMockFn = jest.fn(cb => cb(null, true));
          myMockFn((err, val) => console.log(val));          // > true
        * The mockImplementation method is useful when you need to define the default implementation of a mock function that is created from another module.
          //foo.js
          module.exports = function () {
            // some implementation;
          };

          //test.js
          jest.mock('../foo'); // this happens automatically with automocking
          const foo = require('../foo');
          
          // foo is a mock function
          foo.mockImplementation(() => 42);
          foo();
          // > 42
