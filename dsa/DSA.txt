
2) Introduction -
* Data structures - programm is a set of instructions which performs operations on data. so data is important part of programm. so when a program is dealing with the data, how it will organize the data in the main memory, that's what its data structure. The way you organize the data in the main memory during execution time of programm, that is DS.
* list of DS - 
  Physical DS (how data arrange in memory)=
      Arrays,
      Matrices,
      Linked list
  Logical DS (how data can be utilize) =
      Stack
      Queues
      Trees
      Graph
      Hashing
  Recurssion
  Sortings

* 3 level of programmer -
 beginner - know DS and how they work
 intermediate - how they work in detail and able to do analysis (based on time and space complexities)
 pro - can create own DS

* using c for course


3) Arrays Basics -
* learn c language
* features need to learn - Arrays, Structure, Pointers, Referrence, Parameter Passing, Classes, constructor, template
* array - is a collection of similar data elements. 
  ex. 
int main(){
  int A[5];
}
* when above programmer run,it runs in main memory, which consists code section, stack, and heap. Array will created in stack.
int B[4] = {2, 4, 6, 8, 9}        // declaration : initialization
int i;
for(i = 0; i < 5; i++){
  print(%d, B[i]);
}


4) Practice: Array Basics:
5) Structures:
* DS can be defined as collection of data members under one name
* structure is used for defining user defined data types apart from primitive types.
ex. 
// definition of structure
struct Rectangle {
  int length;    // 2 byte
  int breadth;    // 2 byte
}
// total 4 byte 
* size of structure is the total amount of memory consumed by all its members
* ex.
    main(){
      struct Rectangle r;    //declaration
      struct Rectangle r = {10, 5};    //declaration
      r.length = 15;
      r.breadth = 10;
      printf("Area of Rectangle is %d", r.length * r.breadth)
    }
* r created in stack of memory.

* complex no. -
 struct Complex {
    int read;
    int imginary;
}
// memory used - 4 bytes

2. Students
struct Student {
  int roll,
  char name[25];
  char dept[10];
  char address[50];
}
// memory used by  - 87 bytes
struct Student s1;
s1.roll = 20;
s1.name = "Sumeet"
s1.dept = "IT"
s1.address = "long address"

3. PLaying Cards
struct Card {
  int face;
  int shape;
  int color;
}
main(){
  struct Card c;
  c.face = 1;
  c.shape = 0;
  c.color = 0;
// struct Card c = { 1, 0, 0}    // for single card
// struct Card deck[52];         // for multiple cards - using array of structures // 312 cards
// struct Card deck[52] = { {1,0,0}, {2,0,0} }; 
// printf("%d", deck[0].face);
// printf("%d", deck[0].shape);

}


7) Pointers -
* Pointers is an address variable that is meant for storing address of data. It is used for indirect accessing the data.
* programm can't access heap directly. Programm need pointer to access data from heap. Major usage of pointer to accessing the resources which are outside the programmm.
* usage - accessing in heap, accessing resoures, parameter passing
* using malloc(), we can get memory in heap.

ex. 
// accessing within stack memory
int a = 10;    //variable
int *p;        // pointer variable
p = &a;        // initialization
printf("%d", a);        // 10
printf("%d", *p);      // 10  - this is dereferencing


// access heap memory
int *p;      // takes place in stack. Whichever variable declared, it will be inside stack.
p = (int *)malloc(5 * sizeof(int));      // will allocate 5 integers in heap memory
// p = new int[5];         // for c++, for creating heap memory



9) Referrence -
* nothing before variable name is normal variable, "*" before variable is pointer and "&" before variable is referenece.
int a = 10;
int &r = a;    //must be initialized too, while declaring
cout<<a;    //10
r++;        
cout<<r;    //11
cout<<a;    //11
* reference - another name to variable. useful in parameter passing.


11) Pointer to structure -
* ex.
//Example 1
struct Rectangle r = {10,5};
struct Rectangle *p = &r;

r.length = 15;
(*p).length = 20;
p -> length = 20;


// Example 2
P = (Struct Rectangle *) malloc(sizeof(struct Rectangle));
P -> length = 10;
P -> breadth = 10;


13) Functions -
* whole code in 1 function, called Monolithic programming
* whole code divides in multiple functions, called Modular or Procedural programming.
int add(int a, int c){
  return a + b
}


15) Parameter passing methods -
* pass by value or call by value - use when any changes are done to formal parameters will not reflect in actual parameters.
void swap(int x, int y){
  int temp;
  temp = x;
  x = y;
  y = temp;
}
int main(){
  int a = 10, b= 20;
  swap(a,b);
  printf(" %d %d", a,b);
}


* pass by address or call by address - use when any changes are done to formal parameters will reflect in actual parameters. using pointer
void swap(int *x, int *y){
  int temp;
  temp = *x;
  *x = *y;
  *y = temp;
}
int main(){
  int a = 10, b= 20;
  swap(&a, &b);
  printf(" %d %d", a,b);
}


* pass by referrence - will update formal and actual parameters are updated. here, swap is not separate function, it's actually part of main function.
void swap(int &x, int &y){
  int temp;
  temp = x;
  x = y;
  y = temp;
}
int main(){
  int a = 10, b= 20;
  swap(a,b);
  printf(" %d %d", a,b);
}

* more common, call by value and address.



17) Array as Parameter -
* Arrays cannont be passed by value at all, only by address.
* Ex.
void fun(int A[], int B){
  for(int i = 0; i < n; i++){
    printf(" %d ", A[i]);
  }
  A[0] = 25;      // array element modified
}
int main(){
  int A[5] = {2,3,4,5,6};
  fun(A, 5);
}

* array as parameter -
int [] fun(int n){
  int *p;
  p = (int *) malloc (n * sizeof(int));
  return p;
}
int main(){
int *A;
A = fun(5);


19) Structure as Parameter -

}
