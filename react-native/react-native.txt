Tools used in RN -
Fabric - New Renderer
hermes - JS engine
flipper - debugger
yoga - cross-platform layout engine
metro - bundler


IOS appstore pushing -
* signing with keychain - gives CSR certificate. will help to create developer certificate
* Now login within developer apple account
* lets create identifier

* create app using app store connect

* create a new certificate using certificate tab
* choose apple development >  select CSR certificate from desktop and upload > generate distribution certificate and download it

* create Provisioning profile using Provisioning profile tab
* select distribution of App Store > select App ID > select distribution certificate > Give name to provisioning profile > Download and install provisioning profile

* Now install proviosioning profile and certificate by double clicking


* Build application > archive with any OS device > archive app with validate app 
* apple developer account should sign with xcode
* while pushing to testflight, select pp and certificate

------------------------------------------------------------------------------------------------
GUIDES

A) The Basics
* Core Components and Native Components =

	1) Core Components and Native Components =
	* React Native is an open source framework for building Android and iOS applications using React and the app platform’s native capabilities.
	* using JavaScript to access your platform’s APIs as well as to describe the appearance and behavior of your UI using React components

	a) Views and mobile development
	* a view is the basic building block of UI
	* used to display text, images, or respond to user input

	b) Native Components
	* With React Native, you can invoke platform specific views with JavaScript using React components.
	* At runtime, React Native creates the corresponding Android and iOS views for those components.
	* We call these platform-backed components "Native Components".
	* React Native comes with a set of essential, ready-to-use Native Components you can use to start building your app today. These are "React Native's Core Components".
	* React Native also lets you build your own Native Components for Android and iOS to suit your app’s unique needs. We also have a thriving ecosystem of these community-contributed components.


	c) Core Components
	* React Native has many Core Components for everything from form controls to activity indicators.
	* REACT NATIVE UI COMPONENT - <View>, <Text>,  <Image>, <ScrollView>, <TextInput>
	* React Native uses the same API structure as React components
	* React Native Components contain-
		React components -> 
			React Native Components > 
				Community Components, Core Components, Own Native Component

	* 
	REACT NATIVE UI COMPONENT	ANDROID VIEW	IOS VIEW	WEB ANALOG		DESCRIPTION
	<View>				<ViewGroup>	<UIView>	A non-scrolling <div>	A container that supports layout with flexbox, style, some touch handling, and accessibility controls
	<Text>				<TextView>	<UITextView>	<p>			Displays, styles, and nests strings of text and even handles touch events
	<Image>				<ImageView>	<UIImageView>	<img>			Displays different types of images
	<ScrollView>			<ScrollView>	<UIScrollView>	<div>			A generic scrolling container that can contain multiple components and views
	<TextInput>			<EditText>	<UITextField>	<input type="text">	Allows the user to enter text


2) React Fundamentals =
* React Native runs on React, a popular open source library for building user interfaces with JavaScript.
* First Component =
	
	import React from "react";
	import { Text } from "react-native";

	const cat = () => {
		return <Text>Cat</Text>
	}
	export default cat;

* JSX = 
	* React and React Native use JSX, a syntax that lets you write elements inside JavaScript.
	* it is a syntax extension to JavaScript.
	* Fundamentally, JSX just provides syntactic sugar for the React.createElement(component, props, ...children) function. Babel compiles JSX down to React.createElement() calls.
	* It's been easier to write in JSX instead with "createElement".
	* we can put valid "JS expression" inside curly braces in JSX.
	* we can add attributes too in JSX using curly braces (for expression) and quotes (for string value).
	* we can add children within JSX.


* Custom Components =

* Developer notes =
	* On Android, you usually put your views inside LinearLayout, FrameLayout, RelativeLayout, etc. to define how the view’s children will be arranged on the screen.
	* Any component that renders other components is a parent component. And those other components are child components.

* Props =
	* Props is short for “properties”.
	* Image has many different props, including style, which accepts a JS object of design and layout related property-value pairs.
	* Props are Read-Only.
	* Props are arguments passed into React components.

* State =
	* state is like a component’s personal data storage.
	* State is useful for handling data that changes over time or that comes from user interaction.
	* As a general rule, use props to configure a component when it renders. Use state to keep track of any component data that you expect to change over time.
	* we use "this.setState" and "useState" hook to update state value.
	* ex. 
		// to register in class component
		state = {
			val: "sumeet"
		}
		console.log(this.state.val);	// to access in Class Component
		this.setState((prevState, props) => ({ val: !prevState.val }), () => console.log("callback function"));



		// to register in function component 	
		const [val, setVal] = useState(true);		// General Rule -  [val, setval] = useState(true)
		console.log(val);	// to access in Function Component
		setVal(!val);		// to update state




3) Handling Text Input -
	* TextInput is a Core Component that allows the user to enter text. It has an onChangeText prop that takes a function to be called every time the text changed, and an onSubmitEditing prop that takes a function to be called when the text is submitted.


4) Using a ScrollView -
* ScrollViews can be configured to allow paging through views using swiping gestures by using the pagingEnabled props. Swiping horizontally between views can also be implemented on Android using the ViewPager component.
* On iOS a ScrollView with a single item can be used to allow the user to zoom content. Set up the maximumZoomScale and minimumZoomScale props and your user will be able to use pinch and expand gestures to zoom in and out.
* The ScrollView works best to present a small number of things of a limited size. All the elements and views of a ScrollView are rendered, even if they are not currently shown on the screen. 
* If you have a long list of items which cannot fit on the screen, you should use a FlatList instead.


5) Using List Views -
* The FlatList component displays a scrolling list of changing, but similarly structured, data.
* FlatList works well for long lists of data, where the number of items might change over time.
* Unlike the more generic ScrollView, the FlatList only renders elements that are currently showing on the screen, not all the elements at once.
* The FlatList component requires two props: data and renderItem.
* If you want to render a set of data broken into logical sections, maybe with section headers, similar to UITableViews on iOS, then a SectionList is the way to go.


6) Troubleshooting -
* React Native uses 8081 port.
* if any other process running on 8081. then do the following -
	sudo lsof -i :8081	//  to find the id for the process that is listening on port 8081
	kill -9 <PID>		// run the following to terminate the process

* we can also use another port -
	npx react-native start --port=8088 		// use another port
	
	If running on device from Xcode, you can do this by updating occurrences of 8081 to your chosen port in the ios/__App_Name__.xcodeproj/project.pbxproj file.

* If you encounter an error such as npm WARN locking Error: EACCES while using the React Native CLI, try running the following:
	sudo chown -R $USER ~/.npm
	sudo chown -R $USER /usr/local/lib/node_modules


* Missing libraries for React -
	1) More detailed steps are here: Linking Libraries.
	Need More Time ...

* No transports available -
	1) React Native implements a polyfill for WebSockets.
	2) These polyfills are initialized as part of the react-native module that you include in your application through import React from 'react'. If you load another module that requires WebSockets, such as Firebase, be sure to load/require it after react-native.

* react-native init hangs -
	* If you run into issues where running npx react-native init hangs in your system, try running it again in verbose mode.
		npx react-native init --verbose

	* When you're debugging a process or need to know a little more about the error being thrown, you may want to use the verbose option to output more logs and information to nail down your issue. Run the following command in your root directory.
		npx react-native run-android --verbose


7) Platform Specific Code -
* React Native provides two ways to organize your code and separate it by platform -
	1) Using the Platform module.
	2) Using platform-specific file extensions.

* Platform module -
	1) React Native provides a module that detects the platform in which the app is running. You can use the detection logic to implement platform-specific code. Use this option when only small parts of a component are platform-specific.
	2) Platform.OS will be ios when running on iOS and android when running on Android.
	3) ex. Platform.OS === "ios"? true: false
	4) There is also a Platform.select method available, that given an object where keys can be one of 'ios' | 'android' | 'native' | 'default', returns the most fitting value for the platform you are currently running on. we can use this for css also.
	5) priority in following - 
		1) ios and android, 2) Native, 3) default
	6) ex.
		const styles = StyleSheet.create({
			container: {
				flex: 1,
				...Platform.select({
					android: { backgroundColor: "red" },
					ios: { backgroundColor: "red" },
					default: { backgroundColor: "red" }
				})
			}
		});
		

* Detecting the Android version - 
	1) On Android, the Platform module can also be used to detect the version of the Android Platform in which the app is running:
	console.log(Platform.Version);		//25

* Detecting the iOS version -
 On iOS, the Version is a result of -[UIDevice systemVersion], which is a string with the current version of the operating system. 

* Platform-specific extensions -
	1) When your platform-specific code is more complex, you should consider splitting the code out into separate files. React Native will detect when a file has a .ios. or .android. extension and load the relevant platform file when required from other components.
	2) For example, say you have the following files in your project:
		BigButton.ios.js
		BigButton.android.js
	3) You can then require the component as follows:
		import BigButton from './BigButton';
	4) React Native will automatically pick up the right file based on the running platform.


* Native-specific extensions (i.e. sharing code with NodeJS and Web) -
	1) You can also use the .native.js extension when a module needs to be shared between NodeJS/Web and React Native but it has no Android/iOS differences. This is especially useful for projects that have common code shared among React Native and ReactJS.
	2) For example, say you have the following files in your project:
		Container.js # picked up by Webpack, Rollup or any other Web bundler
		Container.native.js # picked up by the React Native bundler for both Android and iOS (Metro)
	3) You can still require it without the .native extension, as follows:
		import Container from './Container';


8) More Resources -
* IDEs - We recommend using the VS Code code editor and its handy React Native tools.
* Platforms to try - 
	1) EXPO
	2) Ignite is a starter kit CLI with several React Native boilerplates.

* Find, make, and share your own Native Components and TurboModules -
	1)  Visit React Native Directory to find what the community has been creating.



B) Enviornment Setup -
1) Setting up the development environment -

* If you are already familiar with mobile development, you may want to use React Native CLI. It requires Xcode or Android Studio to get started. If you already have one of these tools installed, you should be able to get up and running within a few minutes. If they are not installed, you should expect to spend about an hour installing and configuring them.

* Installing dependencies - 
	You will need Node, the React Native command line interface, a JDK, and Android Studio.

	While you can use any editor of your choice to develop your app, you will need to install Android Studio in order to set up the necessary tooling to build your React Native app for Android.

	Node - version 14 or newer
	Java Development Kit ( JDK ) - version 11 or newwer
	Android development environment - 
	
	1) Install Android Studio -
	Download and install Android Studio. While on Android Studio installation wizard, make sure the boxes next to all of the following items are checked:
		Android SDK
		Android SDK Platform
		Android Virtual Device
	Then, click "Next" to install all of these components.
	
	2) Install the Android SDK -
		Android Studio installs the latest Android SDK by default. Building a React Native app with native code, however, requires the Android 12 (S) SDK in particular. Additional Android SDKs can be installed through the SDK Manager in Android Studio.

		To do that, open Android Studio, click on "Configure" button and select "SDK Manager".

		The SDK Manager can also be found within the Android Studio "Preferences" dialog, under Appearance & Behavior → System Settings → Android SDK.

		Select the "SDK Platforms" tab from within the SDK Manager, then check the box next to "Show Package Details" in the bottom right corner. Look for and expand the Android 12 (S) entry, then make sure the following items are checked:

			Android SDK Platform 31
			Intel x86 Atom_64 System Image or Google APIs Intel x86 Atom System Image

		Next, select the "SDK Tools" tab and check the box next to "Show Package Details" here as well. Look for and expand the "Android SDK Build-Tools" entry, then make sure that 31.0.0 is selected.

		Finally, click "Apply" to download and install the Android SDK and related build tools.


	3) Configure the ANDROID_SDK_ROOT environment variable -
	The React Native tools require some environment variables to be set up in order to build apps with native code.

	Add the following lines to your $HOME/.bash_profile or $HOME/.bashrc (if you are using zsh then ~/.zprofile or ~/.zshrc) config file:
		export ANDROID_SDK_ROOT=$HOME/Library/Android/Sdk
		export PATH=$PATH:$ANDROID_SDK_ROOT/emulator
		export PATH=$PATH:$ANDROID_SDK_ROOT/platform-tools

	.bash_profile is specific to bash. If you're using another shell, you will need to edit the appropriate shell-specific config file.

	Type source $HOME/.bash_profile for bash or source $HOME/.zprofile to load the config into your current shell. Verify that ANDROID_SDK_ROOT has been set by running echo $ANDROID_SDK_ROOT and the appropriate directories have been added to your path by running echo $PATH.

	Please make sure you use the correct Android SDK path. You can find the actual location of the SDK in the Android Studio "Preferences" dialog, under Appearance & Behavior → System Settings → Android SDK.



* Watchman -
	1) Watchman is a tool by Facebook for watching changes in the filesystem. It is highly recommended you install it for better performance and increased compatibility in certain edge cases.

* React Native Command Line Interface -
	1) we recommend you access the current version at runtime using npx, which ships with Node.js. With npx react-native <command>.
	npx react-native init projectName

* Creating a new application -
	1) npx react-native init AwesomeProject
	2) npx react-native init AwesomeProject --version 0.68.2	// Using a specific version or template
	3) npx react-native init AwesomeTSProject --template react-native-template-typescript	// With Template
	
* Running your React Native application -
	1) Step 1: Start Metro - 
		npx react-native start 		//To start metro (JS bundler) which ships with react native.
	2) Note - If you're familiar with web development, Metro is a lot like webpack—for React Native apps.
	3) Step 2: Start your application -
		npx react-native run-android	//To start react native project in another terminal





2) Integration with Existing Apps -
	Take help from directly official website

3) Integration with an Android Fragment -
	Take help from directly official website

4) Building For TV Devices -
	Take help from directly official website

5) Out-of-Tree Platforms -
	Take help from directly official website



C) Workflow -
	1) Running On Device -
	* Running your app on Android devices -
		1) Enable Debugging over USB - To enable USB debugging on your device, you will first need to enable the "Developer options" menu by going to Settings → About phone → Software information and then tapping the Build number row at the bottom seven times. You can then go back to Settings → Developer options to enable "USB debugging".
	
		2) Plug in your device via USB -  plug in your device via USB to your development machine. Next, check the manufacturer code by using lsusb (on mac, you must first install lsusb).  This is an utility to easily list USB devices in Mac OS X, just like the lsusb command in Linux. 
	
		3) npx react-native run-android
	
	* Connecting to the development server -
		1) if our phone and laptop are on different network and we have to reach development server through laptop, we have 2 ways -
		2) using adb reverse - we need to use "adb revese".
			article link - https://blog.grio.com/2015/07/android-tip-adb-reverse.html
		3) using WiFi -
			Take help from directly official website
	
	
	2) Fast Refresh - 
	article link - https://aboutreact.com/fast-refresh-in-react-native/
		* Fast Refresh is a React Native feature that allows you to get near-instant feedback for changes in your React components.
	* Error Resilience -
		* fast refresh is error resilience.
	* Limitations -
		* Local state is not preserved for class components (only function components and Hooks preserve state).
		* The module you're editing might have other exports in addition to a React component.
		* Sometimes, a module would export the result of calling higher-order component like createNavigationContainer(MyScreen). If the returned component is a class, state will be reset.
	* Tips -
		* Fast Refresh preserves React local state in function components (and Hooks) by default.
		* Sometimes you might want to force the state to be reset, and a component to be remounted. To do this, you can add "// @refresh reset" anywhere in the file you're editing. This directive is local to the file, and instructs Fast Refresh to remount components defined in that file on every edit.
	* Fast Refresh and Hooks -
		* When possible, Fast Refresh attempts to preserve the state of your component between edits.
		* In particular, useState and useRef preserve their previous values as long as you don't change their arguments or the order of the Hook calls.
		* Hooks with dependencies—such as useEffect, useMemo, and useCallback—will always update during Fast Refresh. Their list of dependencies will be ignored while Fast Refresh is happening.
	
	3) Metro -
		* React Native uses Metro to build your JavaScript code and assets.
		* Configuring Metro -
			Configuration options for Metro can be customized in your project's metro.config.js file. This can export either:
				1) An object (recommended) that will be merged on top of Metro's internal config defaults.
				2) A function that will be called with Metro's internal config defaults and should return a final config object.
		* In React Native, your Metro config should extend either @react-native/metro-config or @expo/metro-config. These packages contain essential defaults necessary to build and run React Native apps.
		* Below is the default metro.config.js file in a React Native template project:
		 Code :-	
			const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');
			/**
			 * Metro configuration
			 * https://facebook.github.io/metro/docs/configuration
			 *
			 * @type {import('metro-config').MetroConfig}
			 */
			const config = {};
			module.exports = mergeConfig(getDefaultConfig(__dirname), config);
		* Advanced: Using a config function -
			* Exporting a config function is an opt-in to managing the final config yourself — Metro will not apply any internal defaults. This pattern can be useful when needing to read the base default config object from Metro or to set options dynamically.
			Code -
				const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');
				module.exports = function (baseConfig) {
				  const defaultConfig = mergeConfig(baseConfig, getDefaultConfig(__dirname));
				  const {resolver: {assetExts, sourceExts}} = defaultConfig;
				
				  return mergeConfig(
				    defaultConfig,
				    {
				      resolver: {
				        assetExts: assetExts.filter(ext => ext !== 'svg'),
				        sourceExts: [...sourceExts, 'svg'],
				      },
				    },
				  );
				};
		* Learn more about Metro
			Metro website
			Video: "Metro & React Native DevX" talk at App.js 2023
	
	
	4) Using Libraries -
		* Selecting a Package Manager -
			* React Native libraries are typically installed from the npm registry using a Node.js package manager such as npm CLI or Yarn Classic.
		* Installing a Library -
			npm install react-native-webview
		* Linking Native Code on iOS -
			* React Native uses CocoaPods to manage iOS project dependencies and most React Native libraries follow this same convention. If a library you are using does not, then please refer to their README for additional instruction. In most cases, the following instructions will apply.
			* Run pod install in our ios directory in order to link it to our native iOS project. A shortcut for doing this without switching to the ios directory is to run npx pod-install.
			* Once this is complete, re-build the app binary to start using your new library:-
				npm run ios
		* Linking Native Code on Android -
			* React Native uses Gradle to manage Android project dependencies. After you install a library with native dependencies, you will need to re-build the app binary to use your new library:
				npm run android
		* Finding Libraries
			* React Native Directory is a searchable database of libraries built specifically for React Native. This is the first place to look for a library for your React Native app.
			* After React Native Directory, the npm registry is the next best place if you can't find a library specifically for React Native on the directory
	
	
	5) Using TypeScript -
		* TypeScript is a language which extends JavaScript by adding type definitions. New React Native projects target TypeScript by default, but also support JavaScript and Flow.
		* read from official docs
		* Out of the box, TypeScript sources are transformed by Babel during bundling
	
	6) Upgrading to new versions -
		* read from official docs
		* https://react-native-community.github.io/upgrade-helper/
		* I have done all the changes but my app is still using an old version -
			These sort of errors are usually related to caching, it's recommended to install react-native-clean-project to clear all your project's cache and then you can run it again.
	
	
D) UI & Interaction -
	1) Style -
		* With React Native, you style your application using JavaScript. All of the core components accept a prop named style. The style names and values usually match how CSS works on the web, except names are written using camel casing, e.g. backgroundColor rather than background-color.
		* The style prop can be a plain old JavaScript object. You can also pass an array of styles - the last style in the array has precedence, so you can use this to inherit styles.
		* As a component grows in complexity, it is often cleaner to use StyleSheet.create to define several styles in one place. 

	2) Height and Width -
		* A component's height and width determine its size on the screen.
		* Fixed Dimensions -
			* The general way to set the dimensions of a component is by adding a fixed width and height to style. All dimensions in React Native are unitless, and represent density-independent pixels.
		* Flex Dimensions -
			* Use flex in a component's style to have the component expand and shrink dynamically based on available space. Normally you will use flex: 1, which tells a component to fill all available space, shared evenly amongst other components with the same parent. The larger the flex given, the higher the ratio of space a component will take compared to its siblings.
		* Percentage Dimensions -
			* If you want to fill a certain portion of the screen, but you don't want to use the flex layout, you can use percentage values in the component's style. Similar to flex dimensions, percentage dimensions require parent with a defined size.


	3) Layout with Flexbox -
		* read from official docs
		

	4) Images -
		* Static Image Resources -
			* The image name is resolved the same way JS modules are resolved. ex. <Image source={require('./my-icon.png')} />
			* You can use the @2x and @3x suffixes to provide images for different screen densities.
			* On Windows, you might need to restart the bundler if you add new images to your project.

			* Here are some benefits that you get:
				1) Same system on Android and iOS.
				2) Images live in the same folder as your JavaScript code. Components are self-contained.
				3) No global namespace, i.e. you don't have to worry about name collisions.
				4) Only the images that are actually used will be packaged into your app.
				5) Adding and changing images doesn't require app recompilation, you can refresh the simulator as you normally do.
				6) The bundler knows the image dimensions, no need to duplicate it in the code.
				7) Images can be distributed via npm packages.

		* Static Non-Image Resources -
			* The require syntax described above can be used to statically include audio, video or document files in your project as well. Most common file types are supported including .mp3, .wav, .mp4, .mov, .html and .pdf. See bundler defaults for the full list.
			* You can add support for other types by adding an assetExts resolver option in your Metro configuration.

		* Images From Hybrid App's Resources -
			* <Image  source={{uri: 'app_icon'}} style={{width: 40, height: 40}} /> for ios
			* <Image  source={{uri: 'asset:/app_icon.png'}} style={{width: 40, height: 40}} /> for android

		* Network Images - <Image source={{uri: 'https://reactjs.org/logo-og.png'}} style={{width: 400, height: 400}} />
		* Network Requests for Images -
					<Image
					  source={{
					    uri: 'https://reactjs.org/logo-og.png',
					    method: 'POST',
					    headers: {
					      Pragma: 'no-cache',
					    },
					    body: 'Your Body goes here',
					  }}
					  style={{width: 400, height: 400}}
					/>
		* URI Data Images - 
			// include at least width and height!
			<Image
			  style={{
			    width: 51,
			    height: 51,
			    resizeMode: 'contain',
			  }}
			  source={{
			    uri: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg==',
			  }}
			/>

		* Cache Control (iOS Only) -
			* In some cases you might only want to display an image if it is already in the local cache, i.e. a low resolution placeholder until a higher resolution is available. In other cases you do not care if the image is outdated and are willing to display an outdated image to save bandwidth. The cache source property gives you control over how the network layer interacts with the cache.
			* ... cache: 'only-if-cached',

		* remaining take from official site


	5) Color Reference -
		* Components in React Native are styled using JavaScript. Color properties usually match how CSS works on the web.
		* Color APIs - React Native has several color APIs designed to allow you to take full advantage of your platform's design and user preferences.
			* PlatformColor lets you reference the platform's color system.
			* DynamicColorIOS is iOS specific
		* remaining take from official site

	6) Handling Touches -
		* read from official docs

	7) Navigating Between Screens -
		* use react-navigation

	8) Animations

	9) Gesture Responder System -
		* read from official docs

	10) Networking -
		* read from official docs
		* Using Fetch - React Native provides the Fetch API for your networking needs.
		* WebSocket Support - React Native also supports WebSockets

	11) Security -
		* read from official docs
		* Storing Sensitive Info -
			* Tools like react-native-dotenv and react-native-config are great for adding environment-specific variables like API endpoints.
		* Async Storage - Async Storage is a community-maintained module for React Native that provides an asynchronous, unencrypted, key-value store.


3) Debugging -
* Accessing the In-App Developer Menu -
	1) You can access the developer menu by shaking your device or by selecting "Shake Gesture" inside the Hardware menu in the iOS Simulator.
	2) OR command "adb shell input keyevent 82" to open the dev menu (82 being the Menu key code)

* Enabling Fast Refresh - 
	1) Fast Refresh is a React Native feature that allows you to get near-instant feedback for changes in your React components.
	2) Fast Refresh is enabled by default, and you can toggle "Enable Fast Refresh" in the React Native developer menu. When enabled, most of your edits should be visible within a second or two.

* Enabling Keyboard Shortcuts -
	1) React Native supports a few keyboard shortcuts in the iOS Simulator. They are described below. To enable them on macOS, inside the Simulator app, open the I/O menu, select Keyboard, and make sure that "Connect Hardware Keyboard" is checked.

* LogBox -
	1) Errors and warnings in development builds are displayed in LogBox inside your app.

* Console Errors and Warnings -
	1) Console errors and warnings are displayed as on-screen notifications with a red or yellow badge, and the number of errors or warning in the console respectively.
	2) These notifications can be hidden using LogBox.ignoreAllLogs().
	3) ex.
		import { LogBox } from 'react-native';

		// Ignore log notification by message:
		LogBox.ignoreLogs(['Warning: ...']);

		// Ignore all log notifications:
		LogBox.ignoreAllLogs();

* Unhandled Errors -
	1) Unhandled JavaScript errors such as undefined is not a function will automatically open a full screen LogBox error with the source of the error.
* Syntax Errors -
	1) When syntax error occurs the full screen LogBox error will automatically open with the stack trace and location of the syntax error. This error is not dismissable because it represents invalid JavaScript execution that must be fixed before continuing with your app.

* Chrome Developer Tools -
	1) To debug the JavaScript code in Chrome, select "Debug JS Remotely" from the Developer Menu. This will open a new tab at http://localhost:8081/debugger-ui.
* Debugging using a custom JavaScript debugger -
	Take help from directly official website

* Safari Developer Tools -
	Take help from directly official website

* React Developer Tools -
	1) You can use the standalone version of React Developer Tools to debug the React component hierarchy.




------------------------------------------------------------------------------------------------
COMPONENTS

A) Core Components -

1) Core Components and APIs -
	1) React Native provides a number of built-in Core Components ready for you to use in your app. 
	2) lets categorize -
		Basic Components - View, Image, Text, TextInput, ScrollView, StyleSheet
		User Interface - Button, Switch
		List Views - FlatList, SectionList
		Android-specific - BackHandler, DrawerLayoutAndroid, PermissionAndroid, ToastAndroid
		iOS-specific - ActionSheetIOS
		Others - 
		ActivityIndicator, Alert, Animated, Dimensions, KeyboardAvoidingView, Linking, Modal, PixelRatio, RefreshControl, StatusBar

2) ActivityIndicator -
	1) Displays a circular loading indicator.
	2) Props -
		* inherits view props
		* animating - Whether to show the indicator (true) or hide it (false). DEFAULT = true
		* color - The foreground color of the spinner.  "null" or "#000"
		* hidesWhenStopped (IOS) - Whether the indicator should hide when not animating. DEFAULT = true
		* size - Size of the indicator. 'small'
	
3) Button -
	1) A basic button component that should render nicely on any platform. Supports a minimal level of customization.
	2) You can build your own button using TouchableOpacity or TouchableWithoutFeedback.
	3) ex. 
		<Button title="Press me" onPress={() => Alert.alert('Simple Button pressed')} />
	4) Props -
		* onPress (Required) - Handler to be called when the user taps the button.  
			TYPE: ({ nativeEvent: PressEvent })

		*  title (Required) - Text to display inside the button. On Android the given title will be converted to the uppercased form.
			TYPE - string

		* accessibilityLabel - Text to display for blindness accessibility features.
			TYPE - string			

		* accessibilityLanguage (IOS) - A value indicating which language should be used by the screen reader when the user interacts with the element. It should follow the BCP 47 specification. See the iOS accessibilityLanguage doc for more information.
			TYPE - string

		* accessibilityActions - Accessibility actions allow an assistive technology to programmatically invoke the actions of a component. The accessibilityActions property should contain a list of action objects. Each action object should contain the field name and label.
			TYPE - array    REQUIRED - NO

		* onAccessibilityAction - Invoked when the user performs the accessibility actions. The only argument to this function is an event containing the name of the action to perform.
			TYPE - function     REQUIRED - NO

		* color - Color of the text (iOS), or background color of the button (Android).
			TYPE - color 		DEFAULT - `'#2196F3'` (android)   '#007AFF' (ios)

		* disabled - If true, disable all interactions for this component.   TYPE- bool   DEFAULT - false
		* hasTVPreferredFocus - TV preferred focus. 		TYPE - bool 	DEFAULT - false
		* nextFocusDown - Designates the next view to receive focus when the user navigates down. See the Android documentation.
			TYPE - number

		* nextFocusForward - Designates the next view to receive focus when the user navigates forward. See the Android documentation.
			TYPE - number

		* nextFocusLeft - Designates the next view to receive focus when the user navigates left. See the Android documentation.
			TYPE - number

		* nextFocusRight - Designates the next view to receive focus when the user navigates right. See the Android documentation.
			TYPE - number

		* nextFocusUp - Designates the next view to receive focus when the user navigates up. See the Android documentation.
			TYPE - number		

		* testID - Used to locate this view in end-to-end tests.
			TYPE - string

		* touchSoundDisabled - If true, doesn't play system sound on touch.
			TYPE - boolean 		DEFAULT - false


4) Flatlist - 
	1) A performant interface for rendering basic, flat lists, supporting the most handy features:
		Fully cross-platform.
		Optional horizontal mode.
		Configurable viewability callbacks.
		Header support.
		Footer support.
		Separator support.
		Pull to Refresh.
		Scroll loading.
		ScrollToIndex support.
		Multiple column support.

	2) To render multiple columns, use the numColumns prop. Using this approach instead of a flexWrap layout can prevent conflicts with the item height logic.
	3) By passing extraData={selectedId} to FlatList we make sure FlatList itself will re-render when the state changes. Without setting this prop, FlatList would not know it needs to re-render any items because it is a PureComponent and the prop comparison will not show any changes.
	4) keyExtractor tells the list to use the ids for the react keys instead of the default key property.
	5) This is a convenience wrapper around <VirtualizedList>, and thus inherits its props (as well as those of <ScrollView>) that aren't explicitly listed here, along with the following caveats:
		* Internal state is not preserved when content scrolls out of the render window. Make sure all your data is captured in the item data or external stores like Flux, Redux, or Relay.
		* This is a PureComponent which means that it will not re-render if props remain shallow-equal. Make sure that everything your renderItem function depends on is passed as a prop (e.g. extraData) that is not === after updates, otherwise your UI may not update on changes. This includes the data prop and parent component state.
		* In order to constrain memory and enable smooth scrolling, content is rendered asynchronously offscreen. This means it's possible to scroll faster than the fill rate and momentarily see blank content.
		* By default, the list looks for a key prop on each item and uses that for the React key. Alternatively, you can provide a custom keyExtractor prop.
	6) Props -
		* ScrollView Props - Inherits ScrollView Props, unless it is nested in another FlatList of same orientation.

		* renderItem (Required) -
			* renderItem({ item, index, separators });		
			* Takes an item from data and renders it into the list.
			* Provides additional metadata like index if you need it, 
			* as well as a more generic separators.updateProps function which let you set whatever props you want to change the rendering of either the leading separator or trailing separator in case the more common highlight and unhighlight (which set the highlighted: boolean prop) are insufficient for your use case.
			 	TYPE  function

			*	item (Object): The item from data being rendered.
				index (number): The index corresponding to this item in the data array.
				separators (Object)
				highlight (Function)
				unhighlight (Function)
				updateProps (Function)
				select (enum('leading', 'trailing'))
				newProps (Object)

		* data - For simplicity, data is a plain array. If you want to use something else, like an immutable list, use the underlying VirtualizedList directly.
			TYPE  - array

		* ItemSeparatorComponent - 
			* Rendered in between each item, but not at the top or bottom.
			TYPE  -  component, function, element
		
		* ListEmptyComponent - 
			* Rendered when the list is empty. Can be a React Component (e.g. SomeComponent), or a React element (e.g. <SomeComponent />).
			TYPE - component, element

		* ListFooterComponent -
			Rendered at the bottom of all the items. Can be a React Component (e.g. SomeComponent), or a React element (e.g. <SomeComponent />).
			TYPE - component, element

		* ListFooterComponentStyle -
			Styling for internal View for ListFooterComponent.
			TYPE - View Style

		* ListHeaderComponent - 
			Rendered at the top of all the items. Can be a React Component (e.g. SomeComponent), or a React element (e.g. <SomeComponent />).
			TYPE - component, element

		* ListHeaderComponentStyle - 
			Styling for internal View for ListHeaderComponent
			TYPE - View Style

		* columnWrapperStyle -
			Optional custom style for multi-item rows generated when numColumns > 1.
			TYPE - View Style

		* extraData -
			A marker property for telling the list to re-render (since it implements PureComponent). If any of your renderItem, Header, Footer, etc. functions depend on anything outside of the data prop, stick it here and treat it immutably.
			TYPE - any

		* getItemLayout - 
			* (data, index) => {length: number, offset: number, index: number}
			* getItemLayout is an optional optimization that allows skipping the measurement of dynamic content if you know the size (height or width) of items ahead of time.
			* getItemLayout is efficient if you have fixed size items, for example:
				  getItemLayout={(data, index) => (
				    {length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index}
				  )}
			* Adding getItemLayout can be a great performance boost for lists of several hundred items. Remember to include separator length (height or width) in your offset calculation if you specify ItemSeparatorComponent.
			TYPE - function

		* horizontal -
			* If true, renders items next to each other horizontally instead of stacked vertically.
			TYPE - boolean

		* initialNumToRender -
			* How many items to render in the initial batch. This should be enough to fill the screen but not much more. Note these items will never be unmounted as part of the windowed rendering in order to improve perceived performance of scroll-to-top actions.
			TYPE - number		DEFAULT - 10

		* initialScrollIndex -
			* Instead of starting at the top with the first item, start at initialScrollIndex. This disables the "scroll to top" optimization that keeps the first initialNumToRender items always rendered and immediately renders the items starting at this initial index. Requires getItemLayout to be implemented.
			TYPE - number

		* inverted -
			* Reverses the direction of scroll. Uses scale transforms of -1.
			TYPE  boolean

		* keyExtractor -
			* Used to extract a unique key for a given item at the specified index. Key is used for caching and as the react key to track item re-ordering. The default extractor checks item.key, then item.id, and then falls back to using the index, like React does.
			TYPE 	function

		* numColumns -
			Multiple columns can only be rendered with horizontal={false} and will zig-zag like a flexWrap layout. Items should all be the same height - masonry layouts are not supported.
			TYPE  	number

		* onEndReached -
			* (info: {distanceFromEnd: number}) => void 
			* Called once when the scroll position gets within onEndReachedThreshold of the rendered content.
			TYPE  function

		* onEndReachedThreshold -
			* How far from the end (in units of visible length of the list) the bottom edge of the list must be from the end of the content to trigger the onEndReached callback. Thus a value of 0.5 will trigger onEndReached when the end of the content is within half the visible length of the list.
			TYPE  number

		* onRefresh -
			* () => void
			* If provided, a standard RefreshControl will be added for "Pull to Refresh" functionality. Make sure to also set the refreshing prop correctly.
				TYPE  function

		* onViewableItemsChanged -
			* Called when the viewability of rows changes, as defined by the viewabilityConfig prop.
			* (callback: { changed: array of ViewTokens, viewableItems: array of ViewTokens }) => void

		* progressViewOffset -
			* Set this when offset is needed for the loading indicator to show correctly.
			TYPE  number

		* refreshing - 
			Set this true while waiting for new data from a refresh.
			TYPE  boolean

		* removeClippedSubviews -
			This may improve scroll performance for large lists. On Android the default value is true.
			TYPE  boolean

		* viewabilityConfig -
			* See ViewabilityHelper.js for flow type and further documentation.
			* viewabilityConfig takes a type ViewabilityConfig an object with following properties
			PROPERTY							TYPE
			minimumViewTime						number
			viewAreaCoveragePercentThreshold	number
			itemVisiblePercentThreshold			number
			waitForInteraction					boolean
			* Take help from directly official website

		* viewabilityConfigCallbackPairs -
			* List of ViewabilityConfig/onViewableItemsChanged pairs. A specific onViewableItemsChanged will be called when its corresponding ViewabilityConfig's conditions are met. See ViewabilityHelper.js for flow type and further documentation.
			* TYPE 	array of ViewabilityConfigCallbackPair

	7) Methods -
		* flashScrollIndicators() - Displays the scroll indicators momentarily.
		* getNativeScrollRef() - Provides a reference to the underlying scroll component
		* getScrollResponder() - Provides a handle to the underlying scroll responder.
		* getScrollableNode() - Provides a handle to the underlying scroll node.
		* recordInteraction() - Tells the list an interaction has occurred, which should trigger viewability calculations, e.g. if waitForInteractions is true and the user has not scrolled. This is typically called by taps on items or by navigation actions.
		* scrollToEnd(params) - Scrolls to the end of the content. May be janky without getItemLayout prop.
				NAME - params	TYPE - object
			Valid params keys are:
			* 'animated' (boolean) - Whether the list should do an animation while scrolling. Defaults to true.

		* scrollToIndex(params) - 
			* Scrolls to the item at the specified index such that it is positioned in the viewable area such that viewPosition 0 places it at the top, 1 at the bottom, and 0.5 centered in the middle.
			* Note: Cannot scroll to locations outside the render window without specifying the getItemLayout prop.
				NAME - params	TYPE - object
			* Valid params keys are:
				* 'animated' (boolean) - Whether the list should do an animation while scrolling. Defaults to true.
				* 'index' (number) - The index to scroll to. Required.
				* 'viewOffset' (number) - A fixed number of pixels to offset the final target position.
				* 'viewPosition' (number) - A value of 0 places the item specified by index at the top, 1 at the bottom, and 0.5 centered in the middle.

		* scrollToItem(params) - 
			* Requires linear scan through data - use scrollToIndex instead if possible.
			* Note: Cannot scroll to locations outside the render window without specifying the getItemLayout prop.
				NAME - params	TYPE - object
			* Valid params keys are:
				* 'animated' (boolean) - Whether the list should do an animation while scrolling. Defaults to true.
				* 'item' (object) - The item to scroll to. Required.
				* 'viewPosition' (number)

		* scrollToOffset(params) -
			* Scroll to a specific content pixel offset in the list.
				NAME - params	TYPE - object
			* Valid params keys are:
				* 'offset' (number) - The offset to scroll to. In case of horizontal being true, the offset is the x-value, in any other case the offset is the y-value. Required.
				* 'animated' (boolean) - Whether the list should do an animation while scrolling. Defaults to true.


5) Image -
	1) A React component for displaying different types of images, including network images, static resources, temporary local images, and images from local disk, such as the camera roll.
	2) This example shows fetching and displaying an image from local storage as well as one from network and even from data provided in the 'data:' uri scheme.
	3) When building your own native code, GIF and WebP are not supported by default on Android.
	4) You will need to add some optional modules in android/app/build.gradle, depending on the needs of your app.
		* Take help from directly official website
	5) Props -
		* View Props - Inherits View Props.
		* accessible - When true, indicates the image is an accessibility element
			TYPE - bool		DEFAULT - false

		* accessibilityLabel - The text that's read by the screen reader when the user interacts with the image.
			TYPE - string

		* blurRadius - blurRadius: the blur radius of the blur filter added to the image.
			TYPE - number

		* capInsets (iOS) - When the image is resized, the corners of the size specified by capInsets will stay a fixed size, but the center content and borders of the image will be stretched. This is useful for creating resizable rounded buttons, shadows, and other resizable assets. More info in the official Apple documentation.
			TYPE - Rect

		* defaultSource - A static image to display while loading the image source.
			TYPE  ImageSource

		* fadeDuration (Android) - Fade animation duration in miliseconds.
			TYPE - number		DEFAULT - 300

		* loadingIndicatorSource - Similarly to source, this property represents the resource used to render the loading indicator for the image. The loading indicator is displayed until image is ready to be displayed, typically after the image is downloaded.
			TYPE - ImageSource (uri only), number

		* onError - Invoked on load error.
		* onLayout - Invoked on mount and on layout changes.
		* onLoad - Invoked when load completes successfully.
		* onLoadEnd - Invoked when load either succeeds or fails.
		* onLoadStart - Invoked on load start.
		* onPartialLoad (iOS) - Invoked when a partial load of the image is complete. The definition of what constitutes a "partial load" is loader specific though this is meant for progressive JPEG loads.
		* onProgress - Invoked on download progress
		* progressiveRenderingEnabledAndroid - When true, enables progressive jpeg streaming - https://frescolib.org/docs/progressive-jpegs.
			TYPE	bool	DEFAULT false

		* resizeMethod(Android) - 
			* The mechanism that should be used to resize the image when the image's dimensions differ from the image view's dimensions. Defaults to auto.

		* resizeMode - 
			* Determines how to resize the image when the frame doesn't match the raw image dimensions. Defaults to cover.
			* cover: Scale the image uniformly (maintain the image's aspect ratio) so that
				* both dimensions (width and height) of the image will be equal to or larger than the corresponding dimension of the view (minus padding)
				* at least one dimension of the scaled image will be equal to the corresponding dimension of the view (minus padding)
				contain: Scale the image uniformly (maintain the image's aspect ratio) so that both dimensions (width and height) of the image will be equal to or less than the corresponding dimension of the view (minus padding).

			* stretch: Scale width and height independently, This may change the aspect ratio of the src.
			* repeat: Repeat the image to cover the frame of the view. The image will keep its size and aspect ratio, unless it is larger than the view, in which case it will be scaled down uniformly so that it is contained in the view.
			* center: Center the image in the view along both dimensions. If the image is larger than the view, scale it down uniformly so that it is contained in the view.

		* source - 
			* The image source (either a remote URL or a local file resource).
			* This prop can also contain several remote URLs, specified together with their width and height and potentially with scale/other URI arguments.
			* Take help from directly official website
				TYPE  ImageSource

		* style -
			TYPE - Image Style Props, Layout Props, Shadow Props, Transforms
		
		* testID - A unique identifier for this element to be used in UI Automation testing scripts.
			TYPE - string

	6) Methods -
		* abortPrefetch() (Android) - Abort prefetch request.
			NAME		TYPE		DESCRIPTION
			requestId 	Required	number	Request id as returned by prefetch().

		* getSize() - Retrieve the width and height (in pixels) of an image prior to displaying it. This method can fail if the image cannot be found, or fails to download.

		NAME 		TYPE		DESCRIPTION
		uri 		Required	string	The location of the image.
		success 	Required	function	The function that will be called if the image was successfully found and width and height retrieved.
		failure		function	The function that will be called if there was an error, such as failing to retrieve the image.

		* getSizeWithHeaders() - 
			* Image.getSizeWithHeaders(uri, headers, success, [failure]);
			* Retrieve the width and height (in pixels) of an image prior to displaying it with the ability to provide the headers for the request. This method can fail if the image cannot be found, or fails to download. It also does not work for static image resources.

			NAME 				TYPE		DESCRIPTION
			uri 	Required	string		The location of the image.
			headers Required	object		The headers for the request.
			success Required	function	The function that will be called if the image was successfully found and width and height retrieved.
			failure				function	The function that will be called if there was an error, such as failing to retrieve the image.

Will come back for image ....


6) ImageBackground -
	* A common feature request from developers familiar with the web is background-image. To handle this use case, you can use the <ImageBackground> component, which has the same props as <Image>, and add whatever children to it you would like to layer on top of it.
	* props -
		1) Image Props - Inherits Image Props.
		2) imageStyle - TYPE - Image Style
		3) imageRef - Allows to set a reference to the inner Image component
			TYPE - Ref
		4) style - TYPE View Style

7) KeyboardAvoidingView -
	* This component will automatically adjust its height, position, or bottom padding based on the keyboard height to remain visible while the virtual keyboard is displayed.
	* Props - 
		1) View Props - Inherits View Props.
		2) behavior - Specify how to react to the presence of the keyboard.
			TYPE - enum('height', 'position', 'padding')
		3) contentContainerStyle - The style of the content container (View) when behavior is 'position'.
			TYPE - View Style
		4) enabled - Enabled or disabled KeyboardAvoidingView.
			TYPE - boolean		DEFAULT - true
		5) keyboardVerticalOffset - This is the distance between the top of the user screen and the react native view, may be non-zero in some use cases.
			TYPE - number		DEFAULT - 0

8) Modal -
	* The Modal component is a basic way to present content above an enclosing view.
	* Props -
		View Props
		animated
		animationType
		hardwareAcceleratedAndroid
		onDismissiOS
		onOrientationChangeiOS
		onRequestClose
		onShow
		presentationStyleiOS
		statusBarTranslucentAndroid
		supportedOrientationsiOS
		transparent
		visible


9) Pressable -
	* Pressable is a Core Component wrapper that can detect various stages of press interactions on any of its defined children.
	* ex. 
		<Pressable onPress={onPressFunction}>
		  <Text>I'm pressable!</Text>
		</Pressable>
	* 2 types of things will happen with Pressable-
		onPressIn, onPressOut
		After onPressIn, two things will happen -
			1) instant onPressOut
			2) delayed onPressOut, like onLongPress
	* Props -
		android_disableSoundAndroid
		android_rippleAndroid
		children
		unstable_pressDelay
		delayLongPress
		disabled
		hitSlop
		onLongPress
		onPress
		onPressIn
		onPressOut
		pressRetentionOffset
		style
		testOnly_pressed
		Type Definitions
		RippleConfig



10) RefreshControl -
	* This component is used inside a ScrollView or ListView to add pull to refresh functionality. When the ScrollView is at scrollY: 0, swiping down triggers an onRefresh event.
	* Props -
		* View Props
		* refreshing (Required)
		* colorsAndroid
		* enabledAndroid
		* onRefresh
		* progressBackgroundColorAndroid
		* progressViewOffset
		* sizeAndroid
		* tintColoriOS
		* titleiOS
		* titleColor

11) ScrollView -
	* Component that wraps platform ScrollView while providing integration with touch locking "responder" system.
	* ScrollView renders all its react child components at once, but this has a performance downside.
	* Imagine you have a very long list of items you want to display, maybe several screens worth of content. Creating JS components and native views for everything all at once, much of which may not even be shown, will contribute to slow rendering and increased memory usage.
	* This is where FlatList comes into play. FlatList renders items lazily, when they are about to appear, and removes items that scroll way off screen to save memory and processing time.
	* FlatList is also handy if you want to render separators between your items, multiple columns, infinite scroll loading, or any number of other features it supports out of the box.

	* Props -
		View Props
		StickyHeaderComponent
		alwaysBounceHorizontal	(iOS)
		alwaysBounceVertical	(iOS)
		automaticallyAdjustContentInsets	(iOS)
		automaticallyAdjustKeyboardInsets	(iOS)
		automaticallyAdjustsScrollIndicatorInsets	(iOS)
		bounces	(iOS)
		bouncesZoom	(iOS)
		canCancelContentTouches	(iOS)
		centerContent	(iOS)
		contentContainerStyle
		contentInset	(iOS)
		contentInsetAdjustmentBehavior	(iOS)
		contentOffset
		decelerationRate
		directionalLockEnabled	(iOS)
		disableIntervalMomentum
		disableScrollViewPanResponder
		endFillColor 	(Android)
		fadingEdgeLength 	(Android)
		horizontal
		indicatorStyle	(iOS)
		invertStickyHeaders
		keyboardDismissMode
		keyboardShouldPersistTaps
		maintainVisibleContentPosition	(iOS)
		maximumZoomScale	(iOS)
		minimumZoomScale	(iOS)
		nestedScrollEnabled 	(Android)
		onContentSizeChange
		onMomentumScrollBegin
		onMomentumScrollEnd
		onScroll
		onScrollBeginDrag
		onScrollEndDrag
		onScrollToTop	(iOS)
		overScrollMode 	(Android)
		pagingEnabled
		persistentScrollbar 	(Android)
		pinchGestureEnabled	(iOS)
		refreshControl
		removeClippedSubviews
		scrollEnabled
		scrollEventThrottle	(iOS)
		scrollIndicatorInsets	(iOS)
		scrollPerfTag 	(Android)
		scrollToOverflowEnabled	(iOS)
		scrollsToTop	(iOS)
		showsHorizontalScrollIndicator
		showsVerticalScrollIndicator
		snapToAlignment	(iOS)
		snapToEnd
		snapToInterval
		snapToOffsets
		snapToStart
		stickyHeaderHiddenOnScroll
		stickyHeaderIndices
		zoomScalei

	* Methods -
		flashScrollIndicators()
		scrollTo()
		scrollToEnd()

12) SectionList -
	* A performant interface for rendering sectioned lists, supporting the most handy features:
		Fully cross-platform.
		Configurable viewability callbacks.
		List header support.
		List footer support.
		Item separator support.
		Section header support.
		Section separator support.
		Heterogeneous data and item rendering support.
		Pull to Refresh.
		Scroll loading.
	* This is a convenience wrapper around <VirtualizedList>, and thus inherits its props (as well as those of <ScrollView>) that aren't explicitly listed here, along with the following caveats:
		1) Internal state is not preserved when content scrolls out of the render window. Make sure all your data is captured in the item data or external stores like Flux, Redux, or Relay.
		
		2) This is a PureComponent which means that it will not re-render if props remain shallow-equal. Make sure that everything your renderItem function depends on is passed as a prop (e.g. extraData) that is not === after updates, otherwise your UI may not update on changes. This includes the data prop and parent component state.
		
		3) In order to constrain memory and enable smooth scrolling, content is rendered asynchronously offscreen. This means it's possible to scroll faster than the fill rate and momentarily see blank content. This is a tradeoff that can be adjusted to suit the needs of each application, and we are working on improving it behind the scenes.

		4) By default, the list looks for a key prop on each item and uses that for the React key. Alternatively, you can provide a custom keyExtractor prop.

	* Props -
		VirtualizedList Props
		renderItem (Required)
		sections (Required)
		extraData
		initialNumToRender
		inverted
		ItemSeparatorComponent
		keyExtractor
		ListEmptyComponent
		ListFooterComponent
		ListHeaderComponent
		onEndReached
		onEndReachedThreshold
		onRefresh
		onViewableItemsChanged
		refreshing
		removeClippedSubviews
		renderSectionFooter
		renderSectionHeader
		SectionSeparatorComponent
		stickySectionHeadersEnabled

	* Methods -
		flashScrollIndicators() (iOS)
		recordInteraction()
		scrollToLocation()
		Type Definitions
		Section

13) StatusBar -
	* Component to control the app's status bar. The status bar is the zone, typically at the top of the screen, that displays the current time, Wi-Fi and cellular network information, battery level and/or other status icons.
* Usage with Navigator -
	1) It is possible to have multiple StatusBar components mounted at the same time. The props will be merged in the order the StatusBar components were mounted.

	* Constants -
		currentHeightAndroid
	* Props -
		animated
		backgroundColor	(Android)
		barStyle
		hidden
		networkActivityIndicatorVisible	(iOS)
		showHideTransition	(iOS)
		translucent	(Android)

	* Methods -
		popStackEntry()
		pushStackEntry()
		replaceStackEntry()
		setBackgroundColor()	(Android)
		setBarStyle()
		setHidden()
		setNetworkActivityIndicatorVisible()	(iOS)
		setTranslucent()	(Android)
		Type Definitions
		StatusBarAnimation
		StatusBarStyle

14) Switch -
	* Renders a boolean input.
	* This is a controlled component that requires an onValueChange callback that updates the value prop in order for the component to reflect user actions. If the value prop is not updated, the component will continue to render the supplied value prop instead of the expected result of any user actions.
	* Props -
		View Props
		disabled
		ios_backgroundColoriOS
		onChange
		onValueChange
		thumbColor
		trackColor
		value

15) Text -
	* A React component for displaying text.
	* Text supports nesting, styling, and touch handling.
* Nested text -
	Both Android and iOS allow you to display formatted text by annotating ranges of a string with specific formatting like bold or colored text (NSAttributedString on iOS, SpannableString on Android). In practice, this is very tedious. For React Native, we decided to use web paradigm for this where you can nest text to achieve the same effect.
* Containers -
	The <Text> element is unique relative to layout: everything inside is no longer using the Flexbox layout but using text layout. This means that elements inside of a <Text> are no longer rectangles, but wrap when they see the end of the line.
* Need More Time ...

	* Props -
		accessibilityHint
		accessibilityLanguage (iOS)
		accessibilityLabel
		accessibilityRole
		accessibilityState
		accessibilityActions
		onAccessibilityAction
		accessible
		adjustsFontSizeToFit
		allowFontScaling
		android_hyphenationFrequencyAndroid
		dataDetectorType (Android)
		disabled (Android)
		ellipsizeMode
		maxFontSizeMultiplier
		minimumFontScale (iOS)
		nativeID
		numberOfLines
		onLayout
		onLongPress
		onMoveShouldSetResponder
		onPress
		onResponderGrant
		onResponderMove
		onResponderRelease
		onResponderTerminate
		onResponderTerminationRequest
		onStartShouldSetResponderCapture
		onTextLayout
		pressRetentionOffset
		selectable
		selectionColor (Android)
		style
		suppressHighlighting (iOS)
		testID
		textBreakStrategyAndroid
	* Type Definitions
		TextLayout
		TextLayoutEvent

16) TextInput -
	* A foundational component for inputting text into the app via a keyboard. Props provide configurability for several features, such as auto-correction, auto-capitalization, placeholder text, and different keyboard types, such as a numeric keypad.
	* The most basic use case is to plop down a TextInput and subscribe to the onChangeText events to read the user input. There are also other events, such as onSubmitEditing and onFocus that can be subscribed to.
	* Two methods exposed via the native element are .focus() and .blur() that will focus or blur the TextInput programmatically.
	* Note that some props are only available with multiline={true/false}. Additionally, border styles that apply to only one side of the element (e.g., borderBottomColor, borderLeftWidth, etc.) will not be applied if multiline=true.

	* Props -
		* View Props
		
		* allowFontScaling - Specifies whether fonts should scale to respect Text Size accessibility settings. The default is true.

		* autoCapitalize - 
			* Tells TextInput to automatically capitalize certain characters. This property is not supported by some keyboard types such as name-phone-pad.
			TYPE 	enum('none', 'sentences', 'words', 'characters')

		* autoComplete	(Android)- 
			* Specifies autocomplete hints for the system, so it can provide autofill. On Android, the system will always attempt to offer autofill by using heuristics to identify the type of content. To disable autocomplete, set autoComplete to off.
			* Possible values for autoComplete are:
				enum('birthdate-day', 'birthdate-full', 'birthdate-month', 'birthdate-year', 'cc-csc', 'cc-exp', 'cc-exp-day', 'cc-exp-month', 'cc-exp-year', 'cc-number', 'email', 'gender', 'name', 'name-family', 'name-given', 'name-middle', 'name-middle-initial', 'name-prefix', 'name-suffix', 'password', 'password-new', 'postal-address', 'postal-address-country', 'postal-address-extended', 'postal-address-extended-postal-code', 'postal-address-locality', 'postal-address-region', 'postal-code', 'street-address', 'sms-otp', 'tel', 'tel-country-code', 'tel-national', 'tel-device', 'username', 'username-new', 'off')


		* autoCorrect - If false, disables auto-correct. The default value is true.

		* autoFocus - If true, focuses the input on componentDidMount or useEffect. The default value is false.

		* blurOnSubmit - If true, the text field will blur when submitted. The default value is true for single-line fields and false for multiline fields. Note that for multiline fields, setting blurOnSubmit to true means that pressing return will blur the field and trigger the onSubmitEditing event instead of inserting a newline into the field.

		* caretHidden - If true, caret is hidden. The default value is false.

		* clearButtonModeiOS - When the clear button should appear on the right side of the text view. This property is supported only for single-line TextInput component. The default value is never.

		* clearTextOnFocus (iOS) - If true, clears the text field automatically when editing begins.

		* contextMenuHidden - If true, context menu is hidden. The default value is false.

		* dataDetectorTypes(iOS) - 
			* Determines the types of data converted to clickable URLs in the text input. Only valid if multiline={true} and editable={false}. By default no data types are detected.
			* You can provide one type or an array of many types.
			enum('phoneNumber', 'link', 'address', 'calendarEvent', 'none', 'all'), ,array of enum('phoneNumber', 'link', 'address', 'calendarEvent', 'none', 'all')


		* defaultValue - Provides an initial value that will change when the user starts typing. Useful for use-cases where you do not want to deal with listening to events and updating the value prop to keep the controlled state in sync.

		* cursorColor	(Android) -
			* When provided it will set the color of the cursor (or "caret") in the component. Unlike the behavior of selectionColor the cursor color will be set independently from the color of the text selection box.

		* disableFullscreenUI (Android) -
			* When false, if there is a small amount of space available around a text input (e.g. landscape orientation on a phone), the OS may choose to have the user edit the text inside of a full screen text input mode. When true, this feature is disabled and users will always edit the text directly inside of the text input. Defaults to false.

		* editable - If false, text is not editable. The default value is true.

		* enablesReturnKeyAutomatically(iOS)- 
			* If true, the keyboard disables the return key when there is no text and automatically enables it when there is text. The default value is false.
			TYPE 	bool

		* importantForAutofill(Android) - 
			* Tells the operating system whether the individual fields in your app should be included in a view structure for autofill purposes on Android API Level 26+. Possible values are auto, no, noExcludeDescendants, yes, and yesExcludeDescendants. The default value is auto.
			* auto: Let the Android System use its heuristics to determine if the view is important for autofill.
			* no: This view isn't important for autofill.
			* noExcludeDescendants: This view and its children aren't important for autofill.
			* yes: This view is important for autofill.
			* yesExcludeDescendants: This view is important for autofill, but its children aren't important for autofill.

		* inlineImageLeft(Android) -
			* If defined, the provided image resource will be rendered on the left. The image resource must be inside /android/app/src/main/res/drawable and referenced like -
				<TextInput	inlineImageLeft='search_icon' />


		* inlineImagePadding(Android) -
			* Padding between the inline image, if any, and the text input itself.
			Type 	number

		* inputAccessoryViewID(iOS) - An optional identifier which links a custom InputAccessoryView to this text input. The InputAccessoryView is rendered above the keyboard when this text input is focused.
			Type 	string
 

		* keyboardAppearance(iOS) -
			* Determines the color of the keyboard
			Type 	enum('default', 'light', 'dark')

		* keyboardType - 
			* Determines which keyboard to open, e.g.numeric.
			* The following values work across platforms:
				* default
				* number-pad
				* decimal-pad
				* numeric
				* email-address
				* phone-pad
				* url
			* iOS Only =
				The following values work on iOS only:
					* ascii-capable
					* numbers-and-punctuation
					* name-phone-pad
					* twitter
					* web-search
			* Android Only
				* visible-password

		* maxFontSizeMultiplier - 
			* Specifies largest possible scale a font can reach when allowFontScaling is enabled. Possible values:
				* null/undefined (default): inherit from the parent node or the global default (0)
				* 0: no max, ignore parent/global default
				* >= 1: sets the maxFontSizeMultiplier of this node to this value

		* maxLength - 
			* Limits the maximum number of characters that can be entered. Use this instead of implementing the logic in JS to avoid flicker.
			TYPE  number

		* multiline - If true, the text input can be multiple lines. The default value is false.
			TYPE 	bool

		* numberOfLines(Android) - Sets the number of lines for a TextInput. Use it with multiline set to true to be able to fill the lines. TYPE 	number

		* onBlur - Callback that is called when the text input is blurred. TYPE 	function

		* onChange - Callback that is called when the text input's text changes. 
			TYPE  ({ nativeEvent: { eventCount, target, text} }) => void

		* onChangeText - Callback that is called when the text input's text changes. Changed text is passed as a single string argument to the callback handler. TYPE 	function

		* onContentSizeChange - Callback that is called when the text input's content size changes.Only called for multiline text inputs.	TYPE 	({ nativeEvent: { contentSize: { width, height } } }) => void

		* onEndEditing - Callback that is called when text input ends. TYPE 	function

		* onPressIn - Callback that is called when a touch is engaged. TYPE 	({ nativeEvent: PressEvent }) => void

		* onPressOut - Callback that is called when a touch is released. TYPE    ({ nativeEvent: PressEvent }) => void

		* onFocus - Callback that is called when the text input is focused. TYPE   ({ nativeEvent: LayoutEvent }) => void
		
		* onKeyPress - 
			* Callback that is called when a key is pressed. This will be called with object where keyValue is 'Enter' or 'Backspace' for respective keys and the typed-in character otherwise including ' ' for space. Fires before onChange callbacks. Note: on Android only the inputs from soft keyboard are handled, not the hardware keyboard inputs.

		* onLayout - Invoked on mount and on layout changes.
			TYPE 	({ nativeEvent: LayoutEvent }) => void

		* onScroll - 
			* Invoked on content scroll. May also contain other properties from ScrollEvent but on Android contentSize is not provided for performance reasons.
			* TYPE 	({ nativeEvent: { contentOffset: { x, y } } }) => void

		* onSelectionChange - Callback that is called when the text input selection is changed.
			TYPE 	({ nativeEvent: { selection: { start, end } } }) => void

		* onSubmitEditing - Callback that is called when the text input's submit button is pressed.
			TYPE 	({ nativeEvent: { text, eventCount, target }}) => void

		* placeholder - The string that will be rendered before text input has been entered.
			TYPE 	string

		* placeholderTextColor - The text color of the placeholder string.
			TYPE 	color

		* returnKeyLabel(Android) - Sets the return key to the label. Use it instead of returnKeyType.
			TYPE 	string

		* returnKeyType - 
			* Determines how the return key should look. On Android you can also use returnKeyLabel.

			* Cross platform -
				* The following values work across platforms:
					done
					go
					next
					search
					send
			* Android Only -
				The following values work on Android only:
					* none
					* previous
			* iOS Only -
				The following values work on iOS only:
					* default
					* emergency-call
					* google
					* join
					* route
					* yahoo

		* rejectResponderTermination(iOS) -
			* If true, allows TextInput to pass touch events to the parent component. This allows components such as SwipeableListView to be swipeable from the TextInput on iOS, as is the case on Android by default. If false, TextInput always asks to handle the input (except when disabled). The default value is true.
			TYPE  bool

		* scrollEnabled(iOS) - 
			* If false, scrolling of the text view will be disabled. The default value is true. Only works with multiline={true}.
			TYPE 	bool

		* secureTextEntry -
			If true, the text input obscures the text entered so that sensitive text like passwords stay secure. The default value is false. Does not work with multiline={true}.
				TYPE 	bool

		* selection - 
			* The start and end of the text input's selection. Set start and end to the same value to position the cursor.
			TYPE 	object: {start: number,end: number}

		* selectionColor =
			* The highlight and cursor color of the text input.
			TYPE 	color

		* selectTextOnFocus - If true, all text will automatically be selected on focus.
			TYPE 	bool

		* showSoftInputOnFocus - When false, it will prevent the soft keyboard from showing when the field is focused. The default value is true.
			TYPE 	bool

		* spellCheck(iOS) - If false, disables spell-check style (i.e. red underlines). The default value is inherited from autoCorrect. TYPE  bool

		* textAlign - Align the input text to the left, center, or right sides of the input field.
			* Possible values for textAlign are: left, center, right

		* textContentType(iOS) -
			* Give the keyboard and the system information about the expected semantic meaning for the content that users enter.
			* For iOS 11+ you can set textContentType to username or password to enable autofill of login details from the device keychain.
			* For iOS 12+ newPassword can be used to indicate a new password input the user may want to save in the keychain, and oneTimeCode can be used to indicate that a field can be autofilled by a code arriving in an SMS.
			* To disable autofill, set textContentType to none.

			Possible values for textContentType are:
				none
				URL
				addressCity
				addressCityAndState
				addressState
				countryName
				creditCardNumber
				emailAddress
				familyName
				fullStreetAddress
				givenName
				jobTitle
				location
				middleName
				name
				namePrefix
				nameSuffix
				nickname
				organizationName
				postalCode
				streetAddressLine1
				streetAddressLine2
				sublocality
				telephoneNumber
				username
				password
				newPassword
				oneTimeCode

		* passwordRules(iOS) - When using textContentType as newPassword on iOS we can let the OS know the minimum requirements of the password so that it can generate one that will satisfy them. In order to create a valid string for PasswordRules take a look to the Apple Docs.

		* style - Note that not all Text styles are supported, an incomplete list of what is not supported includes:
			borderLeftWidth
			borderTopWidth
			borderRightWidth
			borderBottomWidth
			borderTopLeftRadius
			borderTopRightRadius
			borderBottomRightRadius
			borderBottomLeftRadius

		* textBreakStrategy	(Android) - Set text break strategy on Android API Level 23+, possible values are simple, highQuality, balanced The default value is simple.
			TYPE 	enum('simple', 'highQuality', 'balanced')

		* underlineColorAndroid	(Android) - The color of the TextInput underline.
			TYPE 	color

		* value - 
			* The value to show for the text input. TextInput is a controlled component, which means the native value will be forced to match this value prop if provided. For most uses, this works great, but in some cases this may cause flickering - one common cause is preventing edits by keeping value the same. In addition to setting the same value, either set editable={false}, or set/update maxLength to prevent unwanted edits without flicker.
				TYPE string

	* Methods
		.focus() - Makes the native input request focus.
		.blur() - Makes the native input lose focus.
		clear() - Removes all text from the TextInput.
		isFocused() - Returns true if the input is currently focused; false otherwise.


17) TouchableHighlight -
	* A wrapper for making views respond properly to touches. On press down, the opacity of the wrapped view is decreased, which allows the underlay color to show through, darkening or tinting the view.

	* The underlay comes from wrapping the child in a new View, which can affect layout, and sometimes cause unwanted visual artifacts if not used correctly, for example if the backgroundColor of the wrapped view isn't explicitly set to an opaque color.

	* TouchableHighlight must have one child (not zero or more than one). If you wish to have several child components, wrap them in a View.

	* props -
		TouchableWithoutFeedback Props - Inherits TouchableWithoutFeedback Props.

		* activeOpacity - Determines what the opacity of the wrapped view should be when touch is active. The value should be between 0 and 1. Defaults to 0.85. Requires underlayColor to be set.

		* onHideUnderlay - Called immediately after the underlay is hidden.

		* onShowUnderlay - Called immediately after the underlay is shown.

		* style - 
		
		* underlayColor - The color of the underlay that will show through when the touch is active.

		* hasTVPreferredFocus(iOS) - (Apple TV only) TV preferred focus (see documentation for the View component).

		* nextFocusDown(Android) - TV next focus down (see documentation for the View component).

		* nextFocusForward(Android) - TV next focus forward (see documentation for the View component).

		* nextFocusLeftAndroid -

		* nextFocusRightAndroid -

		* nextFocusUpAndroid -

		* testOnly_pressed -




20) View -
	* The most fundamental component for building a UI, View is a container that supports layout with flexbox, style, some touch handling, and accessibility controls. View maps directly to the native view equivalent on whatever platform React Native is running on, whether that is a UIView, <div>, android.view, etc.
	* View is designed to be nested inside other views and can have 0 to many children of any type.
	* Props -
		accessibilityActions
		accessibilityElementsHidden (iOS)
		accessibilityHint
		accessibilityLanguage (iOS)
		accessibilityIgnoresInvertColors (iOS)
		accessibilityLabel
		accessibilityLiveRegion (Android)
		accessibilityRole
		accessibilityState
		accessibilityValue
		accessibilityViewIsModal (iOS)
		accessible
		collapsable (Android)
		focusable (Android)
		hitSlop
		importantForAccessibility (Android)
		nativeID
		needsOffscreenAlphaCompositing
		nextFocusDown (Android)
		nextFocusForward (Android)
		nextFocusLeft (Android)
		nextFocusRight (Android)
		nextFocusUp (Android)
		onAccessibilityAction
		onAccessibilityEscape (iOS)
		onAccessibilityTap
		onLayout
		onMagicTap (iOS)
		onMoveShouldSetResponder
		onMoveShouldSetResponderCapture
		onResponderGrant
		onResponderMove
		onResponderReject
		onResponderRelease
		onResponderTerminate
		onResponderTerminationRequest
		onStartShouldSetResponder
		onStartShouldSetResponderCapture
		pointerEvents
		removeClippedSubviews
		renderToHardwareTextureAndroid (Android)
		shouldRasterizeIOS (iOS)
		style
		testID

21) VirtualizedList -
	* . In general, this should only really be used if you need more flexibility than FlatList provides, e.g. for use with immutable data instead of plain arrays.
	* Virtualization massively improves memory consumption and performance of large lists by maintaining a finite render window of active items and replacing all items outside of the render window with appropriately sized blank space. 
	* The window adapts to scrolling behavior, and items are rendered incrementally with low-pri (after any running interactions) if they are far from the visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.
	* some caveats -
		same as Flatlist and Sectionlist
	* Props -
		ScrollView Props
		data 	(Required)
		getItem 	(Required)
		getItemCount 	(Required)
		renderItem 	(Required)
		CellRendererComponent
		ItemSeparatorComponent
		ListEmptyComponent
		ListItemComponent
		ListFooterComponent
		ListFooterComponentStyle
		ListHeaderComponent
		ListHeaderComponentStyle
		debug
		disableVirtualization
		extraData
		getItemLayout
		horizontal
		initialNumToRender
		initialScrollIndex
		inverted
		listKey
		keyExtractor
		maxToRenderPerBatch
		onEndReached
		onEndReachedThreshold
		onRefresh
		onScrollToIndexFailed
		onViewableItemsChanged
		persistentScrollbar
		progressViewOffset
		refreshControl
		refreshing
		removeClippedSubviews
		renderScrollComponent
		viewabilityConfig
		viewabilityConfigCallbackPairs
		updateCellsBatchingPeriod
		windowSize
		Methods
		flashScrollIndicators()
		getChildContext()
		getScrollableNode()
		getScrollRef()
		getScrollResponder()
		hasMore()
		scrollToEnd()
		scrollToIndex()
		scrollToItem()
		scrollToOffset()
		recordInteraction()
		setNativeProps()



B) Android Components -
1) DrawerLayoutAndroid -
	* React component that wraps the platform DrawerLayout (Android only). 
	* The Drawer (typically used for navigation) is rendered with renderNavigationView and direct children are the main view (where your content goes).
	Need More Time ...

2) TouchableNativeFeedback -
	* Used Pressable.
	* A wrapper for making views respond properly to touches (Android only). On Android this component uses native state drawable to display touch feedback.
	Need More Time ...


C) iOS Components -
1) InputAccessoryView -
	* A component which enables customization of the keyboard input accessory view on iOS. The input accessory view is displayed above the keyboard whenever a TextInput has focus. This component can be used to create custom toolbars.
	* To use this component wrap your custom toolbar with the InputAccessoryView component, and set a nativeID. Then, pass that nativeID as the inputAccessoryViewID of whatever TextInput you desire. 
	* Props -
		backgroundColor
		nativeID
		style

2) SafeAreaView -
	* The purpose of SafeAreaView is to render content within the safe area boundaries of a device. It is currently only applicable to iOS devices with iOS version 11 or later.
	* SafeAreaView renders nested content and automatically applies padding to reflect the portion of the view that is not covered by navigation bars, tab bars, toolbars, and other ancestor views. Moreover, and most importantly, Safe Area's paddings reflect the physical limitation of the screen, such as rounded corners or camera notches (i.e. the sensor housing area on iPhone 13).


D) Props -
1) Image Style Props -
	backfaceVisibility
	backgroundColor
	borderBottomLeftRadius
	borderBottomRightRadius
	borderColor
	borderRadius
	borderTopLeftRadius
	borderTopRightRadius
	borderWidth
	opacity
	overflow
	overlayColorAndroid
	resizeMode
	tintColor

2) Layout Props -
	alignContent
	alignItems
	alignSelf
	aspectRatio
	borderBottomWidth
	borderEndWidth
	borderLeftWidth
	borderRightWidth
	borderStartWidth
	borderTopWidth
	borderWidth
	bottom
	direction
	display
	end
	flex
	flexBasis
	flexDirection
	flexGrow
	flexShrink
	flexWrap
	height
	justifyContent
	left
	margin
	marginBottom
	marginEnd
	marginHorizontal
	marginLeft
	marginRight
	marginStart
	marginTop
	marginVertical
	maxHeight
	maxWidth
	minHeight
	minWidth
	overflow
	padding
	paddingBottom
	paddingEnd
	paddingHorizontal
	paddingLeft
	paddingRight
	paddingStart
	paddingTop
	paddingVertical
	position
	right
	start
	top
	width
	zIndex

3) Shadow Props -
	shadowColor
	shadowOffset (iOS)
	shadowOpacity (iOS)
	shadowRadius

4) Text Style Props -
	color
	fontFamily
	fontSize
	fontStyle
	fontWeight
	includeFontPaddingAndroid
	fontVariant
	letterSpacing
	lineHeight
	textAlign
	textAlignVerticalAndroid
	textDecorationColoriOS
	textDecorationLine
	textDecorationStyleiOS
	textShadowColor
	textShadowOffset
	textShadowRadius
	textTransform
	writingDirection

5) View Style Props -
	backfaceVisibility
	backgroundColor
	borderBottomColor
	borderBottomEndRadius
	borderBottomLeftRadius
	borderBottomRightRadius
	borderBottomStartRadius
	borderBottomWidth
	borderColor
	borderEndColor
	borderLeftColor
	borderLeftWidth
	borderRadius
	borderRightColor
	borderRightWidth
	borderStartColor
	borderStyle
	borderTopColor
	borderTopEndRadius
	borderTopLeftRadius
	borderTopRightRadius
	borderTopStartRadius
	borderTopWidth
	borderWidth
	elevationAndroid
	opacity


E) Object Types -
1)	LayoutEvent Object Type -
	* LayoutEvent object is returned in the callback as a result of component layout change, for example onLayout in View component.
	* Keys and Value -
		height
		width
		x
		y
		target
	* Used by -
		Image
		Pressable
		ScrollView
		Text
		TextInput
		TouchableWithoutFeedback
		View

2) PressEvent Object Type -
	* PressEvent object is returned in the callback as a result of user press interaction, for example onPress in Button component.
	* Keys and value -
		changedTouches
		force (iOS)
		identifier
		locationX
		locationY
		pageX
		pageY
		target
		timestamp
		touches

	* Used by
		Button
		PanResponder
		Pressable
		ScrollView
		Text
		TextInput
		TouchableHighlight
		TouchableOpacity
		TouchableNativeFeedback
		TouchableWithoutFeedback
		View

3) React Node Object Type -
	* A React Node is one of the following types:
		Boolean (which is ignored)
		null or undefined (which is ignored)
		Number
		String
		A React element (result of JSX)
		An array of any of the above, possibly a nested one


4) Rect Object Type -
	* Rect accepts numeric pixel values to describe how far to extend a rectangular area. These values are added to the original area's size to expand it.
	* Keys and values -
		bottom
		left
		right
		top
	* Used by -
		Image
		Pressable
		Text
		TouchableWithoutFeedback


5) ViewToken Object Type -
	* ViewToken object is returned as one of properties in the onViewableItemsChanged callback, for example in FlatList component. It is exported by ViewabilityHelper.js.
	* Keys and values - 
		index
		isViewable
		item
		key
		section

	* Used by -
		FlatList
		SectionList
		VirtualizedList
------------------------------------------------------------------------------------------------
API -

A) APIs
1) AccessibilityInfo -
	* Sometimes it's useful to know whether or not the device has a screen reader that is currently active. The AccessibilityInfo API is designed for this purpose. You can use it to query the current state of the screen reader as well as to register to be notified when the state of the screen reader changes.
	* Methods -
		addEventListener()
		announceForAccessibility()
		announceForAccessibilityWithOptions()
		getRecommendedTimeoutMillis()  (Android)
		isAccessibilityServiceEnabled()  (Android)
		isBoldTextEnabled() (iOS)
		isGrayscaleEnabled() (iOS)
		isInvertColorsEnabled() (iOS)
		isReduceMotionEnabled()
		isReduceTransparencyEnabled() (iOS)
		isScreenReaderEnabled()
		removeEventListener()
		setAccessibilityFocus()
2) Alert - 
	* Launches an alert dialog with the specified title and message.
	* Optionally provide a list of buttons. Tapping any button will fire the respective onPress callback and dismiss the alert. By default, the only button will be an 'OK' button.
	* This is an API that works both on Android and iOS and can show static alerts. Alert that prompts the user to enter some information is available on iOS only.
	* iOS - On iOS you can specify any number of buttons. Each button can optionally specify a style, available options are represented by the AlertButtonStyle enum.
	* Android - On Android at most three buttons can be specified. Android has a concept of a neutral, negative and a positive button:
		If you specify one button, it will be the 'positive' one (such as 'OK')
		Two buttons mean 'negative', 'positive' (such as 'Cancel', 'OK')
		Three buttons mean 'neutral', 'negative', 'positive' (such as 'Later', 'Cancel', 'OK')

	* Alerts on Android can be dismissed by tapping outside of the alert box. It is disabled by default and can be enabled by providing an optional Options parameter with the cancelable property set to true i.e.
	{ cancelable: true }.

	* The cancel event can be handled by providing an onDismiss callback property inside the options parameter.
	* Methods -
		alert()
		prompt() (iOS)
	* Type Definitions -
		AlertButtonStyle (iOS)
		AlertType (iOS)
		Buttons
		Options

3) Animatied -
	* The Animated library is designed to make animations fluid, powerful, and painless to build and maintain. Animated focuses on declarative relationships between inputs and outputs, configurable transforms in between, and start/stop methods to control time-based animation execution.
	* The core workflow for creating an animation is to create an Animated.Value, hook it up to one or more style attributes of an animated component, and then drive updates via animations using Animated.timing().
	Need More Time

4) Animated.Value -

5) Animated.ValueXY -

6) Appearance - 
	* The Appearance module exposes information about the user's appearance preferences, such as their preferred color scheme (light or dark).
	* Methods -
		getColorScheme()
		addChangeListener()
		removeChangeListener()

7) AppRegistry -
	* AppRegistry is the JS entry point to running all React Native apps. App root components should register themselves with AppRegistry.registerComponent, then the native system can load the bundle for the app and then actually run the app when it's ready by invoking AppRegistry.runApplication.
	* To "stop" an application when a view should be destroyed, call AppRegistry.unmountApplicationComponentAtRootTag with the tag that was passed into runApplication. These should always be used as a pair.
	* AppRegistry should be required early in the require sequence to make sure the JS execution environment is setup before other modules are required.
	* Methods -
		cancelHeadlessTask()
		enableArchitectureIndicator()
		getAppKeys()
		getRegistry()
		getRunnable()
		getSectionKeys()
		getSections()
		registerCancellableHeadlessTask()
		registerComponent()
		registerConfig()
		registerHeadlessTask()
		registerRunnable()
		registerSection()
		runApplication()
		setComponentProviderInstrumentationHook()
		setWrapperComponentProvider()
		startHeadlessTask()
		unmountApplicationComponentAtRootTag()
	* Type Definitions -
		AppConfig
		Registry
		Runnable
		Runnables
		Task
		TaskCanceller
		TaskCancelProvider
		TaskProvider

8) AppState -
	* AppState can tell you if the app is in the foreground or background, and notify you when the state changes.
	* AppState is frequently used to determine the intent and proper behavior when handling push notifications.
* App States -
	1) active - The app is running in the foreground
	2) background - The app is running in the background. 
		The user is either:
			in another app
			on the home screen
			[Android] on another Activity (even if it was launched by your app)
	3) [iOS] inactive - This is a state that occurs when transitioning between foreground & background, and during periods of inactivity such as entering the multitasking view, opening the Notification Center or in the event of an incoming call.
	4) Events -
		change
		memoryWarning
		focusAndroid
		blurAndroid
	5) Methods -
		addEventListener()
		removeEventListener()
	6) Properties -
		currentState

9) DevSettings -
	* The DevSettings module exposes methods for customizing settings for developers in development.
	* Methods -
		addMenuItem()
		reload()

10) Dimensions -
	* useWindowDimensions is the preferred API for React components. Unlike Dimensions, it updates as the window's dimensions update. This works nicely with the React paradigm.
	* import { Dimensions } from 'react-native';
	You can get the application window's width and height using the following code:
		const windowWidth = Dimensions.get('window').width;
		const windowHeight = Dimensions.get('window').height;
	* Although dimensions are available immediately, they may change (e.g due to device rotation, foldable devices etc) so any rendering logic or styles that depend on these constants should try to call this function on every render, rather than caching the value (for example, using inline styles rather than setting a value in a StyleSheet).
	* If you are targeting foldable devices or devices which can change the screen size or app window size, you can use the event listener available in the Dimensions module.
	* Methods -
		addEventListener()
		get()
		removeEventListener()
		set()
	* Type Definitions
		DimensionsValue
		DisplayMetrics

11) Easing -
	* The Easing module implements common easing functions. This module is used by Animated.timing() to convey physically believable motion in animations.
	* Predefined animations -
		The Easing module provides several predefined animations through the following methods:
			* back provides a basic animation where the object goes slightly back before moving forward
			* bounce provides a bouncing animation
			* ease provides a basic inertial animation
			* elastic provides a basic spring interaction
	* Standard functions -
		Three standard easing functions are provided:
			linear
			quad
			cubic
		The poly function can be used to implement quartic, quintic, and other higher power functions.
	* Additional Functions -
		Additional mathematical functions are provided by the following methods:
			* bezier provides a cubic bezier curve
			* circle provides a circular function
			* sin provides a sinusoidal function
			* exp provides an exponential function
		The following helpers are used to modify other easing functions.
			* in runs an easing function forwards
			* inOut makes any easing function symmetrical
			* out runs an easing function backwards
	* Methods -
		step0()
		step1()
		linear()
		ease()
		quad()
		cubic()
		poly()
		sin()
		circle()
		exp()
		elastic()
		back()
		bounce()
		bezier()
		in()
		out()
		inOut()


12) InteractionManager -
	* InteractionManager allows long-running work to be scheduled after any interactions/animations have completed. In particular, this allows JavaScript animations to run smoothly.
	* Need More time...
	* Method -
		runAfterInteractions()
		createInteractionHandle()
		clearInteractionHandle()
		setDeadline()

13) Keyboard -
	* Keyboard module to control keyboard events.
	* Method -
		addListener()
		removeListener()
		removeAllListeners()
		dismiss()
		scheduleLayoutAnimation

14) LayoutAnimation -
	* Automatically animates views to their new positions when the next layout happens.
	* A common way to use this API is to call it before updating the state hook in functional components and calling setState in class components.
	* Note that in order to get this to work on Android you need to set the following flags via UIManager:
		if (Platform.OS === 'android') {
		  if (UIManager.setLayoutAnimationEnabledExperimental) {
		    UIManager.setLayoutAnimationEnabledExperimental(true);
		  }
		}

	* Methods -
		configureNext()
		create()
	* Properties -
		Types
		Properties
		Presets
		easeInEaseOut
		linear
		spring

15) Linking -
	* Linking gives you a general interface to interact with both incoming and outgoing app links.
	* Every Link (URL) has a URL Scheme, some websites are prefixed with https:// or http:// and the http is the URL Scheme. Let's call it scheme for short.
	
	* In addition to https, you're likely also familiar with the mailto scheme. When you open a link with the mailto scheme, your operating system will open an installed mail application. Similarly, there are schemes for making phone calls and sending SMS. Read more about built-in URL schemes below.

	* Like using the mailto scheme, it's possible to link to other applications by using custom url schemes. For example, when you get a Magic Link email from Slack, the Launch Slack button is an anchor tag with an href that looks something like: slack://secret/magic-login/other-secret. Like with Slack, you can tell the operating system that you want to handle a custom scheme. When the Slack app opens, it receives the URL that was used to open it. This is often referred to as deep linking. Read more about how to get the deep link into your app.

	* Custom URL scheme isn't the only way to open your application on mobile. You don't want to use a custom URL scheme in links in the email because then the links would be broken on desktop. Instead, you want to use a regular https links such as https://www.myapp.io/records/1234546. and on mobile you want that link open your app. Android calls it Deep Links (Universal Links - iOS).

* Enabling Deep Links -
	Take help from directly official website

* Handling Deep Links
	There are two ways to handle URLs that open your app.

	1. If the app is already open, the app is foregrounded and a Linking 'url' event is fired
	You can handle these events with Linking.addEventListener('url', callback) - it calls callback({ url }) with the linked URL

	2. If the app is not already open, it is opened and the url is passed in as the initialURL
	You can handle these events with Linking.getInitialURL() - it returns a Promise that resolves to the URL, if there is one.

	* Methods -
		addEventListener()
		canOpenURL()
		getInitialURL()
		openSettings()
		openURL()
		removeEventListener()
		sendIntent()



16) PanResponder -
	* PanResponder reconciles several touches into a single gesture. It makes single-touch gestures resilient to extra touches, and can be used to recognize basic multi-touch gestures.
	Need More Time...

17) PixelRatio -
	* PixelRatio gives you access to the device's pixel density and font scale.
* Fetching a correctly sized image -
	1) You should get a higher resolution image if you are on a high pixel density device. A good rule of thumb is to multiply the size of the image you display by the pixel ratio.

	var image = getImage({
	  width: PixelRatio.getPixelSizeForLayoutSize(200),
	  height: PixelRatio.getPixelSizeForLayoutSize(100)
	});
	<Image source={image} style={{ width: 200, height: 100 }} />;

* Pixel grid snapping -
	Need More Time ...
	* Method -
		get()
		getFontScale()
		getPixelSizeForLayoutSize()
		roundToNearestPixel()

18) Platform -
	* Properties -
		constants
		isPadiOS
		isTV
		isTesting
		OS
		Version
	* Methods
		select()


19) PlatformColor -
	



20) RootTag -
	* RootTag is an opaque identifier assigned to the native root view of your React Native surface — i.e. the ReactRootView or RCTRootView instance for Android or iOS respectively. In short, it is a surface identifier.

21) Share -
	* Methods -
		share()
	* Properties
		sharedAction
		dismissedAction

22) StyleSheet -
	* A StyleSheet is an abstraction similar to CSS StyleSheets
	* Code quality tips:
		1) By moving styles away from the render function, you're making the code easier to understand.
		2) Naming the styles is a good way to add meaning to the low level components in the render function.
	* Method -
		compose()
		create()
		flatten()
		setStyleAttributePreprocessor()
	* Properties -
		absoluteFill
		absoluteFillObject
		hairlineWidth
		absoluteFill vs. absoluteFillObject

23) Systrace -
	* Systrace is a standard Android marker-based profiling tool (and is installed when you install the Android platform-tools package). Profiled code blocks are surrounded by start/end markers which are then visualized in a colorful chart format. Both the Android SDK and React Native framework provide standard markers that you can visualize.
	* Method -
		installReactHook()
		setEnabled()
		isEnabled()
		beginEvent()
		endEvent()
		beginAsyncEvent()
		endAsyncEvent()
		counterEvent()

24) Transforms -
	Transforms are style properties that will help you modify the appearance and position of your components using 2D or 3D transformations. However, once you apply transforms, the layouts remain the same around the transformed component hence it might overlap with the nearby components. You can apply margin to the transformed component, the nearby components or padding to the container to prevent such overlaps.

25) Vibration -
	Vibrates the device.
	* Method -
		cancel()
		vibrate()


B) Hooks -
1) useColorScheme -
	The useColorScheme React hook provides and subscribes to color scheme updates from the Appearance module. The return value indicates the current user preferred color scheme. The value may be updated later, either through direct user action (e.g. theme selection in device settings) or on a schedule (e.g. light and dark themes that follow the day/night cycle).
2) useWindowDimensions -
	* useWindowDimensions automatically updates width and height values when screen size changes. You can get your application window's width and height like so:

	const { height, width } = useWindowDimensions();

	* Properties -
		fontScale
		height
		scale
		width



C) Android APIs -
1) Backhandler -
	* The Backhandler API detects hardware button presses for back navigation, lets you register event listeners for the system's back action, and lets you control how your application responds. It is Android-only.
	* The event subscriptions are called in reverse order (i.e. the last registered subscription is called first).
		1) If one subscription returns true, then subscriptions registered earlier will not be called.
		2) If no subscription returns true or none are registered, it programmatically invokes the default back button functionality to exit the app.
	* Methods
		addEventListener()
		exitApp()
		removeEventListener()

2) PermissionsAndroid -
	* PermissionsAndroid provides access to Android M's new permissions model. The so-called "normal" permissions are granted by default when the application is installed as long as they appear in AndroidManifest.xml. However, "dangerous" permissions require a dialog prompt. You should use this module for those permissions.
	* On devices before SDK version 23, the permissions are automatically granted if they appear in the manifest, so check should always result to true and request should always resolve to PermissionsAndroid.RESULTS.GRANTED.

	* Permissions that require prompting the user
	Available as constants under PermissionsAndroid.PERMISSIONS:

	READ_CALENDAR: 'android.permission.READ_CALENDAR'
	WRITE_CALENDAR: 'android.permission.WRITE_CALENDAR'
	CAMERA: 'android.permission.CAMERA'
	READ_CONTACTS: 'android.permission.READ_CONTACTS'
	WRITE_CONTACTS: 'android.permission.WRITE_CONTACTS'
	GET_ACCOUNTS: 'android.permission.GET_ACCOUNTS'
	ACCESS_FINE_LOCATION: 'android.permission.ACCESS_FINE_LOCATION'
	ACCESS_COARSE_LOCATION: 'android.permission.ACCESS_COARSE_LOCATION'
	ACCESS_BACKGROUND_LOCATION: 'android.permission.ACCESS_BACKGROUND_LOCATION'
	RECORD_AUDIO: 'android.permission.RECORD_AUDIO'
	READ_PHONE_STATE: 'android.permission.READ_PHONE_STATE'
	CALL_PHONE: 'android.permission.CALL_PHONE'
	READ_CALL_LOG: 'android.permission.READ_CALL_LOG'
	WRITE_CALL_LOG: 'android.permission.WRITE_CALL_LOG'
	ADD_VOICEMAIL: 'com.android.voicemail.permission.ADD_VOICEMAIL'
	USE_SIP: 'android.permission.USE_SIP'
	PROCESS_OUTGOING_CALLS: 'android.permission.PROCESS_OUTGOING_CALLS'
	BODY_SENSORS: 'android.permission.BODY_SENSORS'
	SEND_SMS: 'android.permission.SEND_SMS'
	RECEIVE_SMS: 'android.permission.RECEIVE_SMS'
	READ_SMS: 'android.permission.READ_SMS'
	RECEIVE_WAP_PUSH: 'android.permission.RECEIVE_WAP_PUSH'
	RECEIVE_MMS: 'android.permission.RECEIVE_MMS'
	READ_EXTERNAL_STORAGE: 'android.permission.READ_EXTERNAL_STORAGE'
	WRITE_EXTERNAL_STORAGE: 'android.permission.WRITE_EXTERNAL_STORAGE'
	BLUETOOTH_CONNECT: 'android.permission.BLUETOOTH_CONNECT'
	BLUETOOTH_SCAN: 'android.permission.BLUETOOTH_SCAN'
	BLUETOOTH_ADVERTISE: 'android.permission.BLUETOOTH_ADVERTISE'
	ACCESS_MEDIA_LOCATION: 'android.permission.ACCESS_MEDIA_LOCATION'
	ACCEPT_HANDOVER: 'android.permission.ACCEPT_HANDOVER'
	ACTIVITY_RECOGNITION: 'android.permission.ACTIVITY_RECOGNITION'
	ANSWER_PHONE_CALLS: 'android.permission.ANSWER_PHONE_CALLS'
	READ_PHONE_NUMBERS: 'android.permission.READ_PHONE_NUMBERS'
	UWB_RANGING: 'android.permission.UWB_RANGING'
	BODY_SENSORS_BACKGROUND: 'android.permission.BODY_SENSORS_BACKGROUND'
	READ_MEDIA_IMAGES: 'android.permission.READ_MEDIA_IMAGES'
	READ_MEDIA_VIDEO: 'android.permission.READ_MEDIA_VIDEO'
	READ_MEDIA_AUDIO: 'android.permission.READ_MEDIA_AUDIO'
	POST_NOTIFICATION: 'android.permission.POST_NOTIFICATIONS'
	NEARBY_WIFI_DEVICES: 'android.permission.NEARBY_WIFI_DEVICES'
	READ_VOICEMAIL: 'com.android.voicemail.permission.READ_VOICEMAIL',
	WRITE_VOICEMAIL: 'com.android.voicemail.permission.WRITE_VOICEMAIL',

	* Result strings for requesting permissions
	Available as constants under PermissionsAndroid.RESULTS:

	GRANTED: 'granted'
	DENIED: 'denied'
	NEVER_ASK_AGAIN: 'never_ask_again'

	* Method -
	constructor()
	check()
	request()
	requestMultiple()


3) ToastAndroid -
	* React Native's ToastAndroid API exposes the Android platform's ToastAndroid module as a JS module. It provides the method show(message, duration) which takes the following parameters:
		message A string with the text to toast
		duration The duration of the toast—either ToastAndroid.SHORT or ToastAndroid.LONG
	* You can alternatively use showWithGravity(message, duration, gravity) to specify where the toast appears in the screen's layout. May be ToastAndroid.TOP, ToastAndroid.BOTTOM or ToastAndroid.CENTER.
	* The 'showWithGravityAndOffset(message, duration, gravity, xOffset, yOffset)' method adds the ability to specify an offset with in pixels.
	* Methods
		show()
		showWithGravity()
		showWithGravityAndOffset()
	* Properties
		SHORT
		LONG
		TOP
		BOTTOM
		CENTER


D) iOS APIs -
1) ActionSheetIOS -
	* Displays native to iOS Action Sheet component.
	* Methods
	showActionSheetWithOptions()
	dismissActionSheet()
	showShareActionSheetWithOptions()

2) DynamicColorIOS - 
	* The DynamicColorIOS function is a platform color type specific to iOS.
	DynamicColorIOS({
	  light: color,
	  dark: color,
	  highContrastLight: color, // (optional) will fallback to "light" if not provided
	  highContrastDark: color // (optional) will fallback to "dark" if not provided
	});
	* DynamicColorIOS takes a single argument as an object with two mandatory keys: dark and light, and two optional keys highContrastLight and highContrastDark. These correspond to the colors you want to use for "light mode" and "dark mode" on iOS, and when high contrast accessibility mode is enabled, high contrast version of them.
	* At runtime, the system will choose which of the colors to display depending on the current system appearance and accessibility settings. Dynamic colors are useful for branding colors or other app specific colors that still respond automatically to system setting changes.

3) Settings -
	* Settings serves as a wrapper for NSUserDefaults, a persistent key-value store available only on iOS.
	* Methods
		clearWatch()
		get()
		set()
		watchKeys()
------------------------------------------------------------------------------------------------



Interview Questions

1) flatlist optimization = https://reactnative.dev/docs/optimizing-flatlist-configuration
	removeClippedSubviews, maxToRenderPerBatch, updateCellsBatchingPeriod, initialNumToRender, windowSize, Use basic components, Use light components, Use shouldComponentUpdate, Use cached optimized images, Use getItemLayout, Use keyExtractor or key, Avoid anonymous function on renderItem
2) optimization in react = https://blog.codemagic.io/improve-react-native-app-performance/
use flatlist or sectionlist, Avoid Passing Inline Functions as Props, Scale and Resize Images, Cache Images, Avoid Updating state or dispatch Actions in componentWillUpdate, Avoid Rendering Overhead and Unnecessary Renders, Hermes, Avoid Arrow Functions, Use Style References Correctly, Remove Console Statements, Make Use of Uncontrolled Inputs




Important Websites -
https://reactnative.directory/
https://www.reactnative.guide/

------------------------------------------------------------------------------------------------
Architecture -

Metro - acts as JS bundler, manages assets, caches, builds and perform hot module reloading.


RN use 3 threads -

Platform UI - create UI using native manager

Shadow Thread- 
	* uses Fabric Architecture
	* create layout and calculate width and height. create copy of react tree, hence it called shadow thread.
	* uses yoga layout engine

JS thread- 
	* js thread uses compiler called "JSC" previously, now we can also use "v8" or "hermes" also, to run JS code.
	* contain all JS logic and business logic
	* declaratively told react to add element, react does reconcilation and perform actions.

-------------------------------------------------------------------------------------------------------------

============================================================================================================

--------------------------------Architecture Explained by Parshuram N-------------------------------------


React Native's New Architecture - Parashuram N - React Conf 2018 
* We declaratively tells react to add node. React does its magic of reconcillation, figures out that whether we need dom operations or not and did it. we don't need to worry about it.
* react holds a ref to the dom, that we created. so using that ref, we can add style or attribute in web.
* Diffn between react and react native - 
	in RN, we can connect two realms called "JS realm" and "android or IOS realm".

----------------
About Old Architecture -
RN bridge -
* 1 more diff, in RN, we don't have any nodes ref of native element in JS realm. so we cannot call any methods using those nodes.
* Hence, communicating within two realm, we do have 1 bridge, called "RN bridge". It passes message within these two realm.
* Suppose, lets create node in RN. It grab all required data in Array, serialize it as string and simply pass it.

Shadow thread (Shadow tree)-
* android and IOS has different layout system, so to ensure, it works in all devices, RN implement its own version of "flexbox" in a library called "yoga".
* For Yoga, inputs are style and output is relative positions of where each elements should be structured.
* once layout done, it sends all data to UI layer as serialized JSON array. Then UI draws all of it.


RN has 3 main threads -

Platform UI (UI Layer/ Android UI) - 
* here, all scrolling, and view rendering happens
* Android thread most of time empty, so it can respond to our request immediately.

Shadow Tree (Layout Thread / Shadow thread) - 
* here, all layout and its calculations happens.
* in Layout, it create copy of react tree in Shadow thread, hence it call "Shadow tree".

JS Thread -
* Here, all react, business logic code worked.
* Most heavy operations happened in JS thread.


Summary -
* UI updates, JS and Layout operations run on separate threads.
* communication between thread is asynchronous.
* RN is asynchronous with old architecture.
----------------

Issues with old architecture -
* cannot cancel events.
* on fast scrolling, sometime we can face blank space, bcz of asynchronous nature of JS thread and its not in sync with main thread.

----------------
About New Architecture -
* To solve our problem, lets looks at browser implementation in web. Layout engine (part of browser) create node element using native OS. 
* While creating element, we get object "HTMLinputelement" from browser using layout engine. it has ref to element.

JSI -
* like browser, we will create node with ref to that native element. So we have ref of element. Now, we don't need bridge and passing message throught that bridge.
* communicate betn JS and Java/ObjC
* Host objects in C++ expose methods and variables to JS
* JS holds references to hostObjects ( similar to HTMLinputelement), can call methods on them.
* Based on JSI, we build next generations of RN "view managers" and "native modules".

Fabric -
* Here, it shows how "fabric" UI manager, manages async as well as synchronus call.

Native Module -
* Using JSI, we can make available hostObjects to JS realm. so we can call methods of native modules directly from JS realm.
* Hence, this kind of native module, we called turbo module.
* getModule(moduleName) to get a JSI Host Object.
* call Methods on Host Object.
* values returned in functions can also be host objects.

Core Community - 
* ex. webview removed from react-native and move it to core-community. it help to slim react native and upgrading react native.


Block Diagram  - 


JSC - JavaScriptCore runs the bundle when the user starts the app.
V8 engine for react native- microsoft working on it.

----------------------------------------Explaination Ends Here----------------------------------------------

New Architecture image link - https://existek.com/blog/react-native-app-development/
Fabric Explanation - https://www.linkedin.com/pulse/react-native-new-architecture-rishabh-yadav-gd8dc

Artcile link - 1 more explanation about architecture - https://litslink.com/blog/new-react-native-architecture

Article Link - https://www.reactnative.guide/3-react-native-internals/3.1-react-native-internals.html

Article Link - https://collectivemind.dev/blog/react-native-re-architecture

Article Link - https://deepstash.com/idea/148397/the-new-flow

https://medium.com/coox-tech/deep-dive-into-react-natives-new-architecture-fb67ae615ccd
https://engineering.fb.com/2019/07/12/android/hermes/




Old architecture - 
1) Metro - Metro is a development platform for React Native. This project acts as a JavaScript bundler; it manages assets, caches builds and performs hot module reloading.

2) JSC - the JavaScriptCore runs the bundle when the user starts the app.
React Native needs an engine to run JavaScript code on mobile devices. Apple includes JavaScriptCore (JSCore) on iOS devices, but Android does not have a JavaScript engine.
So React Native included a version of JSCore in Android builds to execute JavaScript.
This resulted in larger Android application packages (APKs) for React Native apps, and some noticeable performance issues.

In 2019, the React Native team announced Hermes as “a new JavaScript engine optimized for React Native.” Android apps built with React Native and Hermes were smaller, interactive faster, and used less memory.

3) Flipper - used for debugging purpose.It comes with a variety of useful features, which makes it easier for developers to spot vulnerabilities and fix them quickly.

Turbo
Controlled components
Uncontrolled components



New architecture -
1) React Native CodeGen -
CodeGen will utilise your TypeScript/Flow types to generate more native code at build time, instead of run time. TL:DR: smaller code size, faster execution, fewer errors.
The Codegen is typically invoked at build time, but you may find it useful to generate your native interface code on demand for troubleshooting.

2) Hermes -
Hermes, which is a JavaScript engine specially optimized for running apps on Android. Its update resulted in reduced start-up time, optimized app size, and better performance.

3) Yoga - available for both architecture.
Layout is an important part of building user interfaces for any mobile, desktop, or web application, because it describes the size and position of views on the screen and their relationship to one another.


4) JSI -
One more advantage brought by JSI is the entire synchronization of JS thread and native modules. With the help of the JavaScriptInterface, JS will be able to hold reference to Host Objects and invoke methods on them. It will also come with a concept of shared ownership, allowing the native side to communicate directly with the JS thread.


5) Fabric -
Fabric is basically a re-architecture of the UI manager, which is expected to transform the rendering layer by eliminating the need in bridges. The new approach allows creating the Shadow Tree right in C++ that brings swiftness to the process and reduces the number of steps necessary to render a particular element.


6) Turbo Modules -
Turbomodules are basically the old Native modules, but implemented and behaving differently.
The best thing about Turbomodules is that they’re lazy loaded, meaning the Javascript code is going to load each module only when it’s needed and hold a direct reference to it. This can significantly improve startup time for apps with lots of Native modules.

============================================================================================================
react native uses fiber architecture?

React Fiber:
This is the core reconciliation algorithm used by both React and React Native. It allows for incremental rendering, which means that React can break down the rendering process into smaller chunks and spread them out over multiple frames. This results in smoother UI updates and better performance, especially for complex applications.
React Native Renderer:
This is the specific implementation of the renderer for React Native. It takes the Fiber tree generated by the reconciler and translates it into native UI elements for the target platform (iOS or Android).
New Architecture (Fabric):
The New Architecture in React Native further improves performance and interoperability with native components. It uses the JavaScript Interface (JSI) to enable direct communication between JavaScript and native code, eliminating the need for the bridge used in older versions of React Native. This makes the integration of native modules more seamless and efficient.

============================================================================================================


React Native CLI comes with following commands:

bundle
clean
config
doctor
init
info
log-android
log-ios
ram-bundle
run-android
run-ios
start
upgrade
profile-hermes


1) 	bundle
	
	react-native bundle <flag>
	Builds the JavaScript bundle for offline use.

	--entry-file <path>
	Path to the root JS file, either absolute or relative to JS root.

	--platform <string>
	default: ios

	Either "ios" or "android".

	--transformer <string>
	Specify a custom transformer to be used.

	--dev [boolean]
	default: true

	If false, warnings are disabled and the bundle is minified.

	--minify [boolean]
	Allows overriding whether bundle is minified. This defaults to false if dev is true, and true if dev is false. Disabling minification can be useful for speeding up production builds for testing purposes.

	--bundle-output <string>
	File name where to store the resulting bundle, ex. /tmp/groups.bundle.

	If you are planning on building a debug APK, that will run without the packager, by invoking ./gradlew assembleDebug you can simply set bundleInDebug: true in your app/build.gradle file, inside the project.ext.react map.

	Details
	--bundle-encoding <string>
	default: utf8

	Encoding the bundle should be written in (https://nodejs.org/api/buffer.html#buffer_buffer).

	--max-workers <number>
	Specifies the maximum number of workers the worker-pool will spawn for transforming files. This defaults to the number of the cores available on your machine.

	--sourcemap-output <string>
	File name where to store the sourcemap file for resulting bundle, ex. /tmp/groups.map.

	--sourcemap-sources-root <string>
	Path to make sourcemap sources entries relative to, ex. /root/dir.

	--sourcemap-use-absolute-path
	default: false

	Report SourceMapURL using its full path.

	--assets-dest <string>
	Directory name where to store assets referenced in the bundle.

	If you are planning on building a debug APK that will run without the packager, see (--bundle-output)

	Details
	--reset-cache
	default: false

	Removes cached files.

	--read-global-cache
	default: false

	Try to fetch transformed JS code from the global cache, if configured.

	--config <string>
	Path to the CLI configuration file.


2) clean

	react-native clean
	Cleans caches. Commonly used to ensure build failures are not due to stale cache. By default, it will prompt which caches to purge, with Watchman and Metro already checked. To omit interactive prompt (e.g. in scripts), please use --include flag.

	Options
	--include <string>
	Comma-separated flag of caches to clear e.g. npm,yarn. If omitted, an interactive prompt will appear. Valid values include android, cocoapods, metro, npm, watchman, and yarn.

	--project-root <string>
	default: current working directory

	Root path to your React Native project. When not specified, defaults to current working directory.

	--verify-cache
	default: false

	Whether to verify the cache. Currently only applies to npm cache.


3) config -

	react-native config
	Output project and dependencies configuration in JSON format to stdout. Used by autolinking.

	doctor
	Usage:

	react-native doctor
	[EXPERIMENTAL] Diagnose and fix common Node.js, iOS, Android & React Native issues.



4) init -

	Available since 0.60.0

	IMPORTANT: Please note that this command is not available through react-native-cli, hence you need to either invoke it directly from @react-native-community/cli or react-native package which proxies binary to this CLI since 0.60.0, so it's possible to use it with e.g. npx.

	Usage (with npx):

	npx react-native init <projectName> [options]
	Initialize a new React Native project named in a directory of the same name. You can find out more use cases in init docs.

	Options
	--version <string>
	Shortcut for --template react-native@version.

	--directory <string>
	Uses a custom directory instead of <projectName>.

	--title <string>
	Uses a custom app title instead of <projectName>.

	--template <string>
	Uses a custom template. Accepts following template sources:

	an npm package name
	an absolute path to a local directory
	an absolute path to a tarball created using npm pack
	link to a GitHub repository (supports username/repo format)
	Example:

	npx react-native init MyApp --template react-native-custom-template
	npx react-native init MyApp --template file:///Users/name/template-path
	npx react-native init MyApp --template file:///Users/name/template-name-1.0.0.tgz
	npx react-native init MyApp --template Esemesek/react-native-new-template
	A template is any directory or npm package that contains a template.config.js file in the root with the following type:

	type Template = {
	  // Placeholder used to rename and replace in files
	  // package.json, index.json, android/, ios/
	  placeholderName: string;
	  // Directory with template
	  templateDir: string;
	  // Path to script, which will be executed after init
	  postInitScript?: string;
	  // Placeholder used to rename app title inside values.xml and Info.plist
	  titlePlaceholder?: string;
	};
	Example template.config.js:

	module.exports = {
	  placeholderName: 'ProjectName',
	  titlePlaceholder: 'Project Display Name',
	  templateDir: './template',
	  postInitScript: './script.js',
	};
	--skip-install
	Skip dependencies installation

	--npm
	Force use of npm during initialization


5) info -

	react-native info
	Get relevant version info about OS, toolchain and libraries. Useful when sending bug reports.


6) log-android -

	react-native log-android
	Starts logkitty displaying pretty Android logs.



7) log-ios - 

	react-native log-ios
	Starts iOS device syslog tail.



8) ram-bundle -

	react-native ram-bundle [options]
	Builds JavaScript as a "Random Access Module" bundle for offline use.

	Options
	Accepts all of bundle commands and following:

	--indexed-ram-bundle
	Force the "Indexed RAM" bundle file format, even when building for Android.


9) run-android

	react-native run-android [options]
	Builds your app and starts it on a connected Android emulator or device.

	Options
	--root <string>
	DEPRECATED – root is discovered automatically

	Override the root directory for the Android build (which contains the android directory)'.

	--variant <string>
	default: 'debug'

	Specify your app's build variant.

	--appFolder <string>
	DEPRECATED – use "project.android.appName" in react-native.config.js

	default: 'app'

	Specify a different application folder name for the Android source. If not, we assume is "app".

	--appId <string>
	Specify an applicationId to launch after build. If not specified, package from AndroidManifest.xml will be used.

	--appIdSuffix <string>
	Specify an applicationIdSuffix to launch after build.

	--main-activity <string>
	default: 'MainActivity'

	Name of the activity to start.

	--deviceId <string>
	builds your app and starts it on a specific device/simulator with the given device id (listed by running "adb devices" on the command line).

	--no-packager
	Do not launch packager while building.

	--port <number>
	default: process.env.RCT_METRO_PORT || 8081

	--terminal <string>
	default: process.env.REACT_TERMINAL || process.env.TERM_PROGRAM

	Launches the Metro Bundler in a new window using the specified terminal path.

	--tasks <list>
	default: 'installDebug'

	Run custom gradle tasks. If this argument is provided, then --variant option is ignored. Example: yarn react-native run-android --tasks clean,installDebug.

	--active-arch-only
	default: false

	Build native libraries only for the current device architecture for debug builds.

10) run-ios
	Usage:

	react-native run-ios [options]
	Builds your app and starts it on iOS simulator.

	Options
	--simulator <simulator_name>
	default: iPhone 11

	Explicitly set the simulator to use. Optionally include iOS version between parenthesis at the end to match an exact version, e.g. "iPhone 6 (10.0)".

	Notes: If selected simulator does not exist, cli will try to run fallback simulators in following order:

	iPhone X
	iPhone 8
	Notes: simulator_name must be a valid iOS simulator name. If in doubt, open your AwesomeApp/ios/AwesomeApp.xcodeproj folder on XCode and unroll the dropdown menu containing the simulator list. The dropdown menu is situated on the right hand side of the play button (top left corner).

	Example: this will launch your project directly onto the iPhone XS Max simulator:

	react-native run-ios --simulator "iPhone XS Max"
	--configuration <string>
	Explicitly set the scheme configuration to use default: 'Debug'.

	--scheme <string>
	Explicitly set Xcode scheme to use.

	--device [string]
	Explicitly set device to use by name. The value is not required if you have a single device connected.

	--udid <string>
	Explicitly set device to use by udid.

	--no-packager
	Do not launch packager while building.

	--verbose
	Do not use xcbeautify or xcpretty even if installed.

	--port <number>
	Runs packager on specified port

	Default: process.env.RCT_METRO_PORT || 8081

	--xcconfig <string>
	Explicitly pass xcconfig options from the command line

	start
	Usage:

11) react-native start [option]
	Starts the server that communicates with connected devices

	Options
	--port <number>
	Specify port to listen on

	--projectRoot <path>
	Path to a custom project root

	--watchFolders <list>
	Specify any additional folders to be added to the watch list

	--assetPlugins <list>
	Specify any additional asset plugins to be used by the packager by full filepath

	--sourceExts <list>
	Specify any additional source extensions to be used by the packager

	--max-workers <number>
	Specifies the maximum number of workers the worker-pool will spawn for transforming files. This defaults to the number of the cores available on your machine

	--transformer <string>
	Specify a custom transformer to be used

	--reset-cache, --resetCache
	Removes cached files

	--custom-log-reporter-path, --customLogReporterPath <string>
	Path to a JavaScript file that exports a log reporter as a replacement for TerminalReporter

	--https
	Enables https connections to the server

	--key <path>
	Path to custom SSL key

	--cert <path>
	Path to custom SSL cert

	--config <string>
	Path to the CLI configuration file

	--no-interactive
	Disables interactive mode

	upgrade
	Usage:

12) react-native upgrade [npm-version]
	Upgrade your app's template files to the specified or latest npm version using rn-diff-purge project. Only valid semver versions are allowed.

	Using this command is a recommended way of upgrading relatively simple React Native apps with not too many native libraries linked. The more iOS and Android build files are modified, the higher chance for a conflicts. The command will guide you on how to continue upgrade process manually in case of failure.

	Note: If you'd like to upgrade using this method from React Native version lower than 0.59.0, you may use a standalone version of this CLI: npx @react-native-community/cli upgrade.

	profile-hermes
	Usage:

	react-native profile-hermes [destinationDir] <flag>
	Pull and convert a Hermes tracing profile to Chrome tracing profile, then store it in the directory of the local machine.

	destinationDir is optional, if provided, pull the file to that directory
	default: pull to the current React Native app root directory

	Options
	--filename <string>
	File name of the profile to be downloaded, eg. sampling-profiler-trace8593107139682635366.cpuprofile.

	default: pull the latest file

	--raw
	Pulls the original Hermes tracing profile without any transformation

	--sourcemap-path <string>
	The local path to your source map file if you generated it manually, ex. /tmp/sourcemap.json

	--generate-sourcemap
	Generate the JS bundle and source map in os.tmpdir()

	--port <number>
	The running metro server port number

	default: 8081

	--appId <string>
	Specify an applicationId to launch after build. If not specified, package from AndroidManifest.xml will be used.

	--appIdSuffix <string>
	Specify an applicationIdSuffix to launch after build.

	Notes on source map
	This step is recommended in order for the source map to be generated:

	If you are planning on building a debug APK, that will run without the packager, by invoking ./gradlew assembleDebug you can simply set bundleInDebug: true in your app/build.gradle file, inside the project.ext.react map.


----------------------------------------------------------------------------------



Features - 
LMNTT and many more -
Language can change (instructions, article and its content, categories and subcategories), Mode day and night, Notification setup and subscribe, Text to speech, Font Size change, Google Analytics for each article, photo and video ( gives realtime analytics), admob for ads, links support for (dynamic links, deep links and website links), able to bookmark and favourite articles, share article across any app, change city and it will change articles list as per current city

Issues faced -
1) lots of people uses multiple brands of mobile. so sometime we got error while working with another unusual device, so i try to find that device if it's available with my colleagues and test it. Or else I used symbolication

2) project got bigger, every time it takes so much time to create build, so I used react-native run-android --active-arch-only ( while developing ) and 
$ ./gradlew :app:assembleDebug -PreactNativeArchitectures=x86,x86_64 (while building). 
	Earlier I used in app/build.gradle > android > splits > abi, 
		enable enableSeparateBuildPerCPUArchitecture
            	universalApk true  // If true, also generate a universal APK
            	include "armeabi-v7a", "x86"

3) as application grows, complexity grows. it started giving performance issue with Application. solved by applying measures

4) While loading article list, we download partial content within body property. In article page, we have to show complete article. When we open first time, it took some time to download content. Hence webview not render enough height for content. It render only required height which partial content which comes while fetching list. once whole content comes, we have to readjust height. So we didn't get any plugin which help us. so for that, I wrote custom JS script and added that to Webview. so on loading, it readjust its height. and also added handler to open links which comes within content.

* closing app abruptly after clicking multiple articles in short span of time

5) issue with library linking with older version of RN. It was complex process earlier.

6) In IOS, some .h or .m file not found OR Pod related errors, took help from online community
