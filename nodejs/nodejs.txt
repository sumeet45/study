
359) What are Rest api and why do we use them? -
* In recent times, we want only data (JSON, XML) instead of HTML page, when we fetch data from our web application or mobile app or anything else.


360) Accessing data with Rest API's -
* accessing data with Rest API, will be possible in following ways - HTML, plain text, XML, JSON


----------------- 
tony alicea node js course 

1) Introduction and the Goal of this Course
* we will go under the hood in nodejs.
* Don't Imitate, understand
* v8 engine

2) Big Words and NodsJS
* big words are having simple meaning, just understand that first. 

4) Conceptual Aside: The Command Line Interface
* CLI - terminal or interface, where you type commands to computer rather than clicking around the mouse.
* there are multiple CLI commands, using those we can give commands to computer.
* bash on linux, terminal on mac, command prompt on windows
* While working with nodejs, we need to do work more with CLI
* showed commands - ls, cd folderName, dir /w /p
* showed powershell also

5) Command Line Reference
https://developer.mozilla.org/en-US/docs/Learn_web_development/Getting_started/Environment_setup/Command_line


7) Conceptual Aside: Processors, Machine Language, and C++
* v8 engine is core part of nodejs
* MicroProcessor - small machine, and gives the output based on input. MicroProcessor speaks language. 
* But all MicroProcessor speak different languages. languages - IA -32, x86-64, ARM, MIPS and etc. These languages called "Machine Code"
* Machine Code (languages) - Programming languages spoken by computer Processors. Every program you run on your computer has been converted into Machine code.
* hierarchy - Javascript > c/c++ > Assembly Language > Machine Language
* Node is written in C++
* v8 is written in C++
* Node is wrapper around v8 engine. hence both are written in c++

8) Javascript Aside: Javascript Engines, and The EcmaScript specifications -
* EcmaScript - It is standard that Javascript is based on.
* JS invented first. but all browser create changes in JS as per their requirement. Then Ecma is org that basically give standards to JS.
* JS engine - a program that converts JS code into something the computer Processors can understand. It should follow ECMAscript standard on how the language should work and what features it should have.

9) v8 under the hood -
* v8 written for chrome browser
* showing v8 github repo and downloaded also. showed respective folder for each machine language. shows some .h and .cc files.
* this engine code written in c++, convert it to machine code.

10) Adding features to Javascript - 
* v8 can run standalone, or can be embedded into any c++ application.
* so we can create c++ programm and add v8 engine to it. using this, we can add extra features to JS. c++ is far bigger and have more control compared to JS
* he created 1 programm and add v8 to it. then he run JS code and it shows output. Even he uses different argument also which print actual c++ code also.
    shell --print_code  (to show machine code)


11) Conceptual Aside: Servers and Clients
* Nodejs is server technology, and designed to write server code using JS.
* server is computer that is performing services. client ask data from server. so server do big amount of work.
* client request data in standard format. and then server sends response in standard format. This is called "client-server model of computing"
* webserver - it is computer which is connected to internet and taking requests from client through internet. 
* The standard, which shapes request and response, is called "HTTP"
* we are aiming to write server and client code using Javascript

12) What does Javascript Need to Manage a server?
* Need things in JS -
    1. better ways to organize our code into reusable pieces
    2. ways to deal with files
    3. ways to deal with databases
    4. The ability to Communicate Over the Internet
    5. The ability to Accept request and send response (in standard format)
    6. way to deal with long time taking work

13) The c++ core -
* showing github repo of node. Node js developed by Ryan Dahl under joyent company

14) The Javascript Core -
* In nodejs code, they have JS code too to access c++ feature. These JS code are actually wrapper around c++ features.

16) Lets install and Run some Javascript in Node
* install nodejs process.
* it also install npm
* to check node is installed or not. using  node -v
* we can type command  "node" and create enviornment which Accept JS code and gives output.
* we can run file using node command - node app.js
* showing debug in VS code.
* breakpoint - a spot in our code where we tell a debugging tool to pause the execution of our code. so we can figure out what's going on.
* shows how debugging activated in VS code

17) LTS vs current
* LTS - long term support. LTS version are stable one. prefer LTS over current. current might fail.


19) Modules -
* Moduels - a reusable block of code whose existence does not accidentally impact other code. JS didn't have this before.
* Module wasn't part of JS, newly introduced. Using this, code in module doesn't impact other code. 
* Node js implements CommonJS modules. 
* Common JS modules - An agreed upon standard for how code modules should be structured.

20) Javascript Aside: First Class Functions and Function expression
* First Class function - Everything you can do with other types you can do with functions. You can use functions like strings, numbers, etc.( i.e. pass them around, set variables equal to them, put them in arrays and so on). it allows to write Function expression.
* Function expression - A block of code that results in a value. Function expressions are possible in Javascript because functions are first class.
* Invoke function -  call function
* Function is actually special kind of object.
* pass them around example - 
function ab(){
    console.log("Hello");
}
function bc(a){
    a();
}
bc(ab);
* set function to variable -
var greetMe = function(){
    console.log("hellow");
}
* use a function expression on the fly
logGreeting(function(){
    console.log("Hello sumeet");
})

21) Let's build a module
* Using Module, we can separate code as per functionality and manage properly.
* using "require" function, we can pull code in current codebase.
    require("./greet.js");      // ./ means same folder level
* to make code accessible in other file, we need to export first.
    module.exports = {
        greet: greetFn
    }
    var greet = require("./greet.js");
    greet.greetFn();


Note -
Q. How engine resolve module in ES6 import export
-   1 In ES6 import export, engine first went through each module and create dependancy graph in compile time.
    2 Engine then resolve and links all imports/exports before executing anything

* In ES6 modules, imports are live bindings, not copies.


22) Javascript Aside: Objects and Objects Literal 
* object - name value pair. name which maps to value. The name may be defined more than once in different context, but only can have one value in any given context. value can be other name-value pair.
* value can be anything like primitive "property", object "property", Function "method"
* object literal - name/value pairs separated by commas and surrounded by curly braces. This is quick, shorthand way to create Javascript objects in code.
* let person  = {
    fname: "sumee",
    lname: "shedge",
    greet: function(){
        console.log(`Hello ${this.fname} ${this.lname}`);
    }
}
person.greet();
console.log(person["fname"]);

23) JS Aside: Prototypal inheritance and Function Constructors
* Inheritance - one object gets access to the properties and methods of another object.
* JS implements Prototypal inheritance.
* Every object have its prototype object. Using that, we can access different objects properties. It means whenever object created using Function Constructors, using prototype inheritance we can access other object properties in object.
* Class - this is new ES6 feature
* Function Constructors - Within node, we will use Function Constructors. A normal Function that is used to construct objects. The "this" variable points a new empty object, and that object is returned from the function automatically. And we do this by using "new" keyword.
* To create object from function, we write function looks like below. It return new empty object and "this" keyword will point to that empty object. And within function, we add properties and methods, which get attached to new object.
ex. 
    function Person(fname, lname){
        this.lname = fname;
        this.fname = lname;
    }

    // create prototype inheritance
    Person.prototype.greet = function(){
        console.log(`Hello ${this.fname} ${this.lname}`);
    }
    var ab = new Person("sumeet", "shedge");
    ab.greet();
    var bc = new Person("sumeet1", "shedge");
    bc.greet();

    console.log(ab.__proto__);
    console.log(bc.__proto__);
    console.log(ab.__proto__ === bc.__proto__);     //true
* Here, Person.prototype is not prototype for function actually, it is for objects which created using that function through funciton constructor. 


24) Javascript Aside: By Reference and By Value -
* primitive - a type of data that represents single value. Like a number or a string. In other words, not an object.
* By value - Whenever we pass value to function or create variable using another one, it create using by value. it means, new variable or argument will create new memory location with value and it will point to that.
    b = a (or pass to a function)
    // so if "a" changes in future, "b" doesn't update
* By Reference - when we pass object to function or to new variable, it will point to same memory location. both variable pointing to same memory location in Pass by reference.
    b = a (or pass to a function)
    //so If any changes happen in "a", it will reflect in "b"


25) Javascript Aside: Immediately invoked Function Expressions (IIFEs)
* When we talk about modules, we are not only talking about reusable block of code, but also we are talking about that's protected. Means, code inside module doesn't affect other code. Essentially, we are talking about scope.
* Scope - Where in code you have access to particular variable or function.
* so we need function, which is Immediately invoked by itself.
* Whatever you created variable inside of IIFEs, it is protected. and it doesn't affect outside code and vice versa. That variable is available (scoped) to that function only.
* ex.
var fname = "Jane";
(function (lname){
    var fname = "John";
    console.log(fname);
    console.log(lname);
}('Doe'));
console.log(fname);

John
Doe
Jane


26) How Do Node Modules Really Work?: module.exports and require
* in node, we use "require" and "module.exports" to import and export modules.
* showing internal node code for "require" function.
* while requiring module, it check whether module already cached or not. And if its not cached, then it can cached module.
* if file have extensions other than "JS", just mention it while requiring.
* While running code, first it wraps in function expression with five parameters.
*
    (function(exports, require, module, __filename, __dirname){
        // our code
    });
    fn(exports, require, module, __filename, __dirname);        // node invokes function


27) Javascript Aside: JSON
* JSON - "Javascript object notation" - A standard for structring data that is inspired by Javascript object literals. JS engine are built to understand it.
* in JSON, we have to add names within quotes.

28) More on require -
* If file is not present, then it will look for folder name and goes inside and look for index.js
* when we have bigger module, so that time we have to modularize code. suppose, we have spanish.js and english.js. and we want that code in other separate file.
    // spanish.js
    var greet = () => {
        console.log("Hola");
    }
    module.exports = greet;

    // english.js
    var greet = () => {
        console.log("Hello");
    }
    module.exports = greet;

    //greet/index.js
    var english = require('./english');
    var spanish = require('./spanish');
    module.exports = { english, spanish };

    //app.js
    var greetObj = require("./greetings.json");
    var greet = require("./greet");
    greet.english();
    greet.spanish();


29) Module Patterns -
* we can return single function in module.exports.
    module.exports = function(){
        console.log("Hello");
    }

    // app.js
    var greet = require("./app");
    greet();

* //a0.js
module.exports.greet = function(){
    console.log("hello");
}

// a1.js
var greet2 = require("./greet").greet;

* //a0.js
function Greetr(){
    this.greeting = "Hello";
    this.name = 'sumeet';
}
module.exports = new Greetr();

//a1.js
var greet = require("./a0");
greet()

29 need extra time

30) exports vs module.exports


31. Requiring Native (Core) Modules
* require do much more than requiring modules.
* using require, we can pull core native modules. full details available in "docs/api" in nodeJs official website.
* For node developers, should go through this api docs.
    var util = require("util");
    var name = "sumeet"
    var greeting = util.format('Hello $s', name);
    util.log(greeting);

32) ECMAscript Modules (ESM) -
* ESM example -
    export function greet(){}        // greet.js

    import * as greeter from "greet";
    greetr.greet();


33) package.json


34) ESM and CJS
* to select ESM or CJS, we have to tell explicitly in package.json
    "type": "module"
* In some old npm modules, there are commonjs modules. we have to be careful. Mostly all adapt to ESM.

35) Web Server Checklist - 


36) Conceptual Aside: Events -
* Event - Something that has happened in our app that we can respond to.
* in node, there are two types of events. 
* System events - comes from c++ side of nodejs core, thanks to library called "libuv". Library of c++ code, that deals with events coming from computer system. Those c++ events then allow us to respond to those happening with code.
* Custom Events - they are inside JS core. It's JS library of events that deals with events that i can create for myself. It's JS file that contains the code for what's called the event emitter.
* Whenever event happend in libuv, it generates a custom Javascript Event. JS event is not real events. In JS, there's no eventing concept. so no event object.

37) JavaScript Aside: Object Properties, First Class Functions, and Arrays
* let a = {
    greet: "hello"
}
let prop = "greet"
a.greet         //hello
a['greet']      //hello
a[prop]         //hello
* we can access object property in multiple ways

* function and array - array is collection of anything.
    arr.push(function() {
        console.log("arr push");
    })
    arr.forEach(function(item){
        item()
    })


38) The Node Event Emitter Part 1
* Event Listener - the code that responds to event. When event happen, code (listener) is run. We can have many listeners for same event (one at a time in JS case).

//Emitter.js
function Emitter() {
	this.events = {};
}

Emitter.prototype.on = function(type, listener) {
	this.events[type] = this.events[type] || [];
	this.events[type].push(listener);
}

Emitter.prototype.emit = function(type) {
	if (this.events[type]) {
		this.events[type].forEach(function(listener) {
			listener();
		});
	}
}

module.exports = Emitter;


//app.js
var Emitter = require('./emitter');

var emtr = new Emitter();

emtr.on('greet', function() {
	console.log('Somewhere, someone said hello.');
});

emtr.on('greet', function() {
	console.log('A greeting occurred!');
});

console.log('Hello!');
emtr.emit('greet');

* Event emitter and node uses above idea for event emitter.


39) The node event emitter part 2
* showing event emitter code in node
* using node's own event

// app.js
var Emitter = require('events');
var eventConfig = require('./config').events;

var emtr = new Emitter();

emtr.on(eventConfig.GREET, function() {
	console.log('Somewhere, someone said hello.');
});

emtr.on(eventConfig.GREET, function() {
	console.log('A greeting occurred!');
});

console.log('Hello!');
emtr.emit(eventConfig.GREET);


//config.js
module.exports = {
	events: {
		GREET: 'greet'
	}
}

* magic string - a string that has some special meaning in our code. This is bad because it makes it easy for a typo to cause a bug, and hard for tools to help us find it. so instead of string, we will provide variable, so string will be proper one with everyone.



40) JavaScript Aside: Object.create and Prototypes
* object.create is pure prototypal inheritance. we already added details in JS.

var person = {
			name: "default",
			greet: function () {
				return `Hi ${this.name}`
			}
		}
    var sumeet = Object.create(person);
    console.log(sumeet.name, sumeet);		//default, {}	

    sumeet.name = "Sumeet";
    var add = Object.create(person);
    console.log(add.name);					//default
    add.name = "Aditya";
    
    console.log(sumeet);					//{name:"sumeet"}
    console.log(add);						//{name:"aditya"}


41) Inheriting from the event emitter -
* 

//app.js
var EventEmitter = require('events');
var util = require('util');

function Greetr() {
	this.greeting = 'Hello world!';
}

util.inherits(Greetr, EventEmitter);

Greetr.prototype.greet = function(data) {
	console.log(this.greeting + ': ' + data);
	this.emit('greet', data);
}

var greeter1 = new Greetr();

greeter1.on('greet', function(data) {
	console.log('Someone greeted!: ' + data);
});

greeter1.greet('Tony');

* based on Object.create and prototypal inheritance, node able to inherit properties from one to another


42) Node versioning note -


43. JavaScript Aside: Node, ES6, and Template Literals (Node version <= 12)
* template literals - `my name is ${name}`

44) Javascript Aside: call and apply
* var obj = {
	name: 'John Doe',
	greet: function() {
		console.log(`Hello ${ this.name }`);
	}
}

obj.greet();
obj.greet.call({ name: 'Jane Doe'});
obj.greet.apply({ name: 'Jane Doe'});


45) Inheriting From the event emitter - Part 2 
* 
// app.js
var EventEmitter = require('events');
var util = require('util');

function Greetr() {
	EventEmitter.call(this);
	this.greeting = 'Hello world!';
}

util.inherits(Greetr, EventEmitter);

Greetr.prototype.greet = function(data) {
	console.log(this.greeting + ': ' + data);
	this.emit('greet', data);
}

var greeter1 = new Greetr();

greeter1.on('greet', function(data) {
	console.log('Someone greeted!: ' + data);
});

greeter1.greet('Tony');


//app2.js						
var util = require('util');

function Person() {
	this.firstname = 'John';
	this.lastname = 'Doe';
}

Person.prototype.greet = function() {
	console.log('Hello ' + this.firstname + ' ' + this.lastname);
}

function Policeman() {
	Person.call(this);
	this.badgenumber = '1234';
}

util.inherits(Policeman, Person);
var officer = new Policeman();
officer.greet();


46) Javascript Aside: ES6 Classes -
* class is syntactic sugar.
* 


87. Installing Express and Making it Easier to Build a Web Server
* npm install express --save
* While checking express codebase, we found on calling "createApplicaiton", we got function.
* Enviornment variables - global variables specific to the enviornment (server) our code is living in. Different servers can have different variable settings, and we can access those values in code.
* HTTP method - specifies the type of action the request wishes to make. GET, POST, DELETE, and others. also called verbs.

Code - 
// app.js
var express = require('express');
var app = express();

var port = process.env.PORT || 3000;

app.get('/', function(req, res) {
	res.send('<html><head></head><body><h1>Hello world!</h1></body></html>');
});

app.get('/api', function(req, res) {
	res.json({ firstname: 'John', lastname: 'Doe' });
});

app.listen(port);


88) Routes -
* visit expressjs.com for api docs.
* 
// app.js
var express = require('express');
var app = express();

var port = process.env.PORT || 3000;

app.get('/', function(req, res) {
	res.send('<html><head></head><body><h1>Hello world!</h1></body></html>');
});

app.get('/person/:id', function(req, res) {
	res.send('<html><head></head><body><h1>Person: ' + req.params.id + '</h1></body></html>');
});

app.get('/api', function(req, res) {
	res.json({ firstname: 'John', lastname: 'Doe' });
});

app.listen(port);



89) Static Files and middleware -
* middleware - code that sits between two layers of software. In case of Express, sitting between request and response.
* It alter request and response.
* static file - not dynamic.
* we can create our own middleware too using "app.use"
* show's list of express middleware which is on websit of express.

		var express = require('express');
		var app = express();
		
		var port = process.env.PORT || 3000;		//if env varible is not present, then it will choose 3000
		
		app.use('/assets', express.static(__dirname + '/public'));
		
		app.use('/', function (req, res, next) {			//middleware
			console.log('Request Url:' + req.url);
			next();
		});
		
		app.get('/', function(req, res) {				// request
			res.send('<html><head><link href=assets/style.css type=text/css rel=stylesheet /></head><body><h1>Hello world!</h1></body></html>');
		});
		
		app.get('/person/:id', function(req, res) {
			res.send('<html><head></head><body><h1>Person: ' + req.params.id + '</h1></body></html>');
		});
		
		app.get('/api', function(req, res) {
			res.json({ firstname: 'John', lastname: 'Doe' });
		});
		
		app.listen(port);

90)  Templates and Template Engines
* 

91) Querystring and Post Parameters
* 


94) Structuring an App -
* express generator - used for generating application skeleton
* In application skeleton, we see 4-5 folders like "nodemodules", "router", "views", "public". From that, we are more concerned about "router".
* in app.js, using following code, we can groups our api.
		app.use("/", routes);
		app.use("/users", users);

100) PostgreSQL, Express, React, and NodeJS -
* stack - combination of all technologies used to build a piece of software
